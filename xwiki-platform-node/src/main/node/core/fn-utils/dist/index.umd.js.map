{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\n\n/**\n * Ensure a statement is unreachable\n *\n * @param value - the error value printed when this method is reached\n *\n * @since 0.17\n * @beta\n */\nfunction assertUnreachable(value: never): never {\n  console.error({ unreachable: value });\n  throw new Error(\"Reached a theoretically unreachable statement\");\n}\n\n/**\n * Assert that a value is in an array, and fix its type\n *\n * @since 0.17\n * @beta\n *\n * @param array - the array to check\n * @param value - the value expected in the array\n * @param message - a message displayed in case the value is not found in the array\n *\n * @returns Whether the value is in the provided array, with the correct type\n */\nfunction assertInArray<T, U extends T>(\n  value: T,\n  array: U[],\n  message: string,\n): U {\n  if (!array.includes(value as U)) {\n    throw new Error(message + \": \" + value);\n  }\n\n  return value as U;\n}\n\n/**\n * Get a function's output or `null` if it thrown an error\n *\n * @since 0.17\n * @beta\n *\n * @param func - The function to try\n *\n * @returns The function's output, or `null` if it thrown an error\n */\nfunction tryFallible<T>(func: () => T): T | null {\n  try {\n    return func();\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get a function's output or the thrown error\n * Will construct a new Error object if the thrown value is not an instance of the Error class\n *\n * @since 0.17\n * @beta\n *\n * @param func - The function to try\n *\n * @returns The function's output, the thrown error if it's an instance of the `Error` class, or a constructed `Error` instance\n */\n// eslint-disable-next-line max-statements\nfunction tryFallibleOrError<T>(func: () => T): T | Error {\n  try {\n    return func();\n  } catch (e: unknown) {\n    if (e instanceof Error) {\n      return e;\n    }\n\n    if (typeof e === \"string\") {\n      return new Error(e);\n    }\n\n    if (typeof e === \"number\" || typeof e === \"boolean\") {\n      return new Error(e.toString());\n    }\n\n    if (e === null) {\n      return new Error(\"null\");\n    }\n\n    if (e === undefined) {\n      return new Error(\"undefined\");\n    }\n\n    console.error({ throw: e });\n    return new Error(\"<thrown unknown value type>\");\n  }\n}\n\n/**\n * Get a funcion's promise's output or the thrown error\n * Will construct a new Error object if the thrown value is not an instance of the Error class\n *\n * @since 0.23\n * @beta\n *\n * @param func - The function to try\n *\n * @returns The promise's output, the thrown/resolved error if it's an instance of the `Error` class, or a constructed `Error` instance\n */\n// eslint-disable-next-line max-statements\nasync function tryFalliblePromiseOrError<T>(\n  func: () => Promise<T>,\n): Promise<T | Error> {\n  try {\n    return await func();\n  } catch (e: unknown) {\n    if (e instanceof Error) {\n      return e;\n    }\n\n    if (typeof e === \"string\") {\n      return new Error(e);\n    }\n\n    if (typeof e === \"number\" || typeof e === \"boolean\") {\n      return new Error(e.toString());\n    }\n\n    if (e === null) {\n      return new Error(\"null\");\n    }\n\n    if (e === undefined) {\n      return new Error(\"undefined\");\n    }\n\n    console.error({ throw: e });\n    return new Error(\"<thrown unknown value type>\");\n  }\n}\n\n/**\n * Provide a type for expressions type inference\n *\n * This is actually an identity function - the provided value is returned as is, with no other operation.\n *\n * @since 0.20\n * @beta\n *\n * @param value - The value to return\n * @returns - The provided value\n *\n * @example `[1].concat(\"Hello\")` // Type error\n * @example `provideTypeInference<number | string>([1].concat(\"Hello\"))` // Works\n */\nfunction provideTypeInference<T>(value: T): T {\n  return value;\n}\n\n/**\n * Filter and map an array's values\n *\n * Combines both `.filter` and `.map` with the additional benefit of conditional type predicates\n *\n * @since 0.20\n * @beta\n *\n * @example `filterMap([1, 2, 3], value => value >= 2 ? value.toString() : null) // ['2', '3']`\n *\n * @param array - The array to map\n * @param filterMap - The function performing the mapping and filtering. Returning `null` or `undefined` corresponds to filter values out.\n *\n * @returns The filtered and mapped array\n */\nfunction filterMap<T, U>(\n  array: T[],\n  filterMap: (value: T, index: number) => U | null | undefined,\n): U[] {\n  return array\n    .map(filterMap)\n    .filter((value) => value !== null && value !== undefined);\n}\n\n/**\n * Get correctly-typed object entries, functionally equivalent to `Object.entries`\n *\n * Fixes builtin `Object.entries` which types the returned object values as `any`\n *\n * @param obj - The object to get the entries of\n *\n * @returns - The correctly-typed object's entries\n *\n * @since 0.23\n * @beta\n */\nfunction objectEntries<O extends Record<string, unknown>>(\n  obj: O,\n): Array<[keyof O & string, O[keyof O]]> {\n  return Object.entries(obj) as Array<[keyof O & string, O[keyof O]]>;\n}\n\n/**\n * Generic tree structure type.\n * @since 0.23\n * @beta\n */\ntype TreeNode<T> = T & {\n  children?: TreeNode<T>[];\n};\n\nexport {\n  assertInArray,\n  assertUnreachable,\n  filterMap,\n  objectEntries,\n  provideTypeInference,\n  tryFallible,\n  tryFallibleOrError,\n  tryFalliblePromiseOrError,\n};\n\nexport type { TreeNode };\n"],"names":["assertUnreachable","value","assertInArray","array","message","tryFallible","func","tryFallibleOrError","e","tryFalliblePromiseOrError","provideTypeInference","filterMap","objectEntries","obj"],"mappings":"2OA4BA,SAASA,EAAkBC,EAAqB,CAC9C,cAAQ,MAAM,CAAE,YAAaA,CAAA,CAAO,EAC9B,IAAI,MAAM,+CAA+C,CACjE,CAcA,SAASC,EACPD,EACAE,EACAC,EACG,CACH,GAAI,CAACD,EAAM,SAASF,CAAU,EAC5B,MAAM,IAAI,MAAMG,EAAU,KAAOH,CAAK,EAGxC,OAAOA,CACT,CAYA,SAASI,EAAeC,EAAyB,CAC/C,GAAI,CACF,OAAOA,EAAA,CACT,MAAQ,CACN,OAAO,IACT,CACF,CAcA,SAASC,EAAsBD,EAA0B,CACvD,GAAI,CACF,OAAOA,EAAA,CACT,OAASE,EAAY,CACnB,OAAIA,aAAa,MACRA,EAGL,OAAOA,GAAM,SACR,IAAI,MAAMA,CAAC,EAGhB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACjC,IAAI,MAAMA,EAAE,UAAU,EAG3BA,IAAM,KACD,IAAI,MAAM,MAAM,EAGrBA,IAAM,OACD,IAAI,MAAM,WAAW,GAG9B,QAAQ,MAAM,CAAE,MAAOA,CAAA,CAAG,EACnB,IAAI,MAAM,6BAA6B,EAChD,CACF,CAcA,eAAeC,EACbH,EACoB,CACpB,GAAI,CACF,OAAO,MAAMA,EAAA,CACf,OAASE,EAAY,CACnB,OAAIA,aAAa,MACRA,EAGL,OAAOA,GAAM,SACR,IAAI,MAAMA,CAAC,EAGhB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACjC,IAAI,MAAMA,EAAE,UAAU,EAG3BA,IAAM,KACD,IAAI,MAAM,MAAM,EAGrBA,IAAM,OACD,IAAI,MAAM,WAAW,GAG9B,QAAQ,MAAM,CAAE,MAAOA,CAAA,CAAG,EACnB,IAAI,MAAM,6BAA6B,EAChD,CACF,CAgBA,SAASE,EAAwBT,EAAa,CAC5C,OAAOA,CACT,CAiBA,SAASU,EACPR,EACAQ,EACK,CACL,OAAOR,EACJ,IAAIQ,CAAS,EACb,OAAQV,GAAUA,GAAU,IAA2B,CAC5D,CAcA,SAASW,EACPC,EACuC,CACvC,OAAO,OAAO,QAAQA,CAAG,CAC3B"}