<?xml version="1.1" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc version="1.5" reference="XWiki.InplaceEditing" locale="">
  <web>XWiki</web>
  <name>InplaceEditing</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <parent>WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <version>1.1</version>
  <title/>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>true</hidden>
  <content>{{velocity wiki="false"}}
#if ($request.action == 'lock')
  ## This could be moved later to a Velocity template (e.g. lock.vm).
  ## We set the editor variable to be able to detect the inplace editor within the edit confirmation checkers.
  #set ($editor = 'inplace')
  #template('edit_macros.vm')
  #getEditConfirmation()
  #if ($editConfirmation)
    ## Ask for confirmation to force the lock.
    #set ($discard = $response.setStatus(423))
    #jsonResponse($editConfirmation)
  #else
    ## Lock the document for editing.
    #set ($lockParams = {
      'ajax': 1,
      'action': $request.lockAction,
      'language': $tdoc.realLocale
    })
    #if ($request.force == 'true')
      #set ($lockParams.force = 1)
    #end
    #set ($discard = $response.sendRedirect($tdoc.getURL('lock', $escapetool.url($lockParams))))
  #end
#end
{{/velocity}}</content>
  <object>
    <name>XWiki.InplaceEditing</name>
    <number>0</number>
    <className>XWiki.JavaScriptExtension</className>
    <guid>700dc756-1a3a-49e0-854f-c2ecb0d8e970</guid>
    <class>
      <name>XWiki.JavaScriptExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <defaultValue>long</defaultValue>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <restricted>0</restricted>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage|onDemand|always</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>(function(config) {
  "use strict";

const paths = config.paths;
const l10n = config.l10n;

require.config({
  paths: paths.js
});

define('xwiki-document-api', ['jquery', 'xwiki-meta'], function($, xcontext) {
  function getOldAPI(xwikiDocument) {
    return (xwikiDocument.documentReference &amp;&amp; new XWiki.Document(xwikiDocument.documentReference)) ||
      XWiki.currentDocument;
  }

  class XWikiDocument {
    constructor() {
      // Initialize based on the current document.
      this.documentReference = xcontext.documentReference;
      this.language = xcontext.locale;
      this.version = xcontext.version;
      this.isNew = xcontext.isNew;
      this.renderedTitle = $('#document-title h1').html();
      this.renderedContent = $('#xwikicontent').html();

      if (!this.language) {
        // We know this is the original document translation, but we don't know it's actual (real) locale (which may be
        // different from the current UI locale if this document doesn't have a translation for the current UI locale).
        const docVariant = new URLSearchParams(XWiki.docvariant);
        this.translations = this.translations || {};
        this.translations['default'] = docVariant.get('language');
      }
    }

    /**
     * @return this document's plain title
     */
    getPlainTitle() {
      return $('&lt;div/&gt;').html(this.renderedTitle || this.title).text();
    }

    /**
     * @return this document's real locale
     */
    getRealLocale() {
      var realLocale = this.language;
      if (typeof realLocale !== 'string' || realLocale === '') {
        realLocale = this.getDefaultLocale();
      }
      return realLocale;
    }

    /**
     * @return this document's default locale
     */
    getDefaultLocale() {
      if (this.translations &amp;&amp; typeof this.translations['default'] === 'string') {
        return this.translations['default'];
      } else {
        // The default locale is not specified. Use the UI locale.
        return $('html').attr('lang');
      }
    }

    /**
     * @return the URL that can be used to perform the specified action on this document
     */
    getURL(action, queryString, fragment) {
      if (queryString &amp;&amp; typeof queryString === 'object') {
        queryString = $.param(queryString, true);
      }
      // Forward the call to the old API.
      var oldAPI = getOldAPI(this);
      return oldAPI.getURL.call(oldAPI, action, queryString, fragment);
    }

    /**
     * @param queryString the query string to add to the URL; it can be a string or a plain JavaScript object
     * @return the URL that can be used to retrieve this document's (JSON) data, taking into account whether this is the
     *         original document or a translation
     */
    getRestURL(queryString) {
      var oldAPI = getOldAPI(this);
      if (queryString &amp;&amp; typeof queryString === 'object') {
        queryString = $.param(queryString, true);
      }
      var entity = this.language &amp;&amp; ('translations/' + encodeURIComponent(this.language));
      return oldAPI.getRestURL(entity, queryString);
    }

    /**
     * Render the title and the content of this document.
     *
     * @param forView whether to render the document for view (without the rendering annotations) or for edit (with the
     *          rendering annotations); when rendering for edit some transformations might not be executed
     * @return a promise that resolves to this document instance if the render request succeeds
     */
    render(forView) {
      var queryString = {
        xpage: 'get',
        outputTitle: true,
        // Render the default translation if this is a new document:
        // * if it's a new document then we need to create the default translation first
        // * if it's a new translation then we want to initialize the translation with the title and content from the
        //   default translation
        language: (this.isNew ? '' : this.getRealLocale()),
        // Make sure the response is not retrieved from cache (IE11 doesn't obey the caching HTTP headers).
        timestamp: new Date().getTime()
      };
      if (!forView) {
        // We need the annotated HTML when editing in order to be able to protect the rendering transformations and to
        // be able to recreate the wiki syntax.
        queryString.outputSyntax = 'annotatedhtml';
        queryString.outputSyntaxVersion = '5.0'
        // Currently, only the macro transformations are protected and thus can be edited.
        // See XRENDERING-78: Add markers to modified XDOM by Transformations/Macros
        queryString.transformations = 'macro';
      }
      return Promise.resolve($.get(this.getURL('view'), queryString)).then(html =&gt; {
        // Render succeeded.
        var container = $('&lt;div/&gt;').html(html);
        return $.extend(this, {
          renderedTitle: container.find('#document-title h1').html(),
          renderedContent: container.find('#xwikicontent').html()
        });
      }).catch(() =&gt; {
        new XWiki.widgets.Notification(l10n['edit.inplace.page.renderFailed'], 'error');
        return Promise.reject(this);
      });
    }

    /**
     * Reload this document's (JSON) data.
     *
     * @return a promise that resolves to this document instance if the reload request succeeds
     */
    reload() {
      return Promise.resolve($.getJSON(this.getRestURL(), {
        // Make sure the response is not retrieved from cache (IE11 doesn't obey the caching HTTP headers).
        timestamp: new Date().getTime()
      })).then(newXWikiDocument =&gt; {
        // Reload succeeded.
        // Resolve the document reference.
        this.documentReference = XWiki.Model.resolve(newXWikiDocument.id, XWiki.EntityType.DOCUMENT);
        // We were able to load the document so it's not new.
        this.isNew = false;
        return $.extend(this, newXWikiDocument);
      }).catch(response =&gt; {
        if (response.status === 404) {
          // This document doesn't exist.
          if (this.language === '') {
            // The default document translation doesn't exist. It needs to be created before the other translations.
            this.markAsNew();
            return this;
          } else {
            // This document translation doesn't exist. Initialize it with the values from the default translation.
            const language = this.language;
            // Reload the default translation and then restore the language.
            this.language = '';
            return this.reload().then(() =&gt; {
              // If the default translation exists then use it to initialize the current translation. Otherwise, we have
              // to create the default translation first.
              if (!this.isNew) {
                this.translate(language);
              }
              return this;
            });
          }
        } else {
          // Reload failed.
          return Promise.reject(this);
        }
      });
    }

    markAsNew() {
      this.isNew = true;
      delete this.version;
      delete this.majorVersion;
      delete this.minorVersion;
    }

    /**
     * Lock this document for the specified action. The request fails if the document is already locked, unless the lock
     * is forced.
     *
     * @return a promise that resolves to this document instance if the lock request succeeds
     */
    lock(action, force) {
      action = action || 'edit';
      return Promise.resolve($.getJSON(this.getURL('get'), {
        sheet: 'XWiki.InplaceEditing',
        action: 'lock',
        lockAction: action,
        force: force,
        language: this.getRealLocale(),
        outputSyntax: 'plain',
        // Make sure the response is not retrieved from cache (IE11 doesn't obey the caching HTTP headers).
        timestamp: new Date().getTime()
      })).then(() =&gt; {
        // Lock succeeded.
        this.locked = action;
        return this;
      }).catch(response =&gt; {
        // Lock failed.
        delete this.locked;
        // Check if the user can force the lock.
        var lockConfirmation = response.responseJSON;
        if (response.status === 423 &amp;&amp; lockConfirmation) {
          // The user can force the lock, but needs confirmation.
          this.lockConfirmation = lockConfirmation;
        }
        return Promise.reject(this);
      });
    }

    /**
     * Unlock this document for the specified action, by sending a beacon, if the browser supports it, or by making a
     * synchronous HTTP request, because this function can be called just before the window is unloaded.
     */
    unlock(action) {
      action = action || 'edit';
      this.locked = false;
      var url = this.getURL('cancel', $.param({
        ajax: 1,
        action: action,
        language: this.getRealLocale()
      }));
      if (navigator.sendBeacon) {
        navigator.sendBeacon(url);
      } else {
        // Make a synchronous request otherwise, because the page can unload before the unlock request is sent.
        // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests
        $.ajax({type: 'GET', url: url, async: false});
      }
    }

    /**
     * Makes sure this document matches the current UI locale.
     *
     * @param language the language for which to create the translation; if not specified then the current UI language
     *                 is used
     */
    translate(language) {
      const realLocale = this.getRealLocale();
      language = language || $('html').attr('lang');
      if (realLocale &amp;&amp; realLocale !== language) {
        // Backup the default translation.
        this.backup('defaultTranslation');
        this.language = language;
        // Set the original document locale.
        this.translations = this.translations || {};
        this.translations['default'] = realLocale;
        // Update the document fields that are not 'shared' with the original document.
        this.markAsNew();
      }
    }

    /**
     * Back up the current state of this document instance in a special field named {@code originalDocument}, that can
     * be used to restore the current state later.
     */
    backup(backupName) {
      backupName = backupName || 'originalDocument';
      delete this[backupName];
      this[backupName] = $.extend(true, new XWikiDocument(), this);
    }
  }

  return XWikiDocument;
});

define('editInPlace', [
  'jquery',
  // We need this in order to access information about the current page.
  'xwiki-meta',
  // We need this in order to easily work with the XWiki document JSON.
  'xwiki-document-api',
  // We need this for the confirmation modals.
  'bootstrap',
  // We need this in order to catch events triggered by actionButtons.js using Prototype.js
  'xwiki-events-bridge'
], function($, xcontext, XWikiDocument) {
  var preload = function() {
    paths.css.forEach(loadCSS);
    return initActionButtons();
  };

  var loadCSS = function(url) {
    $('&lt;link/&gt;').attr({
      type: 'text/css',
      rel: 'stylesheet',
      href: url
    }).appendTo('head');
  };

  // We preserve the document data between edits in order to be able to know which document translation should be edited
  // (e.g. when the document translation is missing and we create it, the next edit session should target the created
  // translation).
  let currentXWikiDocument;

  function getCurrentXWikiDocument() {
    if (!currentXWikiDocument) {
      // We initialize the current document late, based on the metadata and HTML available right before edit.
      currentXWikiDocument = new XWikiDocument();
    }
    return currentXWikiDocument;
  }

  function setCurrentXWikiDocument(xwikiDocument) {
    currentXWikiDocument = xwikiDocument;
    return Promise.resolve(xwikiDocument);
  }

  var editPage = function() {
    return editInPlace({
      afterEdit: function() {
        $('#document-title-input').focus().select();
      }
    });
  };

  var translatePage = function() {
    // We have to change the locale of the current document before we start editing in order to lock the translation
    // that is going to be created, not the default translation. Moreover, some editors may rely on the locale. For
    // instance the realtime editor needs to fetch the Netflux channel keys associated with the new document translation
    // (not the default one).
    getCurrentXWikiDocument().translate();
    return editInPlace({
      // This is called after the title and content editors have been loaded. It shows a popover message indicating to
      // the user that they are creating a new translation for the current UI locale.
      afterEdit: createTranslation
    });
  };

  var editSection = function(sectionId) {
    return editInPlace({
      lockFailed: function() {
        // Revert the changes done on #xwikicontent.
        $('#xwikicontent').removeAttr('tabindex').children(':header').children('.edit_section').removeClass('hidden');
      },
      afterEdit: function() {
        // We don't need the tabindex attribute anymore now that the content is editable.
        $('#xwikicontent').removeAttr('tabindex');
        if (sectionId) {
          // Select the heading of the specified section.
          $('#xwikicontent &gt; #' + $.escapeSelector(sectionId)).each(function() {
            selectText(this);
          });
        }
      }
    });
  };

  var editInPlace = function(options) {
    options = $.extend({
      afterEdit: function() {},
      lockFailed: function() {}
    }, options);
    $('#xwikicontent').addClass('loading');
    // Lock the document first.
    return lock(getCurrentXWikiDocument())
      // Then load the document only if we managed to lock it.
      .then(load, xwikiDocument =&gt; {
        options.lockFailed(xwikiDocument);
        return Promise.reject(xwikiDocument);
      // Then load the editors only if we managed to load the document.
      }).then(edit).then(xwikiDocument =&gt; {
        options.afterEdit(xwikiDocument);
        return xwikiDocument;
      }).finally(() =&gt; {
        // Remove the aria-expanded attribute which is incorrect for role=textbox
        $('#xwikicontent').removeClass('loading').removeAttr('aria-expanded');
      // Then wait for an action (save, cancel, reload) only if the editors were loaded successfully.
      }).then(maybeSave)
      // Then unlock the document both when the edit ended with success and with a failure.
      .then(unlock, unlock)
      // Finally view the document both when the edit ended with success and with a failure.
      .then(view, view)
      // Update the current document for the next edit session.
      .then(setCurrentXWikiDocument, setCurrentXWikiDocument);
  };

  var lock = function(xwikiDocument) {
    return xwikiDocument.lock().catch(function(xwikiDocument) {
      // If the document was already locked then we need to ask the user if they want to force the lock.
      if (xwikiDocument.lockConfirmation) {
        var confirmation = xwikiDocument.lockConfirmation;
        delete xwikiDocument.lockConfirmation;
        return maybeForceLock(confirmation).then(xwikiDocument.lock.bind(xwikiDocument, 'edit', true), function() {
          // Cancel the edit action.
          return Promise.reject(xwikiDocument);
        });
      } else {
        new XWiki.widgets.Notification(l10n['edit.inplace.page.lockFailed'], 'error');
        return Promise.reject(xwikiDocument);
      }
    });
  };

  var maybeForceLock = function(confirmation) {
    var deferred, promise = new Promise((resolve, reject) =&gt; {
      deferred = {resolve, reject};
    });
    // We need the catch() to prevent the "Uncaught (in promise)" error log in the console.
    promise.catch(() =&gt; {}).finally(() =&gt; {
      // This flag is used by the Force Lock modal to know whether the promise is settled when the modal is closing.
      deferred.settled = true;
    });
    // Reuse the confirmation modal once it is created.
    var modal = $('.force-edit-lock-modal');
    if (!modal.length) {
      modal = createForceLockModal();
    }
    // Update the deferred that needs to be resolved or rejected.
    modal.data('deferred', deferred);
    // Update the confirmation modal.
    modal.find('.modal-title').text(confirmation.title);
    modal.find('.modal-body').html(confirmation.message);
    modal.find('.modal-footer .btn-default').text(confirmation.reject);
    if (confirmation.confirm) {
      modal.find('.modal-footer .btn-warning').show().text(confirmation.confirm);
    } else {
      modal.find('.modal-footer .btn-warning').hide();
    }
    // Show the confirmation modal.
    modal.modal('show');
    return promise;
  };

  var createForceLockModal = function() {
    var modal = $([
      '&lt;div class="modal fade force-edit-lock-modal" tabindex="-1" role="dialog"&gt;',
        '&lt;div class="modal-dialog" role="document"&gt;',
          '&lt;div class="modal-content"&gt;',
            '&lt;div class="modal-header"&gt;',
              '&lt;button type="button" class="close" data-dismiss="modal"&gt;',
                '&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;',
              '&lt;/button&gt;',
              '&lt;h4 class="modal-title"&gt;&lt;/h4&gt;',
            '&lt;/div&gt;',
            '&lt;div class="modal-body"&gt;&lt;/div&gt;',
            '&lt;div class="modal-footer"&gt;',
              '&lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;&lt;/button&gt;',
              '&lt;button type="button" class="btn btn-warning"&gt;&lt;/button&gt;',
            '&lt;/div&gt;',
          '&lt;/div&gt;',
        '&lt;/div&gt;',
      '&lt;/div&gt;'
    ].join(''));
    modal.find('.close').attr('aria-label', l10n['edit.inplace.close']);
    modal.find('.modal-footer .btn-warning').on('click', function() {
      // The user has confirmed they want to force the lock.
      modal.data('deferred').resolve();
      modal.modal('hide');
    });
    modal.on('hide.bs.modal', function() {
      // If the lock promise is not yet settled when the modal is closing then it means the modal was canceled,
      // i.e. the user doesn't want to force the lock.
      var deferred = modal.data('deferred');
      if (!deferred.settled) {
        deferred.reject();
      }
    });
    return modal.appendTo('body').modal();
  };

  var load = function(xwikiDocument) {
    return xwikiDocument.reload().then(xwikiDocument =&gt; {
      // Clone the current document version and keep a reference to it in order to be able to restore it on cancel.
      xwikiDocument.backup();
      return xwikiDocument;
    }).catch(xwikiDocument =&gt; {
      new XWiki.widgets.Notification(l10n['edit.inplace.page.loadFailed'], 'error');
      return Promise.reject(xwikiDocument);
    // Render the document for edit, in order to have the annotated content HTML. The annotations are used to protect
    // the rendering transformations (e.g. macros) when editing the content.
    }).then(render.bind(null, false));
  };

  /**
   * @param forView whether to render the document for view (without the rendering annotations) or for edit (with the
   *          rendering annotations); when rendering for edit some transformations might not be executed
   * @param xwikiDocument the document to render
   */
  var render = function(forView, xwikiDocument) {
    return xwikiDocument.render(forView);
  };

  var maybeSave = function(xwikiDocument) {
    return waitForAction(xwikiDocument).then(action =&gt; {
      switch(action.name) {
        case 'save': return save({
          document: action.document,
          'continue': action.data &amp;&amp; action.data['continue']
        });
        case 'reload': return reload(action.document);
        default: return cancel(action.document);
      }
    });
  };

  var waitForAction = function(xwikiDocument) {
    return new Promise((resolve, reject) =&gt; {
      // We wait for the first save, reload or cancel event, whichever is triggered first. Note that the event listeners
      // that are not executed first will remain registered but that doesn't cause any problems because the state of a
      // deferred object (promise) cannot change once it was resolved. So the first event that fires will resolve the
      // promise and the remaining events won't be able to change that. The remaining event listeners could be called
      // later but they won't have any effect on the deferred object.
      $(document).one([
        'xwiki:actions:save',
        'xwiki:actions:reload',
        'xwiki:actions:cancel',
      ].join(' '), '.xcontent.form', function(event, data) {
        resolve({
          name: event.type.substring('xwiki:actions:'.length),
          document: xwikiDocument,
          data: data
        });
      });
    });
  };

  var save = function(data) {
    // Push the changes to the server.
    return push(data.document).then(xwikiDocument =&gt; {
      // Save succeeded.
      return shouldReload(xwikiDocument).then(
        // The document was saved with merge and thus if we want to continue editing we need to reload the editor
        // (because its content doesn't match the saved content).
        reload,
        // No need to reload the editor because either the action was Save &amp; View or there was no merge on save.
        maybeContinueEditing.bind(null, data['continue'])
      );
    // Save failed. Continue editing because we may have unsaved content.
    }, maybeSave);
  };

  var push = function(xwikiDocument) {
    // Let actionButtons.js do the push. We just catch the result.
    return new Promise((resolve, reject) =&gt; {
      // We wait for the save request to either succeed or fail. Note that one of the event listeners will remain
      // registered but that doesn't cause any problems because the state of a deferred object (promise) cannot change
      // once it was resolved or rejected. So the first event that fires will resolve/reject the promise and the
      // remaining event won't be able to change that. The remaining event listener could be called later but it won't
      // have any effect.
      $(document).one('xwiki:document:saved', '.xcontent.form', resolve.bind(null, xwikiDocument));
      $(document).one('xwiki:document:saveFailed', '.xcontent.form', reject.bind(null, xwikiDocument));
    });
  };

  var maybeContinueEditing = function(continueEditing, xwikiDocument) {
    var afterReloadAndRender = function(success, xwikiDocument) {
      if (continueEditing) {
        if (success) {
          // Update the original version in order to be able to restore it on cancel.
          xwikiDocument.backup();
        }
        // Continue editing.
        return maybeSave(xwikiDocument);
      } else {
        // This is the final version. We stop editing even if the reload / render failed.
        return xwikiDocument;
      }
    };

    // Reload the document JSON data (to have the new version) and render the document for view. We need the view HTML
    // both if we stop editing now and if we continue but cancel the edit later.
    return xwikiDocument.reload().then(render.bind(null, true)).then(
      afterReloadAndRender.bind(null, /* success: */ true),
      afterReloadAndRender.bind(null, /* success: */ false)
    );
  };

  var cancel = function(xwikiDocument) {
    // Simply return the original version to be restored.
    return xwikiDocument.originalDocument;
  };

  // Unlock the document so that other users can edit it.
  var unlock = function(xwikiDocument) {
    // Check if we're still editing.
    if (xwikiDocument.locked &amp;&amp; $('#document-title-input').length &gt; 0) {
      xwikiDocument.unlock();
    }
    return xwikiDocument;
  };

  // Make sure we unlock the document when the user navigates to another page.
  $(window).on('unload pagehide', () =&gt; {
    unlock(getCurrentXWikiDocument());
  });

  var shouldReload = function(xwikiDocument) {
    var reloadEventFired = false;
    $(document).one('xwiki:actions:reload.maybe', '.xcontent.form', function() {
      reloadEventFired = true;
    });
    return new Promise((resolve, reject) =&gt; {
      // Wait a bit to see if the reload event is fired.
      setTimeout(function() {
        // Remove the listener in case the reload event wasn't fired.
        $(document).off('xwiki:actions:reload.maybe');
        if (reloadEventFired) {
          resolve(xwikiDocument);
        } else {
          reject(xwikiDocument);
        }
      }, 0);
    });
  };

  var reload = function(xwikiDocument) {
    // Leave the edit mode and then re-enter.
    return view(xwikiDocument, true).then(editInPlace);
  };

  var view = function(xwikiDocument, reload) {
    if (xwikiDocument.isNew &amp;&amp; xwikiDocument.language &amp;&amp; xwikiDocument.defaultTranslation) {
      // The user tried to translate the current document in the UI locale and either canceled the edit without saving
      // or there was an error. Display the default translation to the user.
      xwikiDocument = xwikiDocument.defaultTranslation;
    }

    var viewContent = $('#xwikicontent');
    // Destroy the editors before returning to view.
    viewContent.trigger('xwiki:actions:view', {document: xwikiDocument});
    $('#document-title h1').html(xwikiDocument.renderedTitle);
    viewContent.html(xwikiDocument.renderedContent);
    // Reset the editor to let others know that we're not editing anymore.
    XWiki.editor = '';
    if (!reload) {
      // If the user has canceled the edit then the restored page content may include the section edit links. Show them
      // in case they were hidden.
      viewContent.children(':header').children('.edit_section').removeClass('hidden');
      // Let others know that the DOM has been updated, in order to enhance it.
      $(document).trigger('xwiki:dom:updated', {'elements': viewContent.toArray()});
    }
    // Remove the action events scope.
    viewContent.closest('.form').removeClass('form');
    // Update the URL.
    if (window.location.hash === '#edit' || window.location.hash === '#translate') {
      history.replaceState(null, null, '#');
    }
    return Promise.resolve(xwikiDocument);
  };

  var edit = function(xwikiDocument) {
    // By adding the 'form' CSS class we set the scope of the action events (e.g. xwiki:actions:beforeSave or
    // xwiki:actions:cancel). We need this because in view mode we can have multiple forms active on the page (e.g. one
    // for editing the document content in place and one for editing the document syntax in-place) and we don't want
    // them to interfere (e.g. canceling one form shouldn't cancel the other forms).
    $('#xwikicontent').closest('.xcontent').addClass('form');
    // Let others know which editor is used for the page content.
    XWiki.editor = config.editMode;
    return initActionButtons(xwikiDocument).then(initTitleEditor).then(initContentEditor);
  };

  var initActionButtons = function(xwikiDocument) {
    if (xwikiDocument) {
      initTranslateButton(xwikiDocument);
    }
    var editContent = $('#xwikicontent');
    // We need the wrapper because #xwikicontent uses Bootstrap grid (col-xs-12) which is implemented with CSS float.
    // Thus we need to use the grid for the sticky buttons also otherwise the position is badly computed when scrolling
    // (because of the float on the previous element). This wouldn't be needed if we were using position:sticky, which
    // we can't use yet because it's not implemented on IE11 which we still have to support.
    let inplaceEditingForm = editContent.nextAll('form#inplace-editing');
    if (!inplaceEditingForm.length) {
      // The 'xwikieditcontent' id is needed for the auto-save feature (otherwise it doesn't find the form).
      inplaceEditingForm = $(`
        &lt;form id="inplace-editing" class="col-xs-12"&gt;
          &lt;div hidden&gt;
            &lt;input type="hidden" name="form_token" /&gt;
            &lt;input type="hidden" name="async" value="true" /&gt;
            &lt;input type="hidden" name="content" /&gt;
            &lt;input type="hidden" name="RequiresHTMLConversion" value="content" /&gt;
            &lt;input type="hidden" name="content_syntax" /&gt;
            &lt;input type="hidden" name="language" /&gt;
          &lt;/div&gt;
          &lt;fieldset id="xwikieditcontent" class="xform inplace-editing-buttons sticky-buttons"&gt;&lt;/fieldset&gt;
        &lt;/form&gt;
      `).attr('action', XWiki.currentDocument.getURL('save'))
        .insertAfter(editContent).toggle(!!xwikiDocument);
      inplaceEditingForm.find('input[name="form_token"]').val(xcontext.form_token);
      var actionButtons = inplaceEditingForm.children('.sticky-buttons').data('xwikiDocument', xwikiDocument);
      return loadActionButtons(actionButtons);
    } else {
      // If we're editing a page..
      if (xwikiDocument) {
        // ..then make sure the action buttons are displayed right away (don't wait for the user to scroll).
        inplaceEditingForm.show().children('.sticky-buttons')
          .data('xwikiDocument', xwikiDocument)
          // Make sure the position of the action buttons is updated.
          .trigger('xwiki:dom:refresh')
          // The action buttons are disabled on Save &amp; View. We don't reload the page on Save &amp; View and we reuse the
          // action buttons so we need to re-enable them each time we enter the edit mode.
          .prop('disabled', false);
        // Cleanup the extra hidden input fields that actionButtons.js might have appended to the form. We have to do
        // this each time the form is (re)enabled (i.e. after a failed Save &amp; View or before entering the edit mode)
        // because they are designed to be used once.
        inplaceEditingForm.children('fieldset').nextAll().remove();
      }
      return Promise.resolve(xwikiDocument);
    }
  };

  var createTranslation = function(xwikiDocument) {
    $('#document-title-input').focus().select();
    // Let the user know that they are now editing the translation of this page in the current locale.
    $('#document-title-input').popover({
      content: l10n['edit.inplace.page.translate.messageAfter'],
      placement: 'bottom',
      trigger: 'manual'
    }).popover('show').one('blur', function() {
      // Hide the popover when the title input loses the focus.
      $(this).popover('hide');
    });
  };

  var initTranslateButton = function(xwikiDocument) {
    // Initialize the translate button only if it's visible.
    const translateButton = $(config.translateButtonSelector).filter('[data-toggle="popover"]').filter(':visible');
    // Let the user know that they are editing the original version of the page and not the translation corresponding
    // to the current locale because there isn't one created yet.
    translateButton.attr({
      // Backup the initial popover message to be able to restore it on view.
      'data-content-view': translateButton.attr('data-content'),
      // Use a custom popover message dedicated to the edit action.
      'data-content': l10n['edit.inplace.page.translate.messageBefore']
    }).popover('show')
    // Hide the popover on the next click. The user can still see the message by hovering the translate button.
    .closest('html').one('click', function() {
      translateButton.popover('hide');
    });
  };

  var loadActionButtons = function(actionButtons) {
    // We want to update the form data as late as possible (but still before the form is validated), in order to allow
    // the title and content editors to update their values and the 'xwikiDocument' instance. We do this by catching the
    // event early (lower in the DOM, at the start of the event bubbling phase) and adding a one time event listener for
    // the end of the event bubbling phase at the top level of the DOM document.
    actionButtons.on('xwiki:actions:beforeSave', function() {
      $(document).one('xwiki:actions:beforeSave', updateFormDataBeforeSave);
    });
    actionButtons.on('xwiki:actions:cancel', function(event) {
      // We are already in view mode so there's no need to leave the page.
      event.preventDefault();
    });
    $(document).on('xwiki:actions:view', '.xcontent.form', function(event, data) {
      // Blur the action buttons first to re-enable the "disabled in inputs" shortcut keys (e.g. the page edit
      // shortcut), then disable the action buttons in order to disable their shortcut keys while we're not editing
      // in-place (e.g. prevent the Save shortcut while the user is only viewing the page). Finally hide the action
      // buttons to have them ready for the next editing session (the user can save or cancel and then edit again
      // without reloading the page).
      actionButtons.find(':input').blur().end().prop('disabled', true).parent().hide();
      // Restore the Translate button if the locale of the viewed document doesn't match the current user interface
      // locale (because the viewed document doesn't have a translation in the current locale).
      var xwikiDocumentLocale = data.document.getRealLocale();
      var uiLocale = $('html').attr('lang');
      if (xwikiDocumentLocale &amp;&amp; xwikiDocumentLocale !== uiLocale) {
        const translateButton = $(config.translateButtonSelector).filter('[data-toggle="popover"]');
        translateButton
          // Restore the popover text for view action.
          .attr('data-content', translateButton.attr('data-content-view') || translateButton.attr('data-content'))
          // Restore the visibility.
          .parent().removeClass('hidden');
      }
    });
    return Promise.resolve($.get(XWiki.currentDocument.getURL('get'), {
      xpage: 'editactions'
    })).then(html =&gt; {
      actionButtons.html(html);
      // Fix the name of the Save &amp; View action.
      actionButtons.find('.btn-primary').first().attr('name', 'action_save');
      // Let the others know that the DOM has been updated, in order to enhance it.
      $(document).trigger('xwiki:dom:updated', {'elements': actionButtons.toArray()});
      return new Promise((resolve, reject) =&gt; {
        require(['xwiki-actionButtons', 'xwiki-diff', 'xwiki-autoSave'], function() {
          overrideAjaxSaveAndContinue();
          var xwikiDocument = actionButtons.data('xwikiDocument');
          // Enable the action buttons (and their shortcut keys) only if we're editing a document.
          actionButtons.prop('disabled', !xwikiDocument);
          resolve(xwikiDocument);
        });
      });
    }).catch(() =&gt; {
      new XWiki.widgets.Notification(l10n['edit.inplace.actionButtons.loadFailed'], 'error');
    });
  };

  var updateFormDataBeforeSave = function() {
    const form = $('form#inplace-editing');
    const xwikiDocument = form.children('.sticky-buttons').data('xwikiDocument');

    form.find('input[name="language"]').val(xwikiDocument.getRealLocale());
    form.find('input[name="isNew"]').val(xwikiDocument.isNew);

    // Submit either the raw (source) content (no syntax conversion needed in this case) or the rendered content (HTML)
    // in which case we have to force the conversion to the document syntax on the server.
    const submitRawContent = typeof xwikiDocument.renderedContent !== 'string';
    form.find('input[name="content"]').val(submitRawContent ? xwikiDocument.content : xwikiDocument.renderedContent);
    form.find('input[name="RequiresHTMLConversion"]').prop('disabled', submitRawContent);
    form.find('input[name="content_syntax"]').val(xwikiDocument.syntax).prop('disabled', submitRawContent);

    // Add the temporary uploaded files to the form.
    $('#xwikicontent').nextAll('input[name="uploadedFiles"]').attr('form', 'inplace-editing');

    // Check for merge conflicts only if the document is not new and we know the current version.
    if (!xwikiDocument.isNew &amp;&amp; xwikiDocument.version) {
      form.find('input[name="previousVersion"]').val(xwikiDocument.version);
      form.find('input[name="editingVersionDate"]').val(new Date(xwikiDocument.modified).getTime());
    }
  };

  var overrideAjaxSaveAndContinue = function() {
    var originalAjaxSaveAndContinue = $.extend({}, XWiki.actionButtons.AjaxSaveAndContinue.prototype);
    $.extend(XWiki.actionButtons.AjaxSaveAndContinue.prototype, {
      reloadEditor: function() {
        var actionButtons = $('.inplace-editing-buttons');
        if (actionButtons.is(':visible')) {
          // This function is called after the document save confirmation is received, if the save was done by merge. We
          // register our reload listener from a document saved listener, but we're using promises which are
          // asynchronous so the reload listener is actually registered with a delay. For this reason we trigger the
          // reload event with a delay to ensure our reload listener is called.
          setTimeout(function() {
            actionButtons.trigger('xwiki:actions:reload');
          }, 0);
        } else {
          return originalAjaxSaveAndContinue.reloadEditor.apply(this, arguments);
        }
      },
      maybeRedirect: function(continueEditing) {
        if ($('.inplace-editing-buttons').is(':visible')) {
          // Overwrite the default behavior so that we don't redirect when leaving the edit mode because we're already
          // in view mode. We still need to report a redirect (return true) if we don't continue editing, so that
          // actionButtons.js behaves as if a redirect was done.
          return !continueEditing;
        } else {
          // Fallback on the default behavior if the in-place editing buttons are hidden.
          return originalAjaxSaveAndContinue.maybeRedirect.apply(this, arguments);
        }
      }
    });
  };

  var initTitleEditor = function(xwikiDocument) {
    var label = $('&lt;label for="document-title-input" class="sr-only"/&gt;')
      .text(l10n['core.editors.content.titleField.label']);
    var input = $('&lt;input type="text" id="document-title-input" name="title" form="inplace-editing" /&gt;')
      .val(xwikiDocument.rawTitle);
    if (config.titleIsMandatory) {
      input.attr({
        'required': '',
        'data-validation-value-missing': l10n['core.validation.required.message']
      });
    } else {
      var placeholder = xwikiDocument.documentReference.name;
      if (placeholder === 'WebHome') {
        placeholder = xwikiDocument.documentReference.parent.name;
      }
      input.attr('placeholder', placeholder);
    }
    $('#document-title h1').addClass('editable').empty().append([label, input]);
    $(document).on('xwiki:actions:beforeSave.titleEditor', '.xcontent.form', function(event) {
      xwikiDocument.rawTitle = input.val();
    });
    $(document).one('xwiki:actions:view', '.xcontent.form', function(event, data) {
      // Destroy the title editor.
      $(document).off('xwiki:actions:beforeSave.titleEditor');
      $('#document-title h1').removeClass('editable').text(xwikiDocument.rawTitle);
    });
    return xwikiDocument;
  };

  var initContentEditor = function(xwikiDocument) {
    var editContent = $('#xwikicontent');
    var withFocus = document.activeElement &amp;&amp; document.activeElement === editContent[0];
    // Keep showing the view content until the edit content is ready in order to avoid UI flicker.
    var viewContent = editContent.clone().insertAfter(editContent);
    // Note that we don't trigger the xwiki:dom:updated event here because we want to let the editor trigger the event
    // only for the content areas that are safe to be updated from JavaScript (i.e. the macro output).
    editContent.hide().html(xwikiDocument.renderedContent);
    if (withFocus) {
      // Keep the focus while the edit content is being prepared.
      viewContent.focus();
    }
    var data = $.extend({}, config, {
      // Use the same name as for the standalone editor, in order to be consistent.
      editorName: 'content',
      document: xwikiDocument,
      // The content editor is loaded on demand, asynchronously.
      deferred: $.Deferred()
    });
    editContent.trigger('xwiki:actions:edit', data);
    return data.deferred.promise().then(() =&gt; {
      editContent.show();
      viewContent.remove();
      if (withFocus) {
        // Restore the focus when the edit content is ready but make sure we don't scroll the page. We don't restore the
        // focus right away because we just made the content visible so it may not be editable yet (e.g. the WYSIWYG
        // editor can make the content editable only if it is visible).
        setTimeout(function() {
          editContent[0].focus({preventScroll: true});
        }, 0);
      }
      return xwikiDocument;
    });
  };

  var selectText = function(node) {
    if (window.getSelection) {
      var selection = window.getSelection();
      var range = document.createRange();
      range.selectNodeContents(node);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  };

  return {
    preload,
    editPage,
    editSection,
    translatePage
  };
});

require(['jquery'], function($) {
  // We can edit in-place only if the #xwikicontent element is present.
  if (!$('#xwikicontent').length) {
    return;
  }

  var wysiwygEditorModule = 'xwiki-' + config.wysiwygEditor + '-inline';

  var preloadEditor = function() {
    require(['editInPlace', wysiwygEditorModule], function(editInPlace) {
      editInPlace.preload();
    // Fallback on the standalone edit mode if we fail to load the required modules.
    }, disableInPlaceEditing);
  };

  // Preload the WYSIWYG editor code without slowing down the page view.
  if (document.readyState === 'complete') {
    setTimeout(preloadEditor, 0);
  } else {
    $(window).on('load', function() {
      setTimeout(preloadEditor, 0);
    });
  }

  function enableEditing(enable) {
    if (enable) {
      // Restore only the edit button at the end because:
      // * the translate button is restored (if needed) by the editInPlace module
      // * the section edit links are restored when the document is rendered for view
      editButton.removeClass('disabled');
      editButton.removeAttr('aria-disabled');
      editButton.removeAttr('role');
      editButton.attr('href', editButton.attr('data-saved-href'));
      editButton.removeAttr('data-saved-href');
    } else {
      // Disable the edit buttons and hide the section edit links.
      editButton.add(translateButton).addClass('disabled');
      editButton.attr('aria-disabled', 'true');
      editButton.each(function() {
        $(this).attr('data-saved-href', $(this).attr('href'));
      });
      editButton.removeAttr('href');
      editButton.attr('role', 'link');
      $('#xwikicontent').children(':header').children('.edit_section').addClass('hidden');
    }
  }

  // We keep a reference to the promise that resolves when the current editing session ends.
  let currentlyEditing;

  var onInPlaceEditing = function(event) {
    event.preventDefault();
    enableEditing(false);
    if (currentlyEditing) {
      // Continue after the current editing session ends.
      currentlyEditing.finally(() =&gt; {
        onInPlaceEditing(event);
      });
      // Cancel the current editing session. This is especially important if the document we want to edit is different
      // from the one currently being edited. For instance, the user may start editing the default translation of a
      // document and then chose to create a new translation. We have to unlock the default translation before locking
      // the new translation.
      $('.xcontent.form').trigger('xwiki:actions:cancel');
      return;
    }
    const handler = event.data;
    const data = handler.beforeEdit?.(event);
    // Load the code needed to edit in place only when the edit button is clicked.
    currentlyEditing = new Promise((resolve, reject) =&gt; {
      require(['editInPlace', wysiwygEditorModule], (editInPlace) =&gt; {
        // Re-enable the translate button because it can be used while editing to create the missing translation.
        translateButton.removeClass('disabled');
        handler.edit(editInPlace, data).finally(() =&gt; {
          enableEditing(true);
          resolve();
        });
      // Fallback on the standalone edit mode if we fail to load the required modules.
      }, disableInPlaceEditing.bind(event.target));
    }).finally(() =&gt; {
      currentlyEditing = false;
    });
  };

  var disableInPlaceEditing = function() {
    editButton.add(translateButton).off('click.inPlaceEditing').removeClass('disabled');
    $('#xwikicontent').off('click.inPlaceEditing').removeAttr('tabindex').children(':header').children('.edit_section')
      .removeClass('hidden');
    // Fallback on the standalone edit mode.
    $(this).click();
  };

  var editButton = $(config.editButtonSelector);
  editButton.on('click.inPlaceEditing', {
    beforeEdit: function() {
      history.replaceState(null, null, '#edit');
    },
    edit: function(editInPlace) {
      return editInPlace.editPage();
    }
  }, onInPlaceEditing).attr('data-editor', 'inplace');

  var translateButton = $(config.translateButtonSelector);
  translateButton.on('click.inPlaceEditing', {
    beforeEdit: function() {
      history.replaceState(null, null, '#translate');
      translateButton.parent().addClass('hidden');
    },
    edit: function(editInPlace) {
      return editInPlace.translatePage();
    }
  }, onInPlaceEditing);

  // Section in-place editing.
  $('#xwikicontent').on('click.inPlaceEditing', '&gt; :header &gt; a.edit_section:not(.disabled)', {
    beforeEdit: function(event) {
      // Focus the content right away to give the user instant visual feedback about what is going to happen.
      $('#xwikicontent').attr('tabindex', '0').focus();
      // Return the id of the edited section.
      return $(event.target).closest(':header').attr('id');
    },
    edit: function(editInPlace, sectionId) {
      return editInPlace.editSection(sectionId);
    }
  }, onInPlaceEditing);

  if (window.location.hash === '#edit') {
    editButton.click();
  } else if (window.location.hash === '#translate') {
    translateButton.click();
  }
});

require(['jquery', 'xwiki-meta'], function($, meta) {
  // Backup the document title before each editing session in order to catch changes.
  var previousPlainTitle;
  $('#xwikicontent').on('xwiki:actions:edit', function(event, data) {
    var xwikiDocument = data.document;
    // Make sure the metadata is up-to-date before editing starts because some editors may rely on this (e.g. when
    // creating a new translation the meta shouldn't point to the default translation).
    updateMeta(xwikiDocument);
    previousPlainTitle = xwikiDocument.getPlainTitle();
  });

  // Update the UI after each editing session.
  $(document).on('xwiki:actions:view', function(event, data) {
    var xwikiDocument = data.document;
    // Make sure the metadata matches the viewed document (e.g. after a translation is created the metadata should match
    // it, even if initially it was pointing to the default translation; same, if we cancel the creation of a
    // translation then the metadata should point to the default translation even if it was modified to point to the new
    // translation before edit).
    updateMeta(xwikiDocument);
    updateDocAuthorAndDate(xwikiDocument);
    updateDocExtraTabs(xwikiDocument);
    updateDrawer(xwikiDocument);
    updateContentMenu(xwikiDocument);
    if (xwikiDocument.getPlainTitle() !== previousPlainTitle) {
      updateDocTrees(xwikiDocument);
      updateLinks(xwikiDocument);
    }
  });

  function updateMeta(xwikiDocument) {
    $('html').attr({
      'data-xwiki-isnew': xwikiDocument.isNew,
      'data-xwiki-version': xwikiDocument.version || '',
      'data-xwiki-modified': xwikiDocument.modified,
      'data-xwiki-locale': xwikiDocument.language,
      'data-xwiki-rest-url': xwikiDocument.getRestURL()
    }).data({
      'xwiki-isnew': xwikiDocument.isNew,
      'xwiki-version': xwikiDocument.version || '',
      'xwiki-modified': xwikiDocument.modified,
      'xwiki-locale': xwikiDocument.language,
      'xwiki-rest-url': xwikiDocument.getRestURL()
    });

    // Reinitialize the meta.
    meta.init();

    // Indicate the timestamp of the last modification, which may be needed to properly merge on save.
    meta.modified = xwikiDocument.modified;
  }

  var updateDocAuthorAndDate = function(xwikiDocument) {
    var urlWithSelector = xwikiDocument.getURL('get', $.param({
      xpage: 'contentheader',
      // Preserve the current UI locale.
      language: $('html').attr('lang')
    })) + ' .xdocLastModification';
    $('.xdocLastModification').load(urlWithSelector, function() {
      // load() replaces the content of the specified container but we want to replace the container itself. We can't do
      // this from the selector, e.g. by using '.xdocLastModification &gt; *' because we lose the text nodes.
      $(this).children().unwrap();
    });
  };

  var updateDocExtraTabs = function(xwikiDocument) {
    // Reload the selected tab and force the reload of the hidden tabs next time they are selected.
    $('#docextrapanes').children().addClass('empty').empty();
    var selectedTab = $('#docExtraTabs .active[data-template]');
    if (selectedTab.length) {
      var docExtraId = selectedTab.attr('id');
      docExtraId = docExtraId.substring(0, docExtraId.length - 'tab'.length);
      XWiki.displayDocExtra(docExtraId, selectedTab.data('template'), false);
    }
  };

  // Update the document trees (e.g. breadcrumb, navigation) if they have nodes that correspond to the edited document.
  // Note that we want to update the internal tree data not just the link label. This is especially useful if we're
  // going to implement refactoring operations (rename) in the document tree.
  var updateDocTrees = function(xwikiDocument) {
    var plainTitle = xwikiDocument.getPlainTitle();
    $('.jstree-xwiki').each(function() {
      $(this).jstree?.(true)?.set_text?.('document:' + xwikiDocument.id, plainTitle);
    });
  };

  // Update the links that target the edited document and whose label matches the document title. Note that this can
  // update links whose label was not generated dynamically (e.g. with server side scripting) based on the document
  // title. For instance there could be links with hard-coded labels or with labels generated using a translation key
  // (like in the Applications panel). For simplicity, we assume that if the link matches the document URL and its
  // previous title then it needs to be updated, but this happens only at the UI level.
  var updateLinks = function(xwikiDocument) {
    var docURL = xwikiDocument.getURL();
    var newPlainTitle = xwikiDocument.getPlainTitle();
    // Exclude the links from the document content.
    // Update the links that contain only text (no child elements) otherwise we can lose UI elements (e.g. icons).
    $('a').not('#xwikicontent a').not(':has(*)').filter(function() {
      var linkURL = $(this).attr('href')?.split(/[?#]/, 1)[0];
      return linkURL === docURL &amp;&amp; $(this).text() === previousPlainTitle;
    }).text(newPlainTitle);
  };

  // Update the list of available document translations in the drawer menu. This is needed for instance when a new
  // translation is created using the in-place editor.
  var updateDrawer = function(xwikiDocument) {
    var languageMenu = $('#tmLanguages_menu');
    var locale = xwikiDocument.getRealLocale();
    // Look for the language query string parameter, either inside or at the end.
    var localeSelector = 'a[href*="language=' + locale + '&amp;"], a[href$="language=' + locale + '"]';
    // Check if the language menu is present (multilingual is on) and the document locale is not listed.
    if (languageMenu.length &amp;&amp; !languageMenu.find(localeSelector).length) {
      // If we get here then it means a new document translation was created, and it needs to be listed in the drawer.
      $('&lt;div/&gt;').load(xwikiDocument.getURL('get', $.param({
        'xpage': 'xpart',
        'vm': 'drawer.vm',
        'useLayoutVars': true
      // Pass the query string from the current URL so that it gets included in the translation URL.
      // XWIKI-11314: Changing the current language from the UI does not preserve the query string of the current URL
      })) + '&amp;' + location.search.substring(1) + ' #tmLanguages_menu', function() {
        $(this).find('a').each(function() {
          // Clean the query string.
          $(this).attr('href', $(this).attr('href').replace(/&amp;?(xpage=xpart|vm=drawer\.vm|useLayoutVars=true)/g, '')
            .replace('?&amp;', '?'));
        });
        languageMenu.replaceWith($(this).children());
      });
    }
  };

  // Update the links from the content menu to point to the real document locale. This is needed especially when a new
  // document translation is created in-place.
  var updateContentMenu = function(xwikiDocument) {
    var realLocale = xwikiDocument.getRealLocale();
    var defaultLocale = xwikiDocument.getDefaultLocale();
    if (realLocale != defaultLocale) {
      var defaultLocaleRegex = new RegExp('(\\blanguage=)' + defaultLocale + '($|&amp;|#)');
      $('#contentmenu a[href*="language=' + defaultLocale + '"]').each(function() {
        $(this).attr('href', $(this).attr('href').replace(defaultLocaleRegex, '$1' + realLocale + '$2'));
      });
    }
  };
});

})(JSON.parse(document.querySelector('[data-inplace-editing-config]')?.getAttribute('data-inplace-editing-config')) ||
  {});</code>
    </property>
    <property>
      <name/>
    </property>
    <property>
      <parse>0</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>XWiki.InplaceEditing</name>
    <number>0</number>
    <className>XWiki.StyleSheetExtension</className>
    <guid>bd0e5f70-8c74-48e4-97b9-81620b5d9394</guid>
    <class>
      <name>XWiki.StyleSheetExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <defaultValue>long</defaultValue>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <restricted>0</restricted>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <contentType>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>contentType</name>
        <number>6</number>
        <prettyName>Content Type</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>CSS|LESS</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </contentType>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage|onDemand|always</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>#document-title h1.editable {
  /* Move the title heading a bit to the top and to the left in order to accomodate the input border and padding. */
  margin-top: -@line-height-computed / 4;
  margin-left: -(ceil(@grid-gutter-width / 2));
  /* Reduce the bottom margin in order to accomodate the input border and bottom padding. */
  margin-bottom: @line-height-computed / 4;
}

@document-title-input-padding-vertical: @line-height-computed / 4 - 1;
input#document-title-input {
  /* Preserve the heading styles. */
  color: inherit;
  font-size: inherit;
  background-color: @body-bg;
  /* It seems it's not enough to set the line height for the text input. We also need to set its height. */
  height: @font-size-document-title * @headings-line-height + 2 * (1 + @document-title-input-padding-vertical);
  line-height: @headings-line-height;
  padding: @document-title-input-padding-vertical (ceil(@grid-gutter-width / 2) - 1);
  width: 100%;
}
input#document-title-input:valid {
  border: 1px solid transparent;
  box-shadow: none;
}

input#document-title-input:valid:hover {
  border-color: @input-border;
}

input#document-title-input:valid:focus,
#xwikicontent[contenteditable]:focus,
#xwikicontent[tabindex]:focus {
  .form-control-focus();
}

#xwikicontent[contenteditable],
#xwikicontent[tabindex] {
  border: 1px solid transparent;
  margin-top: -1px;
  margin-left: -1px;
}

#xwikicontent.loading {
  background: none;
  cursor: wait;
}

/* Leave more space at the top of the edited content by reducing the margin bottom of the preceding horizontal rule. */
.document-header + hr {
  margin-bottom: @line-height-computed / 4;
}
#xwikicontent {
  padding-top: @line-height-computed * 0.75;
}

form#inplace-editing {
  /* Leave some space for the bottom box shadow of the editing area. */
  margin-top: 7px;
}</code>
    </property>
    <property>
      <contentType>LESS</contentType>
    </property>
    <property>
      <name/>
    </property>
    <property>
      <parse>0</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>XWiki.InplaceEditing</name>
    <number>0</number>
    <className>XWiki.UIExtensionClass</className>
    <guid>5c7fd93e-a308-4bd0-a53a-5e4d54b2640c</guid>
    <class>
      <name>XWiki.UIExtensionClass</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <async_cached>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_cached</name>
        <number>3</number>
        <prettyName>Cached</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_cached>
      <async_context>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>1</multiSelect>
        <name>async_context</name>
        <number>4</number>
        <prettyName>Context elements</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator>, </separator>
        <separators>|, </separators>
        <size>5</size>
        <unmodifiable>0</unmodifiable>
        <values>action=Action|doc.reference=Document|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.cookies|request.headers|request.parameters=Request parameters|request.remoteAddr|request.url=Request URL|request.wiki=Request wiki|user=User|wiki=Wiki</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </async_context>
      <async_enabled>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_enabled</name>
        <number>2</number>
        <prettyName>Asynchronous rendering</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_enabled>
      <content>
        <disabled>0</disabled>
        <editor>Text</editor>
        <name>content</name>
        <number>1</number>
        <prettyName>Executed Content</prettyName>
        <restricted>0</restricted>
        <rows>25</rows>
        <size>120</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </content>
      <extensionPointId>
        <disabled>0</disabled>
        <name>extensionPointId</name>
        <number>5</number>
        <prettyName>Extension Point ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </extensionPointId>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>6</number>
        <prettyName>Extension ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parameters>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>parameters</name>
        <number>7</number>
        <prettyName>Extension Parameters</prettyName>
        <restricted>0</restricted>
        <rows>10</rows>
        <size>40</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </parameters>
      <scope>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>scope</name>
        <number>8</number>
        <prettyName>Extension Scope</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>wiki=Current Wiki|user=Current User|global=Global</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </scope>
    </class>
    <property>
      <async_cached>0</async_cached>
    </property>
    <property>
      <async_context/>
    </property>
    <property>
      <async_enabled>0</async_enabled>
    </property>
    <property>
      <content>{{velocity output="false"}}
## TODO: Remove this when XWIKI-18511 (Add support for passing a query string when calling getSkinFile) is implemented.
#macro (getSkinFileWithParams $file $params)
#set ($url = $xwiki.getSkinFile($file, true))
$url#if ($url.contains('?'))&amp;#else?#end$escapetool.url($params)
#end
{{/velocity}}

{{velocity}}
{{html clean="false"}}
#if ($services.edit.document.inPlaceEditingEnabled() &amp;&amp; $hasEdit &amp;&amp; $xcontext.action == 'view' &amp;&amp; !$doc.isNew())
  ## We support in-place editing only for the WYSIWYG edit mode ATM.
  #getDefaultDocumentEditor($defaultEditMode)
  #if ($defaultEditMode == 'wysiwyg')
    #set ($l10nKeys = [
      'edit.inplace.page.renderFailed',
      'edit.inplace.page.lockFailed',
      'edit.inplace.close',
      'edit.inplace.page.loadFailed',
      'edit.inplace.actionButtons.loadFailed',
      'core.editors.content.titleField.label',
      'core.validation.required.message',
      ['edit.inplace.page.translate.messageBefore', $doc.realLocale.getDisplayName($xcontext.locale),
        $xcontext.locale.getDisplayName($xcontext.locale)],
      ['edit.inplace.page.translate.messageAfter', $xcontext.locale.getDisplayName($xcontext.locale)]
    ])
    #set ($l10n = {})
    #foreach ($key in $l10nKeys)
      #set ($params = $key.subList(1, $key.size()))
      #if ($params)
        #set ($discard = $l10n.put($key[0], $services.localization.render($key[0], $params)))
      #else
        #set ($discard = $l10n.put($key, $services.localization.render($key)))
      #end
    #end
    ## See stylesheets.vm
    #set ($cssParams = {
      'skin': $xwiki.skin,
      'colorTheme': $services.model.serialize($themeDoc.documentReference, 'default')
    })
    #set ($jsParams = {'language': $xcontext.locale})
    ## We have to explicitly enable the source mode for in-line edit because the latest version of the content editor
    ## could be installed on an older version of XWiki where the in-place editor didn't support the source mode (so the
    ## content editor cannot enable the source mode by default).
    #set ($inplaceEditingConfig = {
      'contentType': 'org.xwiki.rendering.syntax.SyntaxContent',
      'editMode': $defaultEditMode,
      'wysiwygEditor': $services.edit.syntaxContent.defaultWysiwygEditor.descriptor.id,
      'editButtonSelector': '#tmEdit &gt; a',
      'translateButtonSelector': '#tmTranslate &gt; a',
      'enableSourceMode': true,
      'paths': {
        'js': {
          'xwiki-actionButtons': "#getSkinFileWithParams('js/xwiki/actionbuttons/actionButtons.js' $jsParams)",
          'xwiki-autoSave': "#getSkinFileWithParams('js/xwiki/editors/autosave.js' $jsParams)",
          'xwiki-diff': $xwiki.getSkinFile('uicomponents/viewers/diff.js')
        },
        'css': [
          "#getSkinFileWithParams('js/xwiki/actionbuttons/actionButtons.css' $cssParams)",
          "#getSkinFileWithParams('js/xwiki/editors/autosave.css' $cssParams)",
          "#getSkinFileWithParams('uicomponents/viewers/diff.css' $cssParams)"
        ]
      },
      'l10n': $l10n
    })
    #set ($inplaceEditingConfig.titleIsMandatory = $xwiki.getSpacePreference('xwiki.title.mandatory') == 1)
    &lt;div class="hidden" data-inplace-editing-config="$escapetool.xml($jsontool.serialize($inplaceEditingConfig))"&gt;&lt;/div&gt;
    ## We didn't move this to the file system because it uses LESS and we didn't want to include it in the skin.
    #set ($discard = $xwiki.ssx.use('XWiki.InplaceEditing'))
    ## We can't move this to a WebJar until we have XWIKI-12788 (Introduce skin extension plugins for webjar resources).
    #set ($discard = $xwiki.jsx.use('XWiki.InplaceEditing'))
  #end
#end
{{/html}}
{{/velocity}}</content>
    </property>
    <property>
      <extensionPointId>org.xwiki.platform.template.header.after</extensionPointId>
    </property>
    <property>
      <name>org.xwiki.platform.template.header.after.inplaceEditing</name>
    </property>
    <property>
      <parameters/>
    </property>
    <property>
      <scope>wiki</scope>
    </property>
  </object>
</xwikidoc>
