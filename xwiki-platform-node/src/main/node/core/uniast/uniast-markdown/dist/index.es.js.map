{"version":3,"file":"index.es.js","sources":["../src/markdown/internal/find-first-match-in.ts","../src/markdown/internal/remark-partial-gfm.ts","../src/markdown/internal-links/parser/parser-configuration-resolver.ts","../src/markdown/default-markdown-to-uni-ast-converter.ts","../src/markdown/internal-links/serializer/internal-links-serializer-resolver.ts","../src/markdown/default-uni-ast-to-markdown-converter.ts","../src/component-init.ts"],"sourcesContent":["/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\n\nexport type MatchResult<K extends string> = {\n  name: K;\n  match: string;\n  offset: number;\n};\n\nexport function findFirstMatchIn<K extends string>(\n  subject: string,\n  candidates: Array<{ name: K; match: string }>,\n): MatchResult<K> | null {\n  let first: MatchResult<K> | null = null;\n\n  for (const { name, match } of candidates) {\n    const offset = subject.indexOf(match);\n\n    if (offset !== -1 && (first === null || first.offset > offset)) {\n      first = { name, match, offset };\n    }\n  }\n\n  return first;\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { gfmStrikethroughFromMarkdown } from \"mdast-util-gfm-strikethrough\";\nimport { gfmTableFromMarkdown } from \"mdast-util-gfm-table\";\nimport { gfmTaskListItemFromMarkdown } from \"mdast-util-gfm-task-list-item\";\nimport { gfmStrikethrough } from \"micromark-extension-gfm-strikethrough\";\nimport { gfmTable } from \"micromark-extension-gfm-table\";\nimport { gfmTaskListItem } from \"micromark-extension-gfm-task-list-item\";\nimport type { Processor } from \"unified\";\n\n/**\n * Extension to *partially* support Github's Front Matter (Markdown) syntax flavor\n *\n * Does **NOT** include some of GFM features like autolinks or footnotes, which are implemented differently in another\n * part of the code\n */\nexport function remarkPartialGfm(this: Processor): void {\n  const data = this.data();\n\n  data.micromarkExtensions ??= [];\n  data.fromMarkdownExtensions ??= [];\n\n  data.micromarkExtensions.push(\n    gfmStrikethrough(),\n    gfmTable(),\n    gfmTaskListItem(),\n  );\n\n  data.fromMarkdownExtensions.push(\n    gfmStrikethroughFromMarkdown(),\n    gfmTableFromMarkdown(),\n    gfmTaskListItemFromMarkdown(),\n  );\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { inject, injectable } from \"inversify\";\nimport type { MarkdownParserConfiguration } from \"./markdown-parser-configuration\";\nimport type { CristalApp } from \"@xwiki/platform-api\";\n\n/**\n * @since 0.22\n */\n@injectable()\nexport class ParserConfigurationResolver {\n  constructor(@inject(\"CristalApp\") private readonly cristalApp: CristalApp) {}\n  get(): MarkdownParserConfiguration {\n    const type = this.cristalApp.getWikiConfig().getType();\n    try {\n      const factory: () => MarkdownParserConfiguration = this.cristalApp\n        .getContainer()\n        .get(\"Factory<MarkdownParserConfiguration>\", { name: type });\n      return factory();\n    } catch {\n      // Return the default value if no specific factory is found.\n      return {\n        supportFlexmarkInternalLinks: false,\n      };\n    }\n  }\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { findFirstMatchIn } from \"./internal/find-first-match-in\";\nimport { remarkPartialGfm } from \"./internal/remark-partial-gfm\";\nimport { ParserConfigurationResolver } from \"./internal-links/parser/parser-configuration-resolver\";\nimport { assertInArray, assertUnreachable } from \"@xwiki/platform-fn-utils\";\nimport { EntityType } from \"@xwiki/platform-model-api\";\nimport { inject, injectable } from \"inversify\";\nimport remarkParse from \"remark-parse\";\nimport { unified } from \"unified\";\nimport type { MatchResult } from \"./internal/find-first-match-in\";\nimport type { MarkdownToUniAstConverter } from \"./markdown-to-uni-ast-converter\";\nimport type { EntityReference } from \"@xwiki/platform-model-api\";\nimport type {\n  ModelReferenceHandlerProvider,\n  ModelReferenceParserProvider,\n} from \"@xwiki/platform-model-reference-api\";\nimport type {\n  Block,\n  Image,\n  InlineContent,\n  LinkTarget,\n  TableCell,\n  TableColumn,\n  TextStyles,\n  UniAst,\n} from \"@xwiki/platform-uniast-api\";\nimport type { Image as MdImage, PhrasingContent, RootContent } from \"mdast\";\n\n/**\n * @since 0.22\n */\n@injectable()\nexport class DefaultMarkdownToUniAstConverter\n  implements MarkdownToUniAstConverter\n{\n  constructor(\n    @inject(\"ModelReferenceParserProvider\")\n    private readonly modelReferenceParserProvider: ModelReferenceParserProvider,\n    @inject(\"ModelReferenceHandlerProvider\")\n    private readonly modelReferenceHandlerProvider: ModelReferenceHandlerProvider,\n    @inject(\"ParserConfigurationResolver\")\n    private readonly parserConfigurationResolver: ParserConfigurationResolver,\n  ) {}\n\n  async parseMarkdown(markdown: string): Promise<UniAst | Error> {\n    // TODO: auto-links (URLs + emails)\n    //     > https://jira.xwiki.org/browse/CRISTAL-513\n\n    const ast = unified()\n      .use(remarkParse)\n      .use(remarkPartialGfm)\n      .parse(markdown);\n\n    try {\n      const blocks = await Promise.all(\n        ast.children.map((item) => this.convertBlock(item)),\n      );\n      return { blocks };\n    } catch (e) {\n      return e instanceof Error ? e : new Error(String(e));\n    }\n  }\n\n  private async convertBlock(block: RootContent): Promise<Block> {\n    switch (block.type) {\n      case \"paragraph\": {\n        const content = await this.collectInlineContent(block.children, {});\n\n        // Paragraphs only made of a single inline macro are actually block macros\n        if (content.length === 1 && content[0].type === \"inlineMacro\") {\n          return {\n            type: \"macroBlock\",\n            name: content[0].name,\n            params: content[0].params,\n          };\n        }\n\n        return {\n          type: \"paragraph\",\n          content,\n          styles: {},\n        };\n      }\n\n      case \"heading\":\n        return {\n          type: \"heading\",\n          level: assertInArray(\n            block.depth,\n            [1, 2, 3, 4, 5, 6] as const,\n            \"Invalid heading depth in markdown parser\",\n          ),\n          content: await this.collectInlineContent(block.children, {}),\n          styles: {},\n        };\n\n      case \"blockquote\":\n        return {\n          type: \"quote\",\n          content: await Promise.all(\n            block.children.map((item) => this.convertBlock(item)),\n          ),\n          styles: {},\n        };\n\n      case \"list\":\n        // TODO: \"token.loose\" property\n        return {\n          type: \"list\",\n          items: await Promise.all(\n            block.children.map(async (item, i) => ({\n              number: block.ordered ? (block.start ?? 1) + i : undefined,\n              checked: item.checked ?? undefined,\n              content: await Promise.all(\n                item.children.map((item) => this.convertBlock(item)),\n              ),\n              styles: {},\n            })),\n          ),\n          styles: {},\n        };\n      case \"code\":\n        // TODO: \"token.escaped\" property\n        // TODO: \"token.codeBlockStyle\" property\n        return {\n          type: \"code\",\n          content: block.value,\n          language: block.lang ?? undefined,\n        };\n\n      case \"table\": {\n        const [headers, ...rows] = block.children;\n        const columns = await Promise.all(\n          headers?.children.map(\n            async (cell): Promise<TableColumn> => ({\n              headerCell: {\n                content: await this.collectInlineContent(cell.children, {}),\n                styles: {},\n              },\n            }),\n          ),\n        );\n        const tableRows = await Promise.all(\n          rows.map(async (row) => {\n            const map = row.children.map(\n              async (cell): Promise<TableCell> => ({\n                content: await this.collectInlineContent(cell.children, {}),\n                styles: {},\n              }),\n            );\n            return await Promise.all(map);\n          }),\n        );\n        return {\n          type: \"table\",\n          columns: columns,\n          rows: tableRows,\n          styles: {},\n        };\n      }\n\n      case \"image\":\n        return {\n          type: \"image\",\n          ...(await this.convertImage(block)),\n        };\n\n      case \"break\":\n      case \"thematicBreak\":\n        return { type: \"break\" };\n\n      case \"imageReference\":\n      case \"linkReference\":\n      case \"definition\":\n      case \"footnoteDefinition\":\n      case \"footnoteReference\":\n      case \"html\":\n        throw new Error(\"TODO: handle blocks of type \" + block.type);\n\n      // NOTE: These are handled in the `convertInline` function below\n      case \"text\":\n      case \"delete\":\n      case \"strong\":\n      case \"emphasis\":\n      case \"inlineCode\":\n      case \"link\":\n      case \"tableCell\":\n      case \"tableRow\":\n      case \"yaml\":\n      case \"listItem\":\n        throw new Error(\n          \"Unexpected block type in markdown parser: \" + block.type,\n        );\n\n      default:\n        assertUnreachable(block);\n    }\n  }\n\n  private async convertInline(\n    inline: PhrasingContent,\n    styles: TextStyles,\n  ): Promise<InlineContent[]> {\n    switch (inline.type) {\n      case \"image\":\n        return [\n          {\n            type: \"image\",\n            ...(await this.convertImage(inline)),\n          },\n        ];\n\n      case \"strong\":\n        return this.collectInlineContent(inline.children, {\n          ...styles,\n          bold: true,\n        });\n\n      case \"emphasis\":\n        return this.collectInlineContent(inline.children, {\n          ...styles,\n          italic: true,\n        });\n\n      case \"delete\":\n        return this.collectInlineContent(inline.children, {\n          ...styles,\n          strikethrough: true,\n        });\n\n      case \"inlineCode\":\n        return [\n          {\n            type: \"text\",\n            content: inline.value,\n            styles: {},\n          },\n        ];\n\n      case \"text\":\n        return this.convertText(inline.value, styles);\n\n      case \"html\":\n      case \"footnoteReference\":\n      case \"linkReference\":\n      case \"imageReference\":\n      case \"break\":\n        throw new Error(\"TODO: handle inlines of type \" + inline.type);\n\n      case \"link\": {\n        return await this.convertLink(inline, styles);\n      }\n\n      default:\n        assertUnreachable(inline);\n    }\n  }\n\n  private async convertLink(\n    inline: PhrasingContent & { type: \"link\" },\n    styles: TextStyles,\n  ): Promise<InlineContent[]> {\n    // TODO: change here for Github and nextcloud + resolve the entity reference in case the link can be resolved as\n    //  internal.\n    // For Nextcloud, resolve based on the note on AnyType (from docid to url)\n    // TODO: the same must be done for attachments!\n    let target: LinkTarget;\n    if (!this.supportFlexmark()) {\n      // If flexmark is not supported, we need to parse the url to find out if it's pointing to an internal entity.\n      try {\n        const parsed = await this.modelReferenceParserProvider\n          .get()!\n          .parseAsync(inline.url);\n        target = {\n          type: \"internal\",\n          parsedReference: parsed,\n          rawReference: inline.url,\n        };\n      } catch (e) {\n        console.debug(\"Error parsing reference: \", e);\n        target = { type: \"external\", url: inline.url };\n      }\n    } else {\n      target = { type: \"external\", url: inline.url };\n    }\n    const label = await this.collectInlineContent(inline.children, styles);\n    return [\n      {\n        type: \"link\",\n        content: label.map((token) => {\n          if (token.type !== \"text\") {\n            throw new Error(\"Unexpected link inside link in markdown parser\");\n          }\n          return token;\n        }),\n        target,\n      },\n    ];\n  }\n\n  private async convertImage(image: MdImage): Promise<Image> {\n    // TODO: \"token.text\" property\n    let target: LinkTarget;\n    const url = image.url;\n    try {\n      const parsed = await this.modelReferenceParserProvider\n        .get()!\n        .parseAsync(url, { type: EntityType.ATTACHMENT });\n      target = {\n        type: \"internal\",\n        parsedReference: parsed,\n        rawReference: url,\n      };\n    } catch {\n      target = { type: \"external\", url: url };\n    }\n\n    return {\n      target,\n      caption: undefined,\n      alt: image.alt ?? undefined,\n      styles: {},\n    };\n  }\n\n  // eslint-disable-next-line max-statements\n  private convertText(text: string, styles: TextStyles): InlineContent[] {\n    const out: InlineContent[] = [];\n\n    let treated = 0;\n\n    while (true) {\n      // Try to find the first XWiki-specific-element syntax in the text (precedence order)\n      // Do not use the expressions for internal images and links when not supported.\n      const internalLinksOrImage: Array<{\n        name: \"image\" | \"link\";\n        match: string;\n      }> = this.supportFlexmark()\n        ? [\n            { name: \"image\", match: \"![[\" },\n            { name: \"link\", match: \"[[\" },\n          ]\n        : [];\n      const candidates: Array<{\n        name: \"image\" | \"link\" | \"macro\";\n        match: string;\n      }> = [...internalLinksOrImage, { name: \"macro\", match: \"{{\" }];\n      const firstItem: MatchResult<\"image\" | \"link\" | \"macro\"> | null =\n        findFirstMatchIn(text.substring(treated), candidates);\n\n      // If none is found, exit immediately\n      // This also means texts that don't contain any specific syntax will have a very low conversion cost\n      if (!firstItem) {\n        break;\n      }\n\n      const match = treated + firstItem.offset;\n\n      // Ensure the current element is not being escaped with backslashes\n      const precedingBackslashes = text.substring(0, match).match(/\\\\+/);\n\n      // Backslashes are counted as pairs, as two consecutive backslashes are not escaping the next character\n      if (precedingBackslashes && precedingBackslashes[0].length % 2 !== 0) {\n        continue;\n      }\n\n      // Push the text between the last match and the current one as plain text\n      if (text.substring(treated, match).length > 0) {\n        out.push({\n          type: \"text\",\n          content: text.substring(treated, match),\n          styles,\n        });\n      }\n\n      switch (firstItem.name) {\n        case \"image\":\n        case \"link\": {\n          treated = this.handleLinkOrImage(\n            firstItem,\n            match,\n            text,\n            treated,\n            styles,\n            out,\n          );\n          break;\n        }\n\n        case \"macro\": {\n          treated = this.handleMacro(firstItem, match, text, treated, out);\n\n          break;\n        }\n\n        default:\n          assertUnreachable(firstItem.name);\n      }\n    }\n\n    // Push the leftover text after the last XWiki-specific element as plain text\n    if (text.substring(treated).length > 0) {\n      out.push({\n        type: \"text\",\n        content: text.substring(treated),\n        styles,\n      });\n    }\n\n    return out;\n  }\n\n  // eslint-disable-next-line max-statements\n  private handleLinkOrImage(\n    firstItem: { name: string; match: string },\n    match: number,\n    text: string,\n    treated: number,\n    styles: TextStyles,\n    out: InlineContent[],\n  ): number {\n    const isImage = firstItem.name === \"image\";\n\n    let i;\n\n    // Is the next character being escaped?\n    let escaping = false;\n    // Is the link or image being closed?\n    let closing = false;\n    // Has the link or image been closed properly?\n    let closed = false;\n\n    for (i = match + firstItem.match.length; i < text.length; i++) {\n      if (escaping) {\n        escaping = false;\n\n        continue;\n      }\n\n      const char = text.charAt(i);\n\n      if (char === \"\\\\\") {\n        escaping = true;\n        continue;\n      }\n\n      if (char === \"]\") {\n        if (closing) {\n          closed = true;\n          break;\n        }\n\n        closing = true;\n      }\n    }\n\n    if (!closed) {\n      return treated;\n    }\n\n    treated = i + 1;\n\n    const substr = text.substring(match + firstItem.match.length, i - 1);\n\n    let title: string | null;\n    let targetStr: string;\n\n    const pipeCharPos = substr.indexOf(\"|\");\n\n    if (pipeCharPos !== -1) {\n      title = substr.substring(0, pipeCharPos);\n      targetStr = substr.substring(pipeCharPos + 1);\n    } else {\n      title = null;\n      targetStr = substr;\n    }\n\n    let reference: EntityReference | null;\n    try {\n      reference = this.modelReferenceParserProvider.get()!.parse(targetStr, {\n        type: isImage ? EntityType.ATTACHMENT : EntityType.DOCUMENT,\n      });\n    } catch {\n      reference = null;\n    }\n\n    const target: LinkTarget = {\n      type: \"internal\",\n      rawReference: targetStr,\n      parsedReference: reference,\n    };\n\n    title ??= reference\n      ? this.modelReferenceHandlerProvider.get()!.getTitle(reference)\n      : \"<invalid reference>\";\n\n    const items: InlineContent = isImage\n      ? {\n          type: \"image\",\n          target,\n          styles: { alignment: \"left\" },\n          alt: title,\n        }\n      : {\n          type: \"link\",\n          target,\n          content: [{ type: \"text\", content: title, styles }],\n        };\n    out.push(items);\n    return treated;\n  }\n\n  // eslint-disable-next-line max-statements\n  private handleMacro(\n    firstItem: { name: string; match: string },\n    match: number,\n    text: string,\n    treated: number,\n    out: InlineContent[],\n  ): number {\n    // Find the macro's name\n    const macroNameMatch = text.substring(match + firstItem.match.length).match(\n      // This weird group matches valid accentuated Unicode letters\n      /\\s*([A-Za-zÀ-ÖØ-öø-ÿ\\d]+)(\\s+(?=[A-Za-zÀ-ÖØ-öø-ÿ\\d/])|(?=\\/))/,\n    );\n\n    if (!macroNameMatch) {\n      treated = match + firstItem.match.length;\n      out.push({ type: \"text\", content: firstItem.match, styles: {} });\n      return treated;\n    }\n\n    const macroName = macroNameMatch[1];\n\n    let i;\n\n    // Is the next character being escaped?\n    let escaping = false;\n\n    // Parameters are built character by character\n    // First the name is parsed from the source, then the value\n    let buildingParameter: { name: string; value: string | null } | null = null;\n\n    // The list of parsed parameters\n    const parameters: Record<string, string> = {};\n\n    // Is the macro being closed?\n    let closingMacro = false;\n\n    for (\n      i = match + firstItem.match.length + macroNameMatch[0].length;\n      i < text.length;\n      i++\n    ) {\n      // Escaping is possible only inside parameter values\n      if (escaping) {\n        if (!buildingParameter || buildingParameter.value === null) {\n          throw new Error(\"Unexpected\");\n        }\n\n        escaping = false;\n        buildingParameter.value += text[i];\n\n        continue;\n      }\n\n      // If we're not building a parameter, we are expecting one thing between...\n      if (!buildingParameter) {\n        // ...a space (no particular meaning)\n        if (text[i] === \" \") {\n          continue;\n        }\n\n        // ...a valid identifier character which will begin the parameter's name\n        if (text[i].match(/[A-Za-zÀ-ÖØ-öø-ÿ_\\d]/)) {\n          buildingParameter = { name: text[i], value: null };\n          continue;\n        }\n\n        // ...or a closing slash which indicates the macro has no more parameter\n        if (text[i] === \"/\") {\n          closingMacro = true;\n          break;\n        }\n\n        // Invalid character, stop building macro here\n        break;\n      }\n\n      // If we're building a parameter's name, we are expecting one thing between...\n      if (buildingParameter.value === null) {\n        // ...a valid identifier character which will continue the parameter's name\n        if (text[i].match(/[A-Za-zÀ-ÖØ-öø-ÿ_\\d]/)) {\n          buildingParameter.name += text[i];\n          continue;\n        }\n\n        // ...or an '=' operator sign which indicates we are going to assign a value to the parameter\n        if (text[i] === \"=\") {\n          // Usually parameters start with a double quote to indicate they have a string-like value\n          if (text[i + 1] === '\"') {\n            i += 1;\n            buildingParameter.value = \"\";\n            continue;\n          }\n\n          // But unquoted integers are also accepted\n          const number = text\n            .substring(i + 1)\n            .match(/\\d+(?=[^A-Za-zÀ-ÖØ-öø-ÿ\\d])/);\n\n          if (!number) {\n            // Invalid character, stop building macro here\n            break;\n          }\n\n          parameters[buildingParameter.name] = number[0];\n          buildingParameter = null;\n\n          i += number[0].length;\n          continue;\n        }\n\n        // Invalid character, stop building macro here\n        break;\n      }\n\n      // If we reach this point, we are building the parameter's value.\n      // Which means we are expecting either:\n      // ...an escaping character\n      if (text[i] === \"\\\\\") {\n        escaping = true;\n      }\n      // ...a closing double quote to indicate the parameter's value's end\n      else if (text[i] === '\"') {\n        parameters[buildingParameter.name] = buildingParameter.value;\n        buildingParameter = null;\n      }\n      // ...or any other character that will continue the parameter's value\n      else {\n        buildingParameter.value += text[i];\n      }\n    }\n\n    // When the macro closes, we expect double braces afterwards\n    const closingBraces = text.substring(i).match(/\\s*}}/);\n\n    // If the macro has not been closed properly (with a '/') or doesn't have the closing braces, it's invalid\n    if (!closingMacro || !closingBraces) {\n      treated = match + firstItem.match.length;\n      out.push({ type: \"text\", content: firstItem.match, styles: {} });\n    }\n    // Otherwise, we can properly build the macro\n    else {\n      treated = i + 1 + closingBraces[0].length;\n\n      // NOTE: If a paragraph only contains an inline macro, it will be converted to a macro block instead\n      //       by the calling function\n      out.push({\n        type: \"inlineMacro\",\n        name: macroName,\n        params: parameters,\n      });\n    }\n    return treated;\n  }\n\n  private supportFlexmark(): boolean {\n    return this.parserConfigurationResolver.get().supportFlexmarkInternalLinks;\n  }\n\n  private async collectInlineContent(\n    children: PhrasingContent[],\n    styles: TextStyles = {},\n  ): Promise<InlineContent[]> {\n    return (\n      await Promise.all(\n        children.map((item) => this.convertInline(item, styles)),\n      )\n    ).flat();\n  }\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { inject, injectable } from \"inversify\";\nimport type { InternalLinksSerializer } from \"./internal-links-serializer\";\nimport type { CristalApp } from \"@xwiki/platform-api\";\n\n/**\n * @since 0.22\n */\n@injectable()\nexport class InternalLinksSerializerResolver {\n  constructor(@inject(\"CristalApp\") private readonly cristalApp: CristalApp) {}\n\n  async get(): Promise<InternalLinksSerializer> {\n    const type = this.cristalApp.getWikiConfig().getType();\n    try {\n      const factory: () => Promise<InternalLinksSerializer> =\n        await this.cristalApp\n          .getContainer()\n          .getAsync(\"Factory<InternalLinksSerializer>\", { name: type });\n      return factory();\n    } catch (e) {\n      console.debug(e);\n      throw new Error(`Could not resolve serializer for type ${type}`);\n    }\n  }\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { InternalLinksSerializerResolver } from \"./internal-links/serializer/internal-links-serializer-resolver\";\nimport { tryFallibleOrError } from \"@xwiki/platform-fn-utils\";\nimport { inject, injectable } from \"inversify\";\nimport type { UniAstToMarkdownConverter } from \"./uni-ast-to-markdown-converter\";\nimport type {\n  Block,\n  Image,\n  InlineContent,\n  Link,\n  ListItem,\n  TableCell,\n  Text,\n  UniAst,\n} from \"@xwiki/platform-uniast-api\";\n\n/**\n * @since 0.22\n */\n@injectable()\nexport class DefaultUniAstToMarkdownConverter\n  implements UniAstToMarkdownConverter\n{\n  constructor(\n    @inject(\"InternalLinksSerializerResolver\")\n    private readonly internalLinksSerializerResolver: InternalLinksSerializerResolver,\n  ) {}\n\n  /**\n   * Converts the provided AST to Markdown.\n   *\n   * @param uniAst - the AST to convert to markdown\n   *\n   * understand the impacts\n   */\n  async toMarkdown(uniAst: UniAst): Promise<string | Error> {\n    const { blocks } = uniAst;\n\n    const out: Promise<string>[] = [];\n\n    for (const element of blocks) {\n      // TODO: fix this (can't error as it's a promise)\n      const md = tryFallibleOrError(() => this.blockToMarkdown(element));\n\n      if (md instanceof Error) {\n        return md;\n      }\n\n      out.push(md);\n    }\n\n    // TODO: try fallible here as this could throw\n    return (await Promise.all(out)).join(\"\\n\\n\");\n  }\n\n  private async blockToMarkdown(block: Block): Promise<string> {\n    switch (block.type) {\n      case \"paragraph\":\n        return this.convertInlineContents(block.content);\n\n      case \"heading\":\n        return `${\"#\".repeat(block.level)} ${await this.convertInlineContents(block.content)}`;\n\n      case \"list\": {\n        return (\n          await Promise.all(\n            block.items.map((item) => this.convertListItem(item)),\n          )\n        ).join(\"\\n\");\n      }\n\n      case \"quote\": {\n        const values = block.content\n          .map((item) => this.blockToMarkdown(item))\n          .flatMap(async (item) => (await item).split(\"\\n\"))\n          .flatMap(async (line) => {\n            const strings = await line;\n            return strings.map((s) => `> ${s}`).join(\"\\n\");\n          });\n        return (await Promise.all(values)).join(\"\\n\");\n      }\n\n      case \"code\":\n        return `\\`\\`\\`${block.language ?? \"\"}\\n${block.content}\\n\\`\\`\\``;\n\n      case \"table\":\n        return this.convertTable(block);\n\n      case \"image\":\n        return this.convertImage(block);\n\n      case \"break\":\n        return \"---\";\n\n      case \"macroBlock\":\n        return this.convertMacro(block.name, block.params);\n    }\n  }\n\n  private async convertListItem(listItem: ListItem): Promise<string> {\n    let prefix = listItem.number !== undefined ? `${listItem.number}. ` : \"* \";\n\n    if (listItem.checked !== undefined) {\n      prefix += `[${listItem.checked ? \"x\" : \" \"}] `;\n    }\n\n    const contents: string[] = [];\n    for (const item of listItem.content) {\n      const md = await this.blockToMarkdown(item);\n      const lines = md.split(\"\\n\");\n      contents.push(\n        lines\n          .map((line, i) => (i > 0 ? \" \".repeat(prefix.length) : \"\") + line)\n          .join(\"\\n\"),\n      );\n    }\n    return `${prefix}${contents.join(\"\\n\")}`;\n  }\n\n  private async convertImage(image: Image): Promise<string> {\n    // TODO: alt text\n    return image.target.type === \"external\"\n      ? `![${image.alt ?? \"\"}](${image.target.url})`\n      : await (\n          await this.internalLinksSerializerResolver.get()\n        ).serializeImage(image.target, image.alt);\n  }\n\n  private async convertTable(\n    table: Extract<Block, { type: \"table\" }>,\n  ): Promise<string> {\n    const { columns, rows } = table;\n\n    const out = [\n      (\n        await Promise.all(\n          columns.map((column) =>\n            column.headerCell ? this.convertTableCell(column.headerCell) : \"\",\n          ),\n        )\n      ).join(\" | \"),\n      columns.map(() => \" - \").join(\" | \"),\n    ];\n\n    for (const cell of rows) {\n      out.push(\n        (\n          await Promise.all(cell.map((item) => this.convertTableCell(item)))\n        ).join(\" | \"),\n      );\n    }\n\n    return out.map((line) => `| ${line} |`).join(\"\\n\");\n  }\n\n  private convertTableCell(cell: TableCell): Promise<string> {\n    return this.convertInlineContents(cell.content);\n  }\n\n  async convertInlineContents(\n    inlineContents: InlineContent[],\n  ): Promise<string> {\n    return (\n      await Promise.all(\n        inlineContents.map((item) => this.convertInlineContent(item)),\n      )\n    ).join(\"\");\n  }\n\n  async convertInlineContent(inlineContent: InlineContent): Promise<string> {\n    switch (inlineContent.type) {\n      case \"text\":\n        return this.convertText(inlineContent);\n      case \"image\":\n        return this.convertImage(inlineContent);\n      case \"link\":\n        return this.convertLink(inlineContent);\n      case \"inlineMacro\":\n        return this.convertMacro(inlineContent.name, inlineContent.params);\n    }\n  }\n\n  private async convertLink(inlineContent: Link): Promise<string> {\n    switch (inlineContent.target.type) {\n      case \"external\":\n        return `[${await this.convertInlineContents(inlineContent.content)}](${inlineContent.target.url})`;\n\n      case \"internal\": {\n        const linksSerializer =\n          await this.internalLinksSerializerResolver.get();\n        return linksSerializer.serialize(\n          inlineContent.content,\n          inlineContent.target,\n          this,\n        );\n      }\n    }\n  }\n\n  private convertMacro(\n    name: string,\n    parameters: Record<string, boolean | number | string>,\n  ): string {\n    return `{{${name}${Object.entries(parameters)\n      .map(\n        ([name, value]) =>\n          ` ${name}=\"${value.toString().replace(/\\\\/g, \"\\\\\\\\\\\\\").replace(/\"/g, '\\\\\\\\\"')}\"`,\n      )\n      .join(\"\")} /}}`;\n  }\n\n  // eslint-disable-next-line max-statements\n  private convertText(text: Text): string {\n    const { content, styles } = text;\n\n    const { bold, italic, strikethrough, code } = styles;\n\n    const surroundings = [];\n\n    // Code must be first as it's going to be the most outer surrounding\n    // Otherwise other surroundings would be \"trapped\" inside the inline code content\n    if (code) {\n      surroundings.push(\"`\");\n    }\n\n    if (strikethrough) {\n      surroundings.push(\"~~\");\n    }\n\n    if (italic) {\n      surroundings.push(\"_\");\n    }\n\n    if (bold) {\n      surroundings.push(\"**\");\n    }\n\n    return `${surroundings.join(\"\")}${content}${surroundings.reverse().join(\"\")}`;\n  }\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { DefaultMarkdownToUniAstConverter } from \"./markdown/default-markdown-to-uni-ast-converter\";\nimport { DefaultUniAstToMarkdownConverter } from \"./markdown/default-uni-ast-to-markdown-converter\";\nimport { ParserConfigurationResolver } from \"./markdown/internal-links/parser/parser-configuration-resolver\";\nimport { InternalLinksSerializerResolver } from \"./markdown/internal-links/serializer/internal-links-serializer-resolver\";\nimport type { MarkdownParserConfiguration } from \"./markdown/internal-links/parser/markdown-parser-configuration\";\nimport type { InternalLinksSerializer } from \"./markdown/internal-links/serializer/internal-links-serializer\";\nimport type { MarkdownToUniAstConverter } from \"./markdown/markdown-to-uni-ast-converter\";\nimport type { UniAstToMarkdownConverter } from \"./markdown/uni-ast-to-markdown-converter\";\nimport type { Container, Factory, Newable, ResolutionContext } from \"inversify\";\n\n/**\n * @since 0.22\n * @beta\n */\nconst markdownToUniAstConverterName = \"MarkdownToUniAstConverter\";\n\n/**\n * @since 0.22\n * @beta\n */\nconst uniAstToMarkdownConverterName = \"UniAstToMarkdownConverter\";\n\n/**\n * @since 0.22\n * @beta\n */\nclass ComponentInit {\n  constructor(container: Container) {\n    container\n      .bind<MarkdownToUniAstConverter>(markdownToUniAstConverterName)\n      .to(DefaultMarkdownToUniAstConverter)\n      .whenDefault();\n\n    container\n      .bind<UniAstToMarkdownConverter>(uniAstToMarkdownConverterName)\n      .to(DefaultUniAstToMarkdownConverter)\n      .whenDefault();\n\n    // New components loading pattern attempt (as of Cristal 0.22).\n    // A resolver is declared. Its job is to resolve the right factory based\n    // on the current configuration type.\n    // Then, the factory is loaded asynchronously with a dynamic import so that\n    // only the code corresponding to the current configuration is loaded.\n    container\n      .bind<InternalLinksSerializerResolver>(\"InternalLinksSerializerResolver\")\n      .to(InternalLinksSerializerResolver);\n    // Factories for the officially supported backends are registered statically\n    // But nothing prevents factories for other backends to be registered at\n    // initialization time.\n    // The main side effect of regisering those factories is a few kb of\n    // initialization code being bundled for nothing (i.e., for the backends\n    // that are not going to be used).\n    this.initXWikiFactory(container);\n    this.initNextcloudFactory(container);\n    this.initGitHubFactory(container);\n    this.initFileSystemFactory(container);\n\n    container\n      .bind<ParserConfigurationResolver>(\"ParserConfigurationResolver\")\n      .to(ParserConfigurationResolver)\n      .whenDefault();\n\n    // Overrides the configuration for the XWiki backend\n    container\n      .bind<Factory<MarkdownParserConfiguration>>(\n        \"Factory<MarkdownParserConfiguration>\",\n      )\n      .toFactory(() => {\n        return () => {\n          return {\n            supportFlexmarkInternalLinks: true,\n          };\n        };\n      })\n      .whenNamed(\"XWiki\");\n  }\n\n  private initXWikiFactory(container: Container) {\n    const name = \"XWiki\";\n    container\n      .bind<Factory<Promise<InternalLinksSerializer>>>(\n        \"Factory<InternalLinksSerializer>\",\n      )\n      .toFactory((context) => {\n        return async () => {\n          const component = (\n            await import(\n              \"./markdown/internal-links/serializer/xwiki-internal-link-serializer\"\n            )\n          ).XWikiInternalLinkSerializer;\n          return this.bindAndLoad(container, name, component, context);\n        };\n      })\n      .whenNamed(name);\n  }\n  private initNextcloudFactory(container: Container) {\n    const name = \"Nextcloud\";\n    container\n      .bind<Factory<Promise<InternalLinksSerializer>>>(\n        \"Factory<InternalLinksSerializer>\",\n      )\n      .toFactory((context) => {\n        return async () => {\n          const component = (\n            await import(\n              \"./markdown/internal-links/serializer/nextcloud-internal-link-serializer\"\n            )\n          ).NextcloudInternalLinkSerializer;\n          return this.bindAndLoad(container, name, component, context);\n        };\n      })\n      .whenNamed(name);\n  }\n  private initGitHubFactory(container: Container) {\n    const name = \"GitHub\";\n    container\n      .bind<Factory<Promise<InternalLinksSerializer>>>(\n        \"Factory<InternalLinksSerializer>\",\n      )\n      .toFactory((context) => {\n        return async () => {\n          const component = (\n            await import(\n              \"./markdown/internal-links/serializer/github-internal-link-serializer\"\n            )\n          ).GitHubInternalLinkSerializer;\n          return this.bindAndLoad(container, name, component, context);\n        };\n      })\n      .whenNamed(name);\n  }\n  private initFileSystemFactory(container: Container) {\n    const name = \"FileSystem\";\n    container\n      .bind<Factory<Promise<InternalLinksSerializer>>>(\n        \"Factory<InternalLinksSerializer>\",\n      )\n      .toFactory((context) => {\n        return async () => {\n          const component = (\n            await import(\n              \"./markdown/internal-links/serializer/filesystem-internal-link-serializer\"\n            )\n          ).FilesystemInternalLinkSerializer;\n          return this.bindAndLoad(container, name, component, context);\n        };\n      })\n      .whenNamed(name);\n  }\n\n  /**\n   * Registed the component in the container on demand.\n   *\n   * @param container - the container\n   * @param name - the name of the component interface\n   * @param component - the actual component to register\n   * @param context - the context\n   */\n  private bindAndLoad<T extends InternalLinksSerializer>(\n    container: Container,\n    name: string,\n    component: Newable<T>,\n    context: ResolutionContext,\n  ) {\n    if (!container.isBound(\"InternalLinksSerializer\", { name: name })) {\n      container\n        .bind<InternalLinksSerializer>(\"InternalLinksSerializer\")\n        .to(component)\n        .whenNamed(name);\n    }\n    return context.get<InternalLinksSerializer>(\"InternalLinksSerializer\", {\n      name: name,\n    });\n  }\n}\n\nexport {\n  ComponentInit,\n  markdownToUniAstConverterName,\n  uniAstToMarkdownConverterName,\n};\n"],"names":["findFirstMatchIn","subject","candidates","first","name","match","offset","remarkPartialGfm","data","gfmStrikethrough","gfmTable","gfmTaskListItem","gfmStrikethroughFromMarkdown","gfmTableFromMarkdown","gfmTaskListItemFromMarkdown","ParserConfigurationResolver","cristalApp","type","__decorateClass","injectable","__decorateParam","DefaultMarkdownToUniAstConverter","modelReferenceParserProvider","modelReferenceHandlerProvider","parserConfigurationResolver","markdown","ast","unified","remarkParse","item","e","block","content","assertInArray","i","headers","rows","columns","cell","tableRows","row","map","assertUnreachable","inline","styles","target","token","image","url","EntityType","text","out","treated","firstItem","precedingBackslashes","isImage","escaping","closing","closed","char","substr","title","targetStr","pipeCharPos","reference","items","macroNameMatch","macroName","buildingParameter","parameters","closingMacro","number","closingBraces","children","InternalLinksSerializerResolver","DefaultUniAstToMarkdownConverter","internalLinksSerializerResolver","uniAst","blocks","element","md","tryFallibleOrError","values","line","s","listItem","prefix","contents","lines","table","column","inlineContents","inlineContent","value","bold","italic","strikethrough","code","surroundings","markdownToUniAstConverterName","uniAstToMarkdownConverterName","ComponentInit","container","context","component"],"mappings":";;;;;;;;;;;AA0BO,SAASA,EACdC,GACAC,GACuB;AACvB,MAAIC,IAA+B;AAEnC,aAAW,EAAE,MAAAC,GAAM,OAAAC,EAAA,KAAWH,GAAY;AACxC,UAAMI,IAASL,EAAQ,QAAQI,CAAK;AAEpC,IAAIC,MAAW,OAAOH,MAAU,QAAQA,EAAM,SAASG,OACrDH,IAAQ,EAAE,MAAAC,GAAM,OAAAC,GAAO,QAAAC,EAAA;AAAA,EAE3B;AAEA,SAAOH;AACT;ACRO,SAASI,IAAwC;AACtD,QAAMC,IAAO,KAAK,KAAA;AAElB,EAAAA,EAAK,wBAAwB,CAAA,GAC7BA,EAAK,2BAA2B,CAAA,GAEhCA,EAAK,oBAAoB;AAAA,IACvBC,EAAA;AAAA,IACAC,EAAA;AAAA,IACAC,EAAA;AAAA,EAAgB,GAGlBH,EAAK,uBAAuB;AAAA,IAC1BI,EAAA;AAAA,IACAC,EAAA;AAAA,IACAC,EAAA;AAAA,EAA4B;AAEhC;;;;;;ACvBO,IAAMC,IAAN,MAAkC;AAAA,EACvC,YAAmDC,GAAwB;AAAxB,SAAA,aAAAA;AAAA,EAAyB;AAAA,EAC5E,MAAmC;AACjC,UAAMC,IAAO,KAAK,WAAW,cAAA,EAAgB,QAAA;AAC7C,QAAI;AAIF,aAHmD,KAAK,WACrD,aAAA,EACA,IAAI,wCAAwC,EAAE,MAAMA,GAAM,EACtD;AAAA,IACT,QAAQ;AAEN,aAAO;AAAA,QACL,8BAA8B;AAAA,MAAA;AAAA,IAElC;AAAA,EACF;AACF;AAhBaF,IAANG,EAAA;AAAA,EADNC,EAAA;AAAA,EAEcC,OAAO,YAAY,CAAA;AAAA,GADrBL,CAAA;;;;;;ACuBN,IAAMM,IAAN,MAEP;AAAA,EACE,YAEmBC,GAEAC,GAEAC,GACjB;AALiB,SAAA,+BAAAF,GAEA,KAAA,gCAAAC,GAEA,KAAA,8BAAAC;AAAA,EAChB;AAAA,EAEH,MAAM,cAAcC,GAA2C;AAI7D,UAAMC,IAAMC,EAAA,EACT,IAAIC,CAAW,EACf,IAAIrB,CAAgB,EACpB,MAAMkB,CAAQ;AAEjB,QAAI;AAIF,aAAO,EAAE,QAHM,MAAM,QAAQ;AAAA,QAC3BC,EAAI,SAAS,IAAI,CAACG,MAAS,KAAK,aAAaA,CAAI,CAAC;AAAA,MAAA,EAE3C;AAAA,IACX,SAASC,GAAG;AACV,aAAOA,aAAa,QAAQA,IAAI,IAAI,MAAM,OAAOA,CAAC,CAAC;AAAA,IACrD;AAAA,EACF;AAAA,EAEA,MAAc,aAAaC,GAAoC;AAC7D,YAAQA,EAAM,MAAA;AAAA,MACZ,KAAK,aAAa;AAChB,cAAMC,IAAU,MAAM,KAAK,qBAAqBD,EAAM,UAAU,EAAE;AAGlE,eAAIC,EAAQ,WAAW,KAAKA,EAAQ,CAAC,EAAE,SAAS,gBACvC;AAAA,UACL,MAAM;AAAA,UACN,MAAMA,EAAQ,CAAC,EAAE;AAAA,UACjB,QAAQA,EAAQ,CAAC,EAAE;AAAA,QAAA,IAIhB;AAAA,UACL,MAAM;AAAA,UACN,SAAAA;AAAA,UACA,QAAQ,CAAA;AAAA,QAAC;AAAA,MAEb;AAAA,MAEA,KAAK;AACH,eAAO;AAAA,UACL,MAAM;AAAA,UACN,OAAOC;AAAA,YACLF,EAAM;AAAA,YACN,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAAA,YACjB;AAAA,UAAA;AAAA,UAEF,SAAS,MAAM,KAAK,qBAAqBA,EAAM,UAAU,CAAA,CAAE;AAAA,UAC3D,QAAQ,CAAA;AAAA,QAAC;AAAA,MAGb,KAAK;AACH,eAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,MAAM,QAAQ;AAAA,YACrBA,EAAM,SAAS,IAAI,CAACF,MAAS,KAAK,aAAaA,CAAI,CAAC;AAAA,UAAA;AAAA,UAEtD,QAAQ,CAAA;AAAA,QAAC;AAAA,MAGb,KAAK;AAEH,eAAO;AAAA,UACL,MAAM;AAAA,UACN,OAAO,MAAM,QAAQ;AAAA,YACnBE,EAAM,SAAS,IAAI,OAAOF,GAAMK,OAAO;AAAA,cACrC,QAAQH,EAAM,WAAWA,EAAM,SAAS,KAAKG,IAAI;AAAA,cACjD,SAASL,EAAK,WAAW;AAAA,cACzB,SAAS,MAAM,QAAQ;AAAA,gBACrBA,EAAK,SAAS,IAAI,CAACA,MAAS,KAAK,aAAaA,CAAI,CAAC;AAAA,cAAA;AAAA,cAErD,QAAQ,CAAA;AAAA,YAAC,EACT;AAAA,UAAA;AAAA,UAEJ,QAAQ,CAAA;AAAA,QAAC;AAAA,MAEb,KAAK;AAGH,eAAO;AAAA,UACL,MAAM;AAAA,UACN,SAASE,EAAM;AAAA,UACf,UAAUA,EAAM,QAAQ;AAAA,QAAA;AAAA,MAG5B,KAAK,SAAS;AACZ,cAAM,CAACI,GAAS,GAAGC,CAAI,IAAIL,EAAM,UAC3BM,IAAU,MAAM,QAAQ;AAAA,UAC5BF,GAAS,SAAS;AAAA,YAChB,OAAOG,OAAgC;AAAA,cACrC,YAAY;AAAA,gBACV,SAAS,MAAM,KAAK,qBAAqBA,EAAK,UAAU,CAAA,CAAE;AAAA,gBAC1D,QAAQ,CAAA;AAAA,cAAC;AAAA,YACX;AAAA,UACF;AAAA,QACF,GAEIC,IAAY,MAAM,QAAQ;AAAA,UAC9BH,EAAK,IAAI,OAAOI,MAAQ;AACtB,kBAAMC,IAAMD,EAAI,SAAS;AAAA,cACvB,OAAOF,OAA8B;AAAA,gBACnC,SAAS,MAAM,KAAK,qBAAqBA,EAAK,UAAU,CAAA,CAAE;AAAA,gBAC1D,QAAQ,CAAA;AAAA,cAAC;AAAA,YACX;AAEF,mBAAO,MAAM,QAAQ,IAAIG,CAAG;AAAA,UAC9B,CAAC;AAAA,QAAA;AAEH,eAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAAJ;AAAA,UACA,MAAME;AAAA,UACN,QAAQ,CAAA;AAAA,QAAC;AAAA,MAEb;AAAA,MAEA,KAAK;AACH,eAAO;AAAA,UACL,MAAM;AAAA,UACN,GAAI,MAAM,KAAK,aAAaR,CAAK;AAAA,QAAA;AAAA,MAGrC,KAAK;AAAA,MACL,KAAK;AACH,eAAO,EAAE,MAAM,QAAA;AAAA,MAEjB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,cAAM,IAAI,MAAM,iCAAiCA,EAAM,IAAI;AAAA;AAAA,MAG7D,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,cAAM,IAAI;AAAA,UACR,+CAA+CA,EAAM;AAAA,QAAA;AAAA,MAGzD;AACE,QAAAW,EAAkBX,CAAK;AAAA,IAAA;AAAA,EAE7B;AAAA,EAEA,MAAc,cACZY,GACAC,GAC0B;AAC1B,YAAQD,EAAO,MAAA;AAAA,MACb,KAAK;AACH,eAAO;AAAA,UACL;AAAA,YACE,MAAM;AAAA,YACN,GAAI,MAAM,KAAK,aAAaA,CAAM;AAAA,UAAA;AAAA,QACpC;AAAA,MAGJ,KAAK;AACH,eAAO,KAAK,qBAAqBA,EAAO,UAAU;AAAA,UAChD,GAAGC;AAAA,UACH,MAAM;AAAA,QAAA,CACP;AAAA,MAEH,KAAK;AACH,eAAO,KAAK,qBAAqBD,EAAO,UAAU;AAAA,UAChD,GAAGC;AAAA,UACH,QAAQ;AAAA,QAAA,CACT;AAAA,MAEH,KAAK;AACH,eAAO,KAAK,qBAAqBD,EAAO,UAAU;AAAA,UAChD,GAAGC;AAAA,UACH,eAAe;AAAA,QAAA,CAChB;AAAA,MAEH,KAAK;AACH,eAAO;AAAA,UACL;AAAA,YACE,MAAM;AAAA,YACN,SAASD,EAAO;AAAA,YAChB,QAAQ,CAAA;AAAA,UAAC;AAAA,QACX;AAAA,MAGJ,KAAK;AACH,eAAO,KAAK,YAAYA,EAAO,OAAOC,CAAM;AAAA,MAE9C,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,cAAM,IAAI,MAAM,kCAAkCD,EAAO,IAAI;AAAA,MAE/D,KAAK;AACH,eAAO,MAAM,KAAK,YAAYA,GAAQC,CAAM;AAAA,MAG9C;AACE,QAAAF,EAAkBC,CAAM;AAAA,IAAA;AAAA,EAE9B;AAAA,EAEA,MAAc,YACZA,GACAC,GAC0B;AAK1B,QAAIC;AACJ,QAAK,KAAK;AAgBR,MAAAA,IAAS,EAAE,MAAM,YAAY,KAAKF,EAAO,IAAA;AAAA;AAdzC,UAAI;AAIF,QAAAE,IAAS;AAAA,UACP,MAAM;AAAA,UACN,iBALa,MAAM,KAAK,6BACvB,MACA,WAAWF,EAAO,GAAG;AAAA,UAItB,cAAcA,EAAO;AAAA,QAAA;AAAA,MAEzB,SAASb,GAAG;AACV,gBAAQ,MAAM,6BAA6BA,CAAC,GAC5Ce,IAAS,EAAE,MAAM,YAAY,KAAKF,EAAO,IAAA;AAAA,MAC3C;AAKF,WAAO;AAAA,MACL;AAAA,QACE,MAAM;AAAA,QACN,UAJU,MAAM,KAAK,qBAAqBA,EAAO,UAAUC,CAAM,GAIlD,IAAI,CAACE,MAAU;AAC5B,cAAIA,EAAM,SAAS;AACjB,kBAAM,IAAI,MAAM,gDAAgD;AAElE,iBAAOA;AAAA,QACT,CAAC;AAAA,QACD,QAAAD;AAAA,MAAA;AAAA,IACF;AAAA,EAEJ;AAAA,EAEA,MAAc,aAAaE,GAAgC;AAEzD,QAAIF;AACJ,UAAMG,IAAMD,EAAM;AAClB,QAAI;AAIF,MAAAF,IAAS;AAAA,QACP,MAAM;AAAA,QACN,iBALa,MAAM,KAAK,6BACvB,IAAA,EACA,WAAWG,GAAK,EAAE,MAAMC,EAAW,WAAA,CAAY;AAAA,QAIhD,cAAcD;AAAA,MAAA;AAAA,IAElB,QAAQ;AACN,MAAAH,IAAS,EAAE,MAAM,YAAY,KAAAG,EAAA;AAAA,IAC/B;AAEA,WAAO;AAAA,MACL,QAAAH;AAAA,MACA,SAAS;AAAA,MACT,KAAKE,EAAM,OAAO;AAAA,MAClB,QAAQ,CAAA;AAAA,IAAC;AAAA,EAEb;AAAA;AAAA,EAGQ,YAAYG,GAAcN,GAAqC;AACrE,UAAMO,IAAuB,CAAA;AAE7B,QAAIC,IAAU;AAEd,eAAa;AAYX,YAAMlD,IAGD,CAAC,GATD,KAAK,oBACN;AAAA,QACE,EAAE,MAAM,SAAS,OAAO,MAAA;AAAA,QACxB,EAAE,MAAM,QAAQ,OAAO,KAAA;AAAA,MAAK,IAE9B,CAAA,GAI2B,EAAE,MAAM,SAAS,OAAO,MAAM,GACvDmD,IACJrD,EAAiBkD,EAAK,UAAUE,CAAO,GAAGlD,CAAU;AAItD,UAAI,CAACmD;AACH;AAGF,YAAMhD,IAAQ+C,IAAUC,EAAU,QAG5BC,IAAuBJ,EAAK,UAAU,GAAG7C,CAAK,EAAE,MAAM,KAAK;AAGjE,UAAI,EAAAiD,KAAwBA,EAAqB,CAAC,EAAE,SAAS,MAAM;AAanE,gBARIJ,EAAK,UAAUE,GAAS/C,CAAK,EAAE,SAAS,KAC1C8C,EAAI,KAAK;AAAA,UACP,MAAM;AAAA,UACN,SAASD,EAAK,UAAUE,GAAS/C,CAAK;AAAA,UACtC,QAAAuC;AAAA,QAAA,CACD,GAGKS,EAAU,MAAA;AAAA,UAChB,KAAK;AAAA,UACL,KAAK,QAAQ;AACX,YAAAD,IAAU,KAAK;AAAA,cACbC;AAAA,cACAhD;AAAA,cACA6C;AAAA,cACAE;AAAA,cACAR;AAAA,cACAO;AAAA,YAAA;AAEF;AAAA,UACF;AAAA,UAEA,KAAK,SAAS;AACZ,YAAAC,IAAU,KAAK,YAAYC,GAAWhD,GAAO6C,GAAME,GAASD,CAAG;AAE/D;AAAA,UACF;AAAA,UAEA;AACE,YAAAT,EAAkBW,EAAU,IAAI;AAAA,QAAA;AAAA,IAEtC;AAGA,WAAIH,EAAK,UAAUE,CAAO,EAAE,SAAS,KACnCD,EAAI,KAAK;AAAA,MACP,MAAM;AAAA,MACN,SAASD,EAAK,UAAUE,CAAO;AAAA,MAC/B,QAAAR;AAAA,IAAA,CACD,GAGIO;AAAA,EACT;AAAA;AAAA,EAGQ,kBACNE,GACAhD,GACA6C,GACAE,GACAR,GACAO,GACQ;AACR,UAAMI,IAAUF,EAAU,SAAS;AAEnC,QAAInB,GAGAsB,IAAW,IAEXC,IAAU,IAEVC,IAAS;AAEb,SAAKxB,IAAI7B,IAAQgD,EAAU,MAAM,QAAQnB,IAAIgB,EAAK,QAAQhB,KAAK;AAC7D,UAAIsB,GAAU;AACZ,QAAAA,IAAW;AAEX;AAAA,MACF;AAEA,YAAMG,IAAOT,EAAK,OAAOhB,CAAC;AAE1B,UAAIyB,MAAS,MAAM;AACjB,QAAAH,IAAW;AACX;AAAA,MACF;AAEA,UAAIG,MAAS,KAAK;AAChB,YAAIF,GAAS;AACX,UAAAC,IAAS;AACT;AAAA,QACF;AAEA,QAAAD,IAAU;AAAA,MACZ;AAAA,IACF;AAEA,QAAI,CAACC;AACH,aAAON;AAGT,IAAAA,IAAUlB,IAAI;AAEd,UAAM0B,IAASV,EAAK,UAAU7C,IAAQgD,EAAU,MAAM,QAAQnB,IAAI,CAAC;AAEnE,QAAI2B,GACAC;AAEJ,UAAMC,IAAcH,EAAO,QAAQ,GAAG;AAEtC,IAAIG,MAAgB,MAClBF,IAAQD,EAAO,UAAU,GAAGG,CAAW,GACvCD,IAAYF,EAAO,UAAUG,IAAc,CAAC,MAE5CF,IAAQ,MACRC,IAAYF;AAGd,QAAII;AACJ,QAAI;AACF,MAAAA,IAAY,KAAK,6BAA6B,IAAA,EAAO,MAAMF,GAAW;AAAA,QACpE,MAAMP,IAAUN,EAAW,aAAaA,EAAW;AAAA,MAAA,CACpD;AAAA,IACH,QAAQ;AACN,MAAAe,IAAY;AAAA,IACd;AAEA,UAAMnB,IAAqB;AAAA,MACzB,MAAM;AAAA,MACN,cAAciB;AAAA,MACd,iBAAiBE;AAAA,IAAA;AAGnB,IAAAH,MAAUG,IACN,KAAK,8BAA8B,MAAO,SAASA,CAAS,IAC5D;AAEJ,UAAMC,IAAuBV,IACzB;AAAA,MACE,MAAM;AAAA,MACN,QAAAV;AAAA,MACA,QAAQ,EAAE,WAAW,OAAA;AAAA,MACrB,KAAKgB;AAAA,IAAA,IAEP;AAAA,MACE,MAAM;AAAA,MACN,QAAAhB;AAAA,MACA,SAAS,CAAC,EAAE,MAAM,QAAQ,SAASgB,GAAO,QAAAjB,GAAQ;AAAA,IAAA;AAExD,WAAAO,EAAI,KAAKc,CAAK,GACPb;AAAA,EACT;AAAA;AAAA,EAGQ,YACNC,GACAhD,GACA6C,GACAE,GACAD,GACQ;AAER,UAAMe,IAAiBhB,EAAK,UAAU7C,IAAQgD,EAAU,MAAM,MAAM,EAAE;AAAA;AAAA,MAEpE;AAAA,IAAA;AAGF,QAAI,CAACa;AACH,aAAAd,IAAU/C,IAAQgD,EAAU,MAAM,QAClCF,EAAI,KAAK,EAAE,MAAM,QAAQ,SAASE,EAAU,OAAO,QAAQ,CAAA,GAAI,GACxDD;AAGT,UAAMe,IAAYD,EAAe,CAAC;AAElC,QAAIhC,GAGAsB,IAAW,IAIXY,IAAmE;AAGvE,UAAMC,IAAqC,CAAA;AAG3C,QAAIC,IAAe;AAEnB,SACEpC,IAAI7B,IAAQgD,EAAU,MAAM,SAASa,EAAe,CAAC,EAAE,QACvDhC,IAAIgB,EAAK,QACThB,KACA;AAEA,UAAIsB,GAAU;AACZ,YAAI,CAACY,KAAqBA,EAAkB,UAAU;AACpD,gBAAM,IAAI,MAAM,YAAY;AAG9B,QAAAZ,IAAW,IACXY,EAAkB,SAASlB,EAAKhB,CAAC;AAEjC;AAAA,MACF;AAGA,UAAI,CAACkC,GAAmB;AAEtB,YAAIlB,EAAKhB,CAAC,MAAM;AACd;AAIF,YAAIgB,EAAKhB,CAAC,EAAE,MAAM,sBAAsB,GAAG;AACzC,UAAAkC,IAAoB,EAAE,MAAMlB,EAAKhB,CAAC,GAAG,OAAO,KAAA;AAC5C;AAAA,QACF;AAGA,YAAIgB,EAAKhB,CAAC,MAAM,KAAK;AACnB,UAAAoC,IAAe;AACf;AAAA,QACF;AAGA;AAAA,MACF;AAGA,UAAIF,EAAkB,UAAU,MAAM;AAEpC,YAAIlB,EAAKhB,CAAC,EAAE,MAAM,sBAAsB,GAAG;AACzC,UAAAkC,EAAkB,QAAQlB,EAAKhB,CAAC;AAChC;AAAA,QACF;AAGA,YAAIgB,EAAKhB,CAAC,MAAM,KAAK;AAEnB,cAAIgB,EAAKhB,IAAI,CAAC,MAAM,KAAK;AACvB,YAAAA,KAAK,GACLkC,EAAkB,QAAQ;AAC1B;AAAA,UACF;AAGA,gBAAMG,IAASrB,EACZ,UAAUhB,IAAI,CAAC,EACf,MAAM,6BAA6B;AAEtC,cAAI,CAACqC;AAEH;AAGF,UAAAF,EAAWD,EAAkB,IAAI,IAAIG,EAAO,CAAC,GAC7CH,IAAoB,MAEpBlC,KAAKqC,EAAO,CAAC,EAAE;AACf;AAAA,QACF;AAGA;AAAA,MACF;AAKA,MAAIrB,EAAKhB,CAAC,MAAM,OACdsB,IAAW,KAGJN,EAAKhB,CAAC,MAAM,OACnBmC,EAAWD,EAAkB,IAAI,IAAIA,EAAkB,OACvDA,IAAoB,QAIpBA,EAAkB,SAASlB,EAAKhB,CAAC;AAAA,IAErC;AAGA,UAAMsC,IAAgBtB,EAAK,UAAUhB,CAAC,EAAE,MAAM,OAAO;AAGrD,WAAI,CAACoC,KAAgB,CAACE,KACpBpB,IAAU/C,IAAQgD,EAAU,MAAM,QAClCF,EAAI,KAAK,EAAE,MAAM,QAAQ,SAASE,EAAU,OAAO,QAAQ,CAAA,GAAI,MAI/DD,IAAUlB,IAAI,IAAIsC,EAAc,CAAC,EAAE,QAInCrB,EAAI,KAAK;AAAA,MACP,MAAM;AAAA,MACN,MAAMgB;AAAA,MACN,QAAQE;AAAA,IAAA,CACT,IAEIjB;AAAA,EACT;AAAA,EAEQ,kBAA2B;AACjC,WAAO,KAAK,4BAA4B,IAAA,EAAM;AAAA,EAChD;AAAA,EAEA,MAAc,qBACZqB,GACA7B,IAAqB,IACK;AAC1B,YACE,MAAM,QAAQ;AAAA,MACZ6B,EAAS,IAAI,CAAC5C,MAAS,KAAK,cAAcA,GAAMe,CAAM,CAAC;AAAA,IAAA,GAEzD,KAAA;AAAA,EACJ;AACF;AAzoBavB,IAANH,EAAA;AAAA,EADNC,EAAA;AAAA,EAKIC,OAAO,8BAA8B,CAAA;AAAA,EAErCA,OAAO,+BAA+B,CAAA;AAAA,EAEtCA,OAAO,6BAA6B,CAAA;AAAA,GAR5BC,CAAA;;;;;;ACvBN,IAAMqD,IAAN,MAAsC;AAAA,EAC3C,YAAmD1D,GAAwB;AAAxB,SAAA,aAAAA;AAAA,EAAyB;AAAA,EAE5E,MAAM,MAAwC;AAC5C,UAAMC,IAAO,KAAK,WAAW,cAAA,EAAgB,QAAA;AAC7C,QAAI;AAKF,cAHE,MAAM,KAAK,WACR,aAAA,EACA,SAAS,oCAAoC,EAAE,MAAMA,GAAM,GACzD;AAAA,IACT,SAASa,GAAG;AACV,oBAAQ,MAAMA,CAAC,GACT,IAAI,MAAM,yCAAyCb,CAAI,EAAE;AAAA,IACjE;AAAA,EACF;AACF;AAhBayD,IAANxD,EAAA;AAAA,EADNC,EAAA;AAAA,EAEcC,OAAO,YAAY,CAAA;AAAA,GADrBsD,CAAA;;;;;;ACWN,IAAMC,IAAN,MAEP;AAAA,EACE,YAEmBC,GACjB;AADiB,SAAA,kCAAAA;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASH,MAAM,WAAWC,GAAyC;AACxD,UAAM,EAAE,QAAAC,MAAWD,GAEb1B,IAAyB,CAAA;AAE/B,eAAW4B,KAAWD,GAAQ;AAE5B,YAAME,IAAKC,EAAmB,MAAM,KAAK,gBAAgBF,CAAO,CAAC;AAEjE,UAAIC,aAAc;AAChB,eAAOA;AAGT,MAAA7B,EAAI,KAAK6B,CAAE;AAAA,IACb;AAGA,YAAQ,MAAM,QAAQ,IAAI7B,CAAG,GAAG,KAAK;AAAA;AAAA,CAAM;AAAA,EAC7C;AAAA,EAEA,MAAc,gBAAgBpB,GAA+B;AAC3D,YAAQA,EAAM,MAAA;AAAA,MACZ,KAAK;AACH,eAAO,KAAK,sBAAsBA,EAAM,OAAO;AAAA,MAEjD,KAAK;AACH,eAAO,GAAG,IAAI,OAAOA,EAAM,KAAK,CAAC,IAAI,MAAM,KAAK,sBAAsBA,EAAM,OAAO,CAAC;AAAA,MAEtF,KAAK;AACH,gBACE,MAAM,QAAQ;AAAA,UACZA,EAAM,MAAM,IAAI,CAACF,MAAS,KAAK,gBAAgBA,CAAI,CAAC;AAAA,QAAA,GAEtD,KAAK;AAAA,CAAI;AAAA,MAGb,KAAK,SAAS;AACZ,cAAMqD,IAASnD,EAAM,QAClB,IAAI,CAACF,MAAS,KAAK,gBAAgBA,CAAI,CAAC,EACxC,QAAQ,OAAOA,OAAU,MAAMA,GAAM,MAAM;AAAA,CAAI,CAAC,EAChD,QAAQ,OAAOsD,OACE,MAAMA,GACP,IAAI,CAACC,MAAM,KAAKA,CAAC,EAAE,EAAE,KAAK;AAAA,CAAI,CAC9C;AACH,gBAAQ,MAAM,QAAQ,IAAIF,CAAM,GAAG,KAAK;AAAA,CAAI;AAAA,MAC9C;AAAA,MAEA,KAAK;AACH,eAAO,SAASnD,EAAM,YAAY,EAAE;AAAA,EAAKA,EAAM,OAAO;AAAA;AAAA,MAExD,KAAK;AACH,eAAO,KAAK,aAAaA,CAAK;AAAA,MAEhC,KAAK;AACH,eAAO,KAAK,aAAaA,CAAK;AAAA,MAEhC,KAAK;AACH,eAAO;AAAA,MAET,KAAK;AACH,eAAO,KAAK,aAAaA,EAAM,MAAMA,EAAM,MAAM;AAAA,IAAA;AAAA,EAEvD;AAAA,EAEA,MAAc,gBAAgBsD,GAAqC;AACjE,QAAIC,IAASD,EAAS,WAAW,SAAY,GAAGA,EAAS,MAAM,OAAO;AAEtE,IAAIA,EAAS,YAAY,WACvBC,KAAU,IAAID,EAAS,UAAU,MAAM,GAAG;AAG5C,UAAME,IAAqB,CAAA;AAC3B,eAAW1D,KAAQwD,EAAS,SAAS;AAEnC,YAAMG,KADK,MAAM,KAAK,gBAAgB3D,CAAI,GACzB,MAAM;AAAA,CAAI;AAC3B,MAAA0D,EAAS;AAAA,QACPC,EACG,IAAI,CAACL,GAAMjD,OAAOA,IAAI,IAAI,IAAI,OAAOoD,EAAO,MAAM,IAAI,MAAMH,CAAI,EAChE,KAAK;AAAA,CAAI;AAAA,MAAA;AAAA,IAEhB;AACA,WAAO,GAAGG,CAAM,GAAGC,EAAS,KAAK;AAAA,CAAI,CAAC;AAAA,EACxC;AAAA,EAEA,MAAc,aAAaxC,GAA+B;AAExD,WAAOA,EAAM,OAAO,SAAS,aACzB,KAAKA,EAAM,OAAO,EAAE,KAAKA,EAAM,OAAO,GAAG,MACzC,OACE,MAAM,KAAK,gCAAgC,OAC3C,eAAeA,EAAM,QAAQA,EAAM,GAAG;AAAA,EAC9C;AAAA,EAEA,MAAc,aACZ0C,GACiB;AACjB,UAAM,EAAE,SAAApD,GAAS,MAAAD,EAAA,IAASqD,GAEpBtC,IAAM;AAAA,OAER,MAAM,QAAQ;AAAA,QACZd,EAAQ;AAAA,UAAI,CAACqD,MACXA,EAAO,aAAa,KAAK,iBAAiBA,EAAO,UAAU,IAAI;AAAA,QAAA;AAAA,MACjE,GAEF,KAAK,KAAK;AAAA,MACZrD,EAAQ,IAAI,MAAM,KAAK,EAAE,KAAK,KAAK;AAAA,IAAA;AAGrC,eAAWC,KAAQF;AACjB,MAAAe,EAAI;AAAA,SAEA,MAAM,QAAQ,IAAIb,EAAK,IAAI,CAACT,MAAS,KAAK,iBAAiBA,CAAI,CAAC,CAAC,GACjE,KAAK,KAAK;AAAA,MAAA;AAIhB,WAAOsB,EAAI,IAAI,CAACgC,MAAS,KAAKA,CAAI,IAAI,EAAE,KAAK;AAAA,CAAI;AAAA,EACnD;AAAA,EAEQ,iBAAiB7C,GAAkC;AACzD,WAAO,KAAK,sBAAsBA,EAAK,OAAO;AAAA,EAChD;AAAA,EAEA,MAAM,sBACJqD,GACiB;AACjB,YACE,MAAM,QAAQ;AAAA,MACZA,EAAe,IAAI,CAAC9D,MAAS,KAAK,qBAAqBA,CAAI,CAAC;AAAA,IAAA,GAE9D,KAAK,EAAE;AAAA,EACX;AAAA,EAEA,MAAM,qBAAqB+D,GAA+C;AACxE,YAAQA,EAAc,MAAA;AAAA,MACpB,KAAK;AACH,eAAO,KAAK,YAAYA,CAAa;AAAA,MACvC,KAAK;AACH,eAAO,KAAK,aAAaA,CAAa;AAAA,MACxC,KAAK;AACH,eAAO,KAAK,YAAYA,CAAa;AAAA,MACvC,KAAK;AACH,eAAO,KAAK,aAAaA,EAAc,MAAMA,EAAc,MAAM;AAAA,IAAA;AAAA,EAEvE;AAAA,EAEA,MAAc,YAAYA,GAAsC;AAC9D,YAAQA,EAAc,OAAO,MAAA;AAAA,MAC3B,KAAK;AACH,eAAO,IAAI,MAAM,KAAK,sBAAsBA,EAAc,OAAO,CAAC,KAAKA,EAAc,OAAO,GAAG;AAAA,MAEjG,KAAK;AAGH,gBADE,MAAM,KAAK,gCAAgC,IAAA,GACtB;AAAA,UACrBA,EAAc;AAAA,UACdA,EAAc;AAAA,UACd;AAAA,QAAA;AAAA,IAEJ;AAAA,EAEJ;AAAA,EAEQ,aACNxF,GACAiE,GACQ;AACR,WAAO,KAAKjE,CAAI,GAAG,OAAO,QAAQiE,CAAU,EACzC;AAAA,MACC,CAAC,CAACjE,GAAMyF,CAAK,MACX,IAAIzF,CAAI,KAAKyF,EAAM,SAAA,EAAW,QAAQ,OAAO,QAAQ,EAAE,QAAQ,MAAM,OAAO,CAAC;AAAA,IAAA,EAEhF,KAAK,EAAE,CAAC;AAAA,EACb;AAAA;AAAA,EAGQ,YAAY3C,GAAoB;AACtC,UAAM,EAAE,SAAAlB,GAAS,QAAAY,EAAA,IAAWM,GAEtB,EAAE,MAAA4C,GAAM,QAAAC,GAAQ,eAAAC,GAAe,MAAAC,MAASrD,GAExCsD,IAAe,CAAA;AAIrB,WAAID,KACFC,EAAa,KAAK,GAAG,GAGnBF,KACFE,EAAa,KAAK,IAAI,GAGpBH,KACFG,EAAa,KAAK,GAAG,GAGnBJ,KACFI,EAAa,KAAK,IAAI,GAGjB,GAAGA,EAAa,KAAK,EAAE,CAAC,GAAGlE,CAAO,GAAGkE,EAAa,QAAA,EAAU,KAAK,EAAE,CAAC;AAAA,EAC7E;AACF;AA3NavB,IAANzD,EAAA;AAAA,EADNC,EAAA;AAAA,EAKIC,OAAO,iCAAiC,CAAA;AAAA,GAJhCuD,CAAA;ACLb,MAAMwB,IAAgC,6BAMhCC,IAAgC;AAMtC,MAAMC,GAAc;AAAA,EAClB,YAAYC,GAAsB;AAChC,IAAAA,EACG,KAAgCH,CAA6B,EAC7D,GAAG9E,CAAgC,EACnC,YAAA,GAEHiF,EACG,KAAgCF,CAA6B,EAC7D,GAAGzB,CAAgC,EACnC,YAAA,GAOH2B,EACG,KAAsC,iCAAiC,EACvE,GAAG5B,CAA+B,GAOrC,KAAK,iBAAiB4B,CAAS,GAC/B,KAAK,qBAAqBA,CAAS,GACnC,KAAK,kBAAkBA,CAAS,GAChC,KAAK,sBAAsBA,CAAS,GAEpCA,EACG,KAAkC,6BAA6B,EAC/D,GAAGvF,CAA2B,EAC9B,YAAA,GAGHuF,EACG;AAAA,MACC;AAAA,IAAA,EAED,UAAU,MACF,OACE;AAAA,MACL,8BAA8B;AAAA,IAAA,EAGnC,EACA,UAAU,OAAO;AAAA,EACtB;AAAA,EAEQ,iBAAiBA,GAAsB;AAC7C,UAAMlG,IAAO;AACb,IAAAkG,EACG;AAAA,MACC;AAAA,IAAA,EAED,UAAU,CAACC,MACH,YAAY;AACjB,YAAMC,KACJ,MAAM,OACJ,8CACF,GACA;AACF,aAAO,KAAK,YAAYF,GAAWlG,GAAMoG,GAAWD,CAAO;AAAA,IAC7D,CACD,EACA,UAAUnG,CAAI;AAAA,EACnB;AAAA,EACQ,qBAAqBkG,GAAsB;AACjD,UAAMlG,IAAO;AACb,IAAAkG,EACG;AAAA,MACC;AAAA,IAAA,EAED,UAAU,CAACC,MACH,YAAY;AACjB,YAAMC,KACJ,MAAM,OACJ,kDACF,GACA;AACF,aAAO,KAAK,YAAYF,GAAWlG,GAAMoG,GAAWD,CAAO;AAAA,IAC7D,CACD,EACA,UAAUnG,CAAI;AAAA,EACnB;AAAA,EACQ,kBAAkBkG,GAAsB;AAC9C,UAAMlG,IAAO;AACb,IAAAkG,EACG;AAAA,MACC;AAAA,IAAA,EAED,UAAU,CAACC,MACH,YAAY;AACjB,YAAMC,KACJ,MAAM,OACJ,+CACF,GACA;AACF,aAAO,KAAK,YAAYF,GAAWlG,GAAMoG,GAAWD,CAAO;AAAA,IAC7D,CACD,EACA,UAAUnG,CAAI;AAAA,EACnB;AAAA,EACQ,sBAAsBkG,GAAsB;AAClD,UAAMlG,IAAO;AACb,IAAAkG,EACG;AAAA,MACC;AAAA,IAAA,EAED,UAAU,CAACC,MACH,YAAY;AACjB,YAAMC,KACJ,MAAM,OACJ,mDACF,GACA;AACF,aAAO,KAAK,YAAYF,GAAWlG,GAAMoG,GAAWD,CAAO;AAAA,IAC7D,CACD,EACA,UAAUnG,CAAI;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUQ,YACNkG,GACAlG,GACAoG,GACAD,GACA;AACA,WAAKD,EAAU,QAAQ,2BAA2B,EAAE,MAAAlG,EAAA,CAAY,KAC9DkG,EACG,KAA8B,yBAAyB,EACvD,GAAGE,CAAS,EACZ,UAAUpG,CAAI,GAEZmG,EAAQ,IAA6B,2BAA2B;AAAA,MACrE,MAAAnG;AAAA,IAAA,CACD;AAAA,EACH;AACF;"}