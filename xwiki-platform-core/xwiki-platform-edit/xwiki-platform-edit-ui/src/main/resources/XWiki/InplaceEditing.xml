<?xml version="1.1" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc version="1.4" reference="XWiki.InplaceEditing" locale="">
  <web>XWiki</web>
  <name>InplaceEditing</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <parent>WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <version>1.1</version>
  <title/>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>true</hidden>
  <content>{{velocity wiki="false"}}
#if ($request.action == 'lock')
  ## This could be moved later to a Velocity template (e.g. lock.vm).
  #template('edit_macros.vm')
  #getEditConfirmation()
  #if ($editConfirmation)
    ## Ask for confirmation to force the lock.
    #set ($discard = $response.setStatus(423))
    #jsonResponse($editConfirmation)
  #else
    ## Lock the document for editing.
    #set ($lockParams = {
      'ajax': 1,
      'action': $request.lockAction,
      'language': $tdoc.realLocale
    })
    #if ($request.force == 'true')
      #set ($lockParams.force = 1)
    #end
    #set ($discard = $response.sendRedirect($tdoc.getURL('lock', $escapetool.url($lockParams))))
  #end
#end
{{/velocity}}</content>
  <object>
    <name>XWiki.InplaceEditing</name>
    <number>0</number>
    <className>XWiki.JavaScriptExtension</className>
    <guid>700dc756-1a3a-49e0-854f-c2ecb0d8e970</guid>
    <class>
      <name>XWiki.JavaScriptExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <defaultValue>long</defaultValue>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage|onDemand|always</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>(function(config) {
  "use strict";

const paths = config.paths;
const l10n = config.l10n;

require.config({
  paths: paths.js
});

define('xwiki-document-api', ['jquery'], function($) {
  var getOldAPI = function(xwikiDocument) {
    return (xwikiDocument.documentReference &amp;&amp; new XWiki.Document(xwikiDocument.documentReference)) ||
      XWiki.currentDocument;
  };

  return {
    /**
     * @return this document's plain title
     */
    getPlainTitle() {
      return $('&lt;div/&gt;').html(this.renderedTitle || this.title).text();
    },

    /**
     * @return this document's real locale
     */
    getRealLocale: function() {
      var realLocale = this.language;
      if (typeof realLocale !== 'string' || realLocale === '') {
        realLocale = this.getDefaultLocale();
      }
      return realLocale;
    },

    /**
     * @return this document's default locale
     */
    getDefaultLocale: function() {
      if (this.translations &amp;&amp; typeof this.translations['default'] === 'string') {
        return this.translations['default'];
      } else {
        // The default locale is not specified. Use the UI locale.
        return $('html').attr('lang');
      }
    },

    /**
     * @return the URL that can be used to perform the specified action on this document
     */
    getURL: function(action, queryString, fragment) {
      if (queryString &amp;&amp; typeof queryString === 'object') {
        queryString = $.param(queryString, true);
      }
      // Forward the call to the old API.
      var oldAPI = getOldAPI(this);
      return oldAPI.getURL.call(oldAPI, action, queryString, fragment);
    },

    /**
     * @param queryString the query string to add to the URL; it can be a string or a plain JavaScript object
     * @return the URL that can be used to retrieve this document's (JSON) data, taking into account whether this is the
     *         original document or a translation
     */
    getRestURL: function(queryString) {
      var oldAPI = getOldAPI(this);
      if (queryString &amp;&amp; typeof queryString === 'object') {
        queryString = $.param(queryString, true);
      }
      var entity = this.language &amp;&amp; ('translations/' + encodeURIComponent(this.language));
      return oldAPI.getRestURL(entity, queryString);
    },

    /**
     * Render the title and the content of this document.
     *
     * @param forView whether to render the document for view (without the rendering annotations) or for edit (with the
     *          rendering annotations); when rendering for edit some transformations might not be executed
     * @return a promise that resolves to this document instance if the render request succeeds
     */
    render: function(forView) {
      var queryString = {
        xpage: 'get',
        outputTitle: true,
        language: this.getRealLocale(),
        // Make sure the response is not retrieved from cache (IE11 doesn't obey the caching HTTP headers).
        timestamp: new Date().getTime()
      };
      if (!forView) {
        // We need the annotated XHTML when editing in order to be able to protect the rendering transformations and to
        // be able to recreate the wiki syntax.
        queryString.outputSyntax = 'annotatedxhtml';
        // Currently, only the macro transformations are protected and thus can be edited.
        // See XRENDERING-78: Add markers to modified XDOM by Transformations/Macros
        queryString.transformations = 'macro';
      }
      var thisXWikiDocument = this;
      return $.get(this.getURL('view'), queryString).fail(function() {
        new XWiki.widgets.Notification(l10n['edit.inplace.page.renderFailed'], 'error');
      }).then(function(html) {
        // Render succeeded.
        var container = $('&lt;div/&gt;').html(html);
        return $.extend(thisXWikiDocument, {
          renderedTitle: container.find('#document-title h1').html(),
          renderedContent: container.find('#xwikicontent').html()
        });
      }, function() {
        // Render failed.
        return thisXWikiDocument;
      });
    },

    /**
     * Reload this document's (JSON) data.
     *
     * @return a promise that resolves to this document instance if the reload request succeeds
     */
    reload: function() {
      var thisXWikiDocument = this;
      return $.getJSON(this.getRestURL(), {
        // Make sure the response is not retrieved from cache (IE11 doesn't obey the caching HTTP headers).
        timestamp: new Date().getTime()
      }).then(function(newXWikiDocument) {
        // Reload succeeded.
        // Resolve the document reference.
        thisXWikiDocument.documentReference = XWiki.Model.resolve(newXWikiDocument.id, XWiki.EntityType.DOCUMENT);
        // We were able to load the document so it's not new.
        thisXWikiDocument.isNew = false;
        return $.extend(thisXWikiDocument, newXWikiDocument);
      }, function() {
        // Reload failed.
        return thisXWikiDocument;
      });
    },

    /**
     * Lock this document for the specified action. The request fails if the document is already locked, unless the lock
     * is forced.
     *
     * @return a promise that resolves to this document instance if the lock request succeeds
     */
    lock: function(action, force) {
      var thisXWikiDocument = this;
      action = action || 'edit';
      return $.getJSON(this.getURL('get'), {
        sheet: 'XWiki.InplaceEditing',
        action: 'lock',
        lockAction: action,
        force: force,
        language: this.getRealLocale(),
        outputSyntax: 'plain',
        // Make sure the response is not retrieved from cache (IE11 doesn't obey the caching HTTP headers).
        timestamp: new Date().getTime()
      }).then(function() {
        // Lock succeeded.
        thisXWikiDocument.locked = action;
        return thisXWikiDocument;
      }, function(response) {
        // Lock failed.
        delete thisXWikiDocument.locked;
        // Check if the user can force the lock.
        var lockConfirmation = response.responseJSON;
        if (response.status === 423 &amp;&amp; lockConfirmation) {
          // The user can force the lock, but needs confirmation.
          thisXWikiDocument.lockConfirmation = lockConfirmation;
        }
        return thisXWikiDocument;
      });
    },

    /**
     * Unlock this document for the specified action, by sending a beacon, if the browser supports it, or by making a
     * synchronous HTTP request, because this function can be called just before the window is unloaded.
     */
    unlock: function(action) {
      action = action || 'edit';
      this.locked = false;
      var url = this.getURL('cancel', $.param({
        ajax: 1,
        action: action,
        language: this.getRealLocale()
      }));
      if (navigator.sendBeacon) {
        navigator.sendBeacon(url);
      } else {
        // Make a synchronous request otherwise, because the page can unload before the unlock request is sent.
        // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests
        $.ajax({type: 'GET', url: url, async: false});
      }
    },

    /**
     * Makes sure this document matches the current UI locale.
     */
    translate: function() {
      const realLocale = this.getRealLocale();
      const uiLocale = $('html').attr('lang');
      if (realLocale &amp;&amp; realLocale !== uiLocale) {
        this.language = uiLocale;
        // Set the original document locale.
        this.translations = this.translations || {};
        this.translations['default'] = realLocale;
        // Update the document fields that are not 'shared' with the original document.
        this.isNew = true;
        delete this.version;
        delete this.majorVersion;
        delete this.minorVersion;
      }
    }
  };
});

define('editInPlace', [
  'jquery',
  // We need this in order to access information about the current page.
  'xwiki-meta',
  // We need this in order to easily work with the XWiki document JSON.
  'xwiki-document-api',
  // We need this for the confirmation modals.
  'bootstrap',
  // We need this in order to catch events triggered by actionButtons.js using Prototype.js
  'xwiki-events-bridge'
], function($, xcontext, xwikiDocumentAPI) {
  var preload = function() {
    paths.css.forEach(loadCSS);
    return initActionButtons();
  };

  var loadCSS = function(url) {
    var link = $('&lt;link&gt;').attr({
      type: 'text/css',
      rel: 'stylesheet',
      href: url
    }).appendTo('head');
  };

  var editPage = function() {
    return editInPlace({
      afterEdit: function() {
        $('#document-title-input').focus().select();
      }
    });
  };

  var translatePage = function() {
    return editInPlace({
      afterEdit: createTranslation
    });
  };

  var editSection = function(sectionId) {
    return editInPlace({
      lockFailed: function() {
        // Revert the changes done on #xwikicontent.
        $('#xwikicontent').removeAttr('tabindex').children(':header').children('.edit_section').removeClass('hidden');
      },
      afterEdit: function() {
        // We don't need the tabindex attribute anymore now that the content is editable.
        $('#xwikicontent').removeAttr('tabindex');
        if (sectionId) {
          // Select the heading of the specified section.
          $('#xwikicontent &gt; #' + escapeSelector(sectionId)).each(function() {
            selectText(this);
          });
        }
      }
    });
  };

  var escapeSelector = function(selector) {
    if (window.CSS &amp;&amp; typeof CSS.escape === 'function') {
      // Not supported by Internet Explorer.
      return CSS.escape(selector);
    } else if (typeof $.escapeSelector === 'function') {
      // Added in jQuery 3.0
      return $.escapeSelector(selector);
    } else if (typeof selector === 'string') {
      // Simple implementation.
      // See https://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/
      return selector.replace(/(:|\.|\[|\]|,|=|@)/g, '\\$1');
    } else {
      return selector;
    }
  };

  // We preserve the document data between edits in order to be able to know which document translation should be edited
  // (e.g. when the document translation is missing and we create it, the next edit session should target the created
  // translation).
  var currentXWikiDocument = $.extend({
    language: xcontext.locale
  }, xwikiDocumentAPI);

  var editInPlace = function(options) {
    options = $.extend({
      afterEdit: function() {},
      lockFailed: function() {}
    }, options);
    $('#xwikicontent').addClass('loading');
    // Lock the document first.
    return lock(currentXWikiDocument).fail(options.lockFailed)
      // Then load the document only if we managed to lock it.
      .then(load)
      // Then load the editors only if we managed to load the document.
      .then(edit).done(options.afterEdit).always(function() {
        $('#xwikicontent').removeClass('loading');
      // Then wait for an action (save, cancel, reload) only if the editors were loaded successfuly.
      }).then(maybeSave)
      // Then unlock the document both when the edit ended with success and with a failure.
      .then(unlock, unlock)
      // Finally view the document both when the edit ended with success and with a failure.
      .then(view, view)
      .always(function(xwikiDocument) {
        // Update the current document for the next edit session.
        currentXWikiDocument = xwikiDocument;
      });
  };

  var lock = function(xwikiDocument) {
    return xwikiDocument.lock().then(null, function(xwikiDocument) {
      // If the document was already locked then we need to ask the user if they want to force the lock.
      if (xwikiDocument.lockConfirmation) {
        var confirmation = xwikiDocument.lockConfirmation;
        delete xwikiDocument.lockConfirmation;
        return maybeForceLock(confirmation).then($.proxy(xwikiDocument, 'lock', 'edit', true), function() {
          // Cancel the edit action.
          return xwikiDocument;
        });
      } else {
        new XWiki.widgets.Notification(l10n['edit.inplace.page.lockFailed'], 'error');
        return xwikiDocument;
      }
    });
  };

  var maybeForceLock = function(confirmation) {
    var deferred = $.Deferred();
    // Reuse the confirmation modal once it is created.
    var modal = $('.force-edit-lock-modal');
    if (modal.length === 0) {
      modal = createForceLockModal();
    }
    // Update the deferred that needs to be resolved or rejected.
    modal.data('deferred', deferred);
    // Update the confirmation modal.
    modal.find('.modal-title').text(confirmation.title);
    modal.find('.modal-body').html(confirmation.message);
    modal.find('.modal-footer .btn-default').text(confirmation.reject);
    if (confirmation.confirm) {
      modal.find('.modal-footer .btn-warning').show().text(confirmation.confirm);
    } else {
      modal.find('.modal-footer .btn-warning').hide();
    }
    // Show the confirmation modal.
    modal.modal('show');
    return deferred.promise();
  };

  var createForceLockModal = function() {
    var modal = $([
      '&lt;div class="modal fade force-edit-lock-modal" tabindex="-1" role="dialog"&gt;',
        '&lt;div class="modal-dialog" role="document"&gt;',
          '&lt;div class="modal-content"&gt;',
            '&lt;div class="modal-header"&gt;',
              '&lt;button type="button" class="close" data-dismiss="modal"&gt;',
                '&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;',
              '&lt;/button&gt;',
              '&lt;h4 class="modal-title"&gt;&lt;/h4&gt;',
            '&lt;/div&gt;',
            '&lt;div class="modal-body"&gt;&lt;/div&gt;',
            '&lt;div class="modal-footer"&gt;',
              '&lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;&lt;/button&gt;',
              '&lt;button type="button" class="btn btn-warning"&gt;&lt;/button&gt;',
            '&lt;/div&gt;',
          '&lt;/div&gt;',
        '&lt;/div&gt;',
      '&lt;/div&gt;'
    ].join(''));
    modal.find('.close').attr('aria-label', l10n['edit.inplace.close']);
    modal.find('.modal-footer .btn-warning').click(function() {
      // The user has confirmed they want to force the lock.
      modal.data('deferred').resolve();
      modal.modal('hide');
    });
    modal.on('hide.bs.modal', function() {
      // If the lock promise is not yet resolved when the modal is closing then it means the modal was canceled,
      // i.e. the user doesn't want to force the lock.
      var deferred = modal.data('deferred');
      if (deferred.state() === 'pending') {
        deferred.reject();
      }
    });
    return modal.appendTo('body').modal();
  };

  var load = function(xwikiDocument) {
    return xwikiDocument.reload().done(function(xwikiDocument) {
      // Clone the current document version and keep a reference to it in order to be able to restore it on cancel.
      xwikiDocument.originalDocument = $.extend(true, {
        renderedTitle: $('#document-title h1').html(),
        renderedContent: $('#xwikicontent').html()
      }, xwikiDocument);
    }).fail(function() {
      new XWiki.widgets.Notification(l10n['edit.inplace.page.loadFailed'], 'error');
    // Render the document for edit, in order to have the annotated content HTML. The annotations are used to protect
    // the rendering transformations (e.g. macros) when editing the content.
    }).then($.proxy(render, null, false));
  };

  /**
   * @param forView whether to render the document for view (without the rendering annotations) or for edit (with the
   *          rendering annotations); when rendering for edit some transformations might not be executed
   * @param xwikiDocument the document to render
   */
  var render = function(forView, xwikiDocument) {
    return xwikiDocument.render(forView);
  };

  var maybeSave = function(xwikiDocument) {
    return waitForAction(xwikiDocument).then(function(action) {
      switch(action.name) {
        case 'save': return save({
          document: action.document,
          'continue': action.data &amp;&amp; action.data['continue']
        });
        case 'reload': return reload(action.document);
        default: return cancel(action.document);
      }
    });
  };

  var waitForAction = function(xwikiDocument) {
    var deferred = $.Deferred();
    // We wait for the first save, reload or cancel event, whichever is triggered first. Note that the event listeners
    // that are not executed first will remain registered but that doesn't cause any problems because the state of a
    // deferred object (promise) cannot change once it was resolved. So the first event that fires will resolve the
    // promise and the remaining events won't be able to change that. The remaining event listeners could be called
    // later but they won't have any effect on the deferred object.
    $(document).one([
      'xwiki:actions:save',
      'xwiki:actions:reload',
      'xwiki:actions:cancel',
    ].join(' '), '.xcontent.form', function(event, data) {
      deferred.resolve({
        name: event.type.substring('xwiki:actions:'.length),
        document: xwikiDocument,
        data: data
      });
    });
    return deferred.promise();
  };

  var save = function(data) {
    // Push the changes to the server.
    return push(data.document).then(function(xwikiDocument) {
      // Save succeeded.
      return shouldReload(xwikiDocument).then(
        // The document was saved with merge and thus if we want to continue eding we need to reload the editor (because
        // its content doesn't match the saved content).
        reload,
        // No need to reload the editor because either the action was Save &amp; View or there was no merge on save.
        $.proxy(maybeContinueEditing, null, data['continue'])
      );
    // Save failed. Continue editing because we may have unsaved content.
    }, maybeSave);
  };

  var push = function(xwikiDocument) {
    // Let actionButtons.js do the push. We just catch the result.
    var deferred = $.Deferred();
    // We wait for the save request to either succeed or fail. Note that one of the event listeners will remain
    // registered but that doesn't cause any problems because the state of a deferred object (promise) cannot change
    // once it was resolved or rejected. So the first event that fires will resolve/reject the promise and the remaining
    // event won't be able to change that. The remaining event listener could be called later but it won't have any
    // effect.
    $(document).one('xwiki:document:saved', '.xcontent.form', $.proxy(deferred, 'resolve', xwikiDocument));
    $(document).one('xwiki:document:saveFailed', '.xcontent.form', $.proxy(deferred, 'reject', xwikiDocument));
    return deferred.promise();
  };

  var maybeContinueEditing = function(continueEditing, xwikiDocument) {
    var afterReloadAndRender = function(success, xwikiDocument) {
      if (continueEditing) {
        if (success) {
          // Update the original version in order to be able to restore it on cancel.
          delete xwikiDocument.originalDocument;
          xwikiDocument.originalDocument = $.extend(true, {}, xwikiDocument);
        }
        // Continue editing.
        return maybeSave(xwikiDocument);
      } else {
        // This is the final version. We stop editing even if the reload / render failed.
        return xwikiDocument;
      }
    };

    // Reload the document JSON data (to have the new version) and render the document for view. We need the view HTML
    // both if we stop editing now and if we continue but cancel the edit later.
    return xwikiDocument.reload().then($.proxy(render, null, true)).then(
      $.proxy(afterReloadAndRender, null, /* success: */ true),
      $.proxy(afterReloadAndRender, null, /* success: */ false)
    );
  };

  var cancel = function(xwikiDocument) {
    // Simply return the original version to be restored.
    return xwikiDocument.originalDocument;
  };

  // Unlock the document so that other users can edit it.
  var unlock = function(xwikiDocument) {
    // Check if we're still editing.
    if (xwikiDocument.locked &amp;&amp; $('#document-title-input').length &gt; 0) {
      xwikiDocument.unlock();
    }
    return xwikiDocument;
  };

  // Make sure we unlock the document when the user navigates to another page.
  $(window).on('unload pagehide', $.proxy(unlock, null, currentXWikiDocument));

  var shouldReload = function(xwikiDocument) {
    var reloadEventFired = false;
    $(document).one('xwiki:actions:reload.maybe', '.xcontent.form', function() {
      reloadEventFired = true;
    });
    var deferred = $.Deferred();
    // Wait a bit to see if the reload event is fired.
    setTimeout(function() {
      // Remove the listener in case the reload event wasn't fired.
      $(document).off('xwiki:actions:reload.maybe');
      if (reloadEventFired) {
        deferred.resolve(xwikiDocument);
      } else {
        deferred.reject(xwikiDocument);
      }
    }, 0);
    return deferred.promise();
  };

  var reload = function(xwikiDocument) {
    // Leave the edit mode and then re-enter.
    return view(xwikiDocument, true).then(editInPlace);
  };

  var view = function(xwikiDocument, reload) {
    var viewContent = $('#xwikicontent');
    // Destroy the editors before returning to view.
    viewContent.trigger('xwiki:actions:view', {document: xwikiDocument});
    $('#document-title h1').html(xwikiDocument.renderedTitle);
    viewContent.html(xwikiDocument.renderedContent);
    if (!reload) {
      // If the user has canceled the edit then the restored page content may include the section edit links. Show them
      // in case they were hidden.
      viewContent.children(':header').children('.edit_section').removeClass('hidden');
      // Let others know that the DOM has been updated, in order to enhance it.
      $(document).trigger('xwiki:dom:updated', {'elements': viewContent.toArray()});
    }
    // Remove the action events scope.
    viewContent.closest('.form').removeClass('form');
    // Update the URL.
    if (window.location.hash === '#edit' || window.location.hash === '#translate') {
      history.replaceState(null, null, '#');
    }
    return $.Deferred().resolve(xwikiDocument).promise();
  };

  var edit = function(xwikiDocument) {
    // By adding the 'form' CSS class we set the scope of the action events (e.g. xwiki:actions:beforeSave or
    // xwiki:actions:cancel). We need this because in view mode we can have multiple forms active on the page (e.g. one
    // for editing the document content in place and one for editing the document syntax in-place) and we don't want
    // them to interfere (e.g. canceling one form shouldn't cancel the other forms).
    $('#xwikicontent').closest('.xcontent').addClass('form');
    return initActionButtons(xwikiDocument).then(initTitleEditor).then(initContentEditor)
      .then(startRealTimeEditingSession);
  };

  var initActionButtons = function(xwikiDocument) {
    if (xwikiDocument) {
      initTranslateButton(xwikiDocument);
    }
    var editContent = $('#xwikicontent');
    // We need the wrapper because #xwikicontent uses Bootstrap grid (col-xs-12) which is implemented with CSS float.
    // Thus we need to use the grid for the sticky buttons also otherwise the postion is badly computed when scrolling
    // (because of the float on the previous element). This wouldn't be needed if we were using position:sticky, which
    // we can't use yet because it's not implemented on IE11 which we still have to support.
    var actionButtonsWrapper = editContent.nextAll('.sticky-buttons-wrapper');
    if (actionButtonsWrapper.length === 0) {
      actionButtonsWrapper = $('&lt;div class="sticky-buttons-wrapper col-xs-12"&gt;' +
        '&lt;div class="inplace-editing-buttons sticky-buttons"/&gt;&lt;/div&gt;').insertAfter(editContent).toggle(!!xwikiDocument);
      var actionButtons = actionButtonsWrapper.children('.sticky-buttons')
        .data('xwikiDocument', xwikiDocument)
        // Expose the fake form if an extension needs to manipulate it.
        .data('fakeForm', fakeForm);
      return loadActionButtons(actionButtons);
    } else {
      // If we're editing a page..
      if (xwikiDocument) {
        // ..then make sure the action buttons are displayed right away (don't wait for the user to scroll).
        actionButtonsWrapper.show().children('.sticky-buttons')
          .data('xwikiDocument', xwikiDocument)
          // Expose the fake form if an extension needs to manipulate it.
          .data('fakeForm', fakeForm)
          // but make sure the position of the action buttons is updated.
          .trigger('xwiki:dom:refresh');
        // The action buttons are disabled on Save &amp; View. We don't reload the page on Save &amp; View and we reuse the
        // action buttons so we need to re-enable them each time we enter the edit mode.
        fakeForm.enable();
      }
      return $.Deferred().resolve(xwikiDocument).promise();
    }
  };

  var createTranslation = function(xwikiDocument) {
    xwikiDocument.translate();
    $('#document-title-input').focus().select();
    // Let the user know that they are now editing the translation of this page in the current locale.
    $('#document-title-input').popover({
      content: l10n['edit.inplace.page.translate.messageAfter'],
      placement: 'bottom',
      trigger: 'manual'
    }).popover('show').one('blur', function() {
      // Hide the popover when the title input loses the focus.
      $(this).popover('hide');
    });
  };

  var initTranslateButton = function(xwikiDocument) {
    // Initialize the translate button only if it's visible.
    const translateButton = $(config.translateButtonSelector).filter('[data-toggle="popover"]').filter(':visible');
    translateButton.off('click.translate').on('click.translate', function(event) {
      event.preventDefault();
      translateButton.parent().addClass('hidden');
      createTranslation(xwikiDocument);
    // Let the user know that they are editing the original version of the page and not the translation corresponding
    // to the current locale because there isn't one created yet.
    }).attr({
      // Backup the initial popover message to be able to restore it on view.
      'data-content-view': translateButton.attr('data-content'),
      // Use a custom popover message dedicated to the edit action.
      'data-content': l10n['edit.inplace.page.translate.messageBefore']
    }).popover('show')
    // Hide the popover on the next click. The user can still see the message by hovering the translate button.
    .closest('html').one('click', function() {
      translateButton.popover('hide');
    });
  };

  var loadActionButtons = function(actionButtons) {
    $(document).on('xwiki:actions:view', '.xcontent.form', function(event, data) {
      // Blur the action buttons first to re-enable the "disabled in inputs" shortcut keys (e.g. the page edit
      // shortcut), then disable the action buttons in order to disable their shortcut keys while we're not editing
      // in-place (e.g. prevent the Save shortcut while the user is only viewing the page). Finally hide the action
      // buttons to have them ready for the next editing session (the user can save or cancel and then edit again
      // without reloading the page).
      actionButtons.find(':input').blur().prop('disabled', true).end().parent().hide();
      // Restore the Translate button if the locale of the viewed document doesn't match the current user interface
      // locale (because the viewed document doesn't have a translation in the current locale).
      var xwikiDocumentLocale = data.document.getRealLocale();
      var uiLocale = $('html').attr('lang');
      if (xwikiDocumentLocale &amp;&amp; xwikiDocumentLocale !== uiLocale) {
        const translateButton = $(config.translateButtonSelector).filter('[data-toggle="popover"]');
        // Restore the translation button behavior for view action.
        translateButton.off('click.translate')
          // Restore the popover text for view action.
          .attr('data-content', translateButton.attr('data-content-view') || translateButton.attr('data-content'))
          // Restore the visibility.
          .parent().removeClass('hidden');
      }
    });
    return $.get(XWiki.currentDocument.getURL('get'), {
      xpage: 'editactions'
    }).then(function(html) {
      actionButtons.html(html);
      // Fix the name of the Save &amp; View action.
      actionButtons.find('.btn-primary').first().attr('name', 'action_save');
      // Append the hidden input field that keeps the CSRF token.
      $('&lt;input type="hidden" name="form_token" /&gt;').val(xcontext.form_token).appendTo(actionButtons);
      // We need a place where actionButtons.js can add more hidden inputs.
      actionButtons.append('&lt;div class="hidden extra"/&gt;');
      // Let the others know that the DOM has been updated, in order to enhance it.
      $(document).trigger('xwiki:dom:updated', {'elements': actionButtons.toArray()});
      var deferred = $.Deferred();
      require(['xwiki-actionButtons', 'xwiki-diff', 'xwiki-autoSave'], function() {
        overrideEditActions();
        overrideAjaxSaveAndContinue();
        // Activate the auto-save feature passing our fake edit form. Note that autosave.js also creates an instance of
        // AutoSave but it doesn't do anything because it doesn't find a real edit form in the page. This is why we have
        // to create our own instance of AutoSave passing the right (fake) form.
        new XWiki.editors.AutoSave({form: fakeForm});
        var xwikiDocument = actionButtons.data('xwikiDocument');
        // Enable the action buttons (and their shortcut keys) only if we're editing a document.
        actionButtons.find(':input').prop('disabled', !xwikiDocument);
        deferred.resolve(xwikiDocument);
      });
      return deferred.promise();
    }, function() {
      new XWiki.widgets.Notification(l10n['edit.inplace.actionButtons.loadFailed'], 'error');
    });
  };

  // actionButtons.js expects a form so we use a fake form. Refactoring actionButtons.js is too dangerous ATM.
  var fakeForm = {
    action: XWiki.currentDocument.getURL('save'),
    async: true,
    _getActionButtons: function() {
      if (!this._actionButtons) {
        this._actionButtons = $('#xwikicontent').nextAll('.sticky-buttons-wrapper').children('.sticky-buttons');
      }
      return this._actionButtons;
    },
    disable: function() {
      this._getActionButtons().find(':input').prop('disabled', true);
    },
    enable: function() {
      // Clear the extra hidden input fields, that actionButtons.js might have added, each time the form is (re)enabled
      // (i.e. after a failed Save &amp; View or before entering the edit mode) because they are designed to be used once.
      this._getActionButtons().find('.hidden.extra').empty();
      this._getActionButtons().find(':input').prop('disabled', false);
    },
    insert: function(element) {
      this._getActionButtons().find('.hidden.extra').append(element);
    },
    // Note that this method only works with single argument.
    append: function(element) {
      this.insert(element);
    },
    down: function(selector) {
      return this._getActionButtons().find(selector)[0];
    },
    serialize: function() {
      var extra = this._getActionButtons().find(':input').serializeArray().reduce(function(extra, entry) {
        var value = extra[entry.name] || [];
        value.push(entry.value);
        extra[entry.name] = value;
        return extra;
      }, {});
      var xwikiDocument = this._getActionButtons().data('xwikiDocument');
      var formData = {
        title: xwikiDocument.rawTitle,
        language: xwikiDocument.getRealLocale(),
        isNew: xwikiDocument.isNew
      };
      if (xwikiDocument.content != xwikiDocument.originalDocument.content) {
        // Submit the raw (source) content. No syntax conversion is needed in this case.
        formData.content = xwikiDocument.content;
      } else {
        // Submit the rendered content (HTML), but make sure it is converted to the document syntax on the server.
        $.extend(formData, {
          content: xwikiDocument.renderedContent,
          RequiresHTMLConversion: 'content',
          content_syntax: xwikiDocument.syntax
        });
      }
      // Check for merge conflicts only if the document is not new and we know the current version.
      if (!xwikiDocument.isNew &amp;&amp; xwikiDocument.version) {
        formData.previousVersion = xwikiDocument.version;
        formData.editingVersionDate = new Date(xwikiDocument.modified).getTime();
      }
      // Ensure that formData information has priority over extra information.
      return $.extend({}, extra, formData);
    }
  };

  var overrideEditActions = function() {
    // Override the EditActions.notify() function in order to pass a fake form in the event parameters.
    var originalNotify = XWiki.actionButtons.EditActions.prototype.notify;
    XWiki.actionButtons.EditActions.prototype.notify = function(originalEvent, action, params) {
      if (params &amp;&amp; $(originalEvent.element()).closest('.inplace-editing-buttons').length &gt; 0) {
        // actionButtons.js expects a form so we use a fake form. Refactoring actionButtons.js is too dangerous ATM.
        // Note that we do this only when the event has parameters because we want to exclude the cancel event for which
        // actionButtons.js changes the window location if a form is specified, and we want to prevent that.
        params.form = fakeForm;
      }
      return originalNotify.apply(this, arguments);
    };
  };

  var overrideAjaxSaveAndContinue = function() {
    var originalAjaxSaveAndContinue = $.extend({}, XWiki.actionButtons.AjaxSaveAndContinue.prototype);
    $.extend(XWiki.actionButtons.AjaxSaveAndContinue.prototype, {
      reloadEditor: function() {
        var actionButtons = $('.inplace-editing-buttons');
        if (actionButtons.is(':visible')) {
          actionButtons.trigger('xwiki:actions:reload');
        } else {
          return originalAjaxSaveAndContinue.reloadEditor.apply(this, arguments);
        }
      },
      maybeRedirect: function(continueEditing) {
        if ($('.inplace-editing-buttons').is(':visible')) {
          // Overwrite the default behavior so that we don't redirect when leaving the edit mode because we're already
          // in view mode. We still need to report a redirect (return true) if we don't continue editing, so that
          // actionButtons.js behaves as if a redirect was done.
          return !continueEditing;
        } else {
          // Fallback on the default behavior if the in-place editing buttons are hidden.
          return originalAjaxSaveAndContinue.maybeRedirect.apply(this, arguments);
        }
      }
    });
  };

  var initTitleEditor = function(xwikiDocument) {
    var label = $('&lt;label for="document-title-input" class="sr-only"/&gt;')
      .text(l10n['core.editors.content.titleField.label']);
    var input = $('&lt;input type="text" id="document-title-input"/&gt;').val(xwikiDocument.rawTitle);
    var placeholder = xwikiDocument.documentReference.name;
    if (placeholder === 'WebHome') {
      placeholder = xwikiDocument.documentReference.parent.name;
    }
    input.attr('placeholder', placeholder);
    $('#document-title h1').addClass('editable').empty().append([label, input]);
    $(document).on('xwiki:actions:beforeSave.titleEditor', '.xcontent.form', function(event) {
      xwikiDocument.rawTitle = input.val();
    });
    $(document).one('xwiki:actions:view', '.xcontent.form', function(event, data) {
      // Destroy the title editor.
      $(document).off('xwiki:actions:beforeSave.titleEditor');
      $('#document-title h1').removeClass('editable').text(xwikiDocument.rawTitle);
    });
    return xwikiDocument;
  };

  var initContentEditor = function(xwikiDocument) {
    var editContent = $('#xwikicontent');
    var withFocus = document.activeElement &amp;&amp; document.activeElement === editContent[0];
    // Keep showing the view content until the edit content is ready in order to avoid UI flicker.
    var viewContent = editContent.clone().insertAfter(editContent);
    // Note that we don't trigger the xwiki:dom:updated event here because we want to let the editor trigger the event
    // only for the content areas that are safe to be updated from JavaScript (i.e. the macro output).
    editContent.hide().html(xwikiDocument.renderedContent);
    if (withFocus) {
      // Keep the focus while the edit content is being prepared.
      viewContent.focus();
    }
    var data = $.extend({}, config, {
      document: xwikiDocument,
      // The content editor is loaded on demand, asynchronously.
      deferred: $.Deferred()
    });
    editContent.trigger('xwiki:actions:edit', data);
    return data.deferred.done(function() {
      editContent.show();
      viewContent.remove();
      if (withFocus) {
        // Restore the focus when the edit content is ready but make sure we don't scroll the page. We don't restore the
        // focus right away because we just made the content visible so it may not be editable yet (e.g. the WYSIWYG
        // editor can make the content editable only if it is visible).
        setTimeout(function() {
          editContent[0].focus({preventScroll: true});
        }, 0);
      }
    }).promise();
  };

  var startRealTimeEditingSession = function(xwikiDocument) {
    // TODO
    return xwikiDocument;
  };

  var selectText = function(node) {
    if (window.getSelection) {
      var selection = window.getSelection();
      var range = document.createRange();
      range.selectNodeContents(node);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  };

  return {
    preload,
    editPage,
    editSection,
    translatePage
  };
});

require(['jquery'], function($) {
  // We can edit in-place only if the #xwikicontent element is present.
  if (!$('#xwikicontent').length) {
    return;
  }

  var wysiwygEditorModule = 'xwiki-' + config.wysiwygEditor + '-inline';

  var preloadEditor = function() {
    require(['editInPlace', wysiwygEditorModule], function(editInPlace) {
      editInPlace.preload();
    // Fallback on the standalone edit mode if we fail to load the required modules.
    }, disableInPlaceEditing);
  };

  // Preload the WYSIWYG editor code without slowing down the page view.
  if (document.readyState === 'complete') {
    setTimeout(preloadEditor, 0);
  } else {
    $(window).on('load', function() {
      setTimeout(preloadEditor, 0);
    });
  }

  var onInPlaceEditing = function(event) {
    // Make sure the user doesn't try to re-activate the edit mode while we are in edit mode.
    if (editButton.hasClass('disabled')) {
      return;
    }
    // Disable the edit buttons and hide the section edit links.
    editButton.add(translateButton).addClass('disabled');
    $('#xwikicontent').children(':header').children('.edit_section').addClass('hidden');
    event.preventDefault();
    const handler = event.data;
    const data = handler.beforeEdit?.(event);
    // Load the code needed to edit in place only when the edit button is clicked.
    require(['editInPlace', wysiwygEditorModule], function(editInPlace) {
      // Re-enable the translate button because it can be used while editing to create the missing translation.
      translateButton.removeClass('disabled');
      handler.edit(editInPlace, data).always(function() {
        // Restore only the edit button at the end because:
        // * the translate button is restored (if needed) by the editInPlace module
        // * the section edit links are restored when the document is rendered for view
        editButton.removeClass('disabled');
      });
    // Fallback on the standalone edit mode if we fail to load the required modules.
    }, $.proxy(disableInPlaceEditing, event.target));
  };

  var disableInPlaceEditing = function() {
    editButton.add(translateButton).off('click.inPlaceEditing').removeClass('disabled');
    $('#xwikicontent').off('click.inPlaceEditing').removeAttr('tabindex').children(':header').children('.edit_section')
      .removeClass('hidden');
    // Fallback on the standalone edit mode.
    $(this).click();
  };

  var editButton = $(config.editButtonSelector);
  editButton.on('click.inPlaceEditing', {
    beforeEdit: function() {
      history.replaceState(null, null, '#edit');
    },
    edit: function(editInPlace) {
      return editInPlace.editPage();
    }
  }, onInPlaceEditing).attr('data-editor', 'inplace');

  var translateButton = $(config.translateButtonSelector);
  translateButton.on('click.inPlaceEditing', {
    beforeEdit: function() {
      history.replaceState(null, null, '#translate');
      translateButton.parent().addClass('hidden');
    },
    edit: function(editInPlace) {
      return editInPlace.translatePage();
    }
  }, onInPlaceEditing);

  // Section in-place editing.
  $('#xwikicontent').on('click.inPlaceEditing', '&gt; :header &gt; a.edit_section:not(.disabled)', {
    beforeEdit: function(event) {
      // Focus the content right away to give the user instant visual feedback about what is going to happen.
      $('#xwikicontent').attr('tabindex', '0').focus();
      // Return the id of the edited section.
      return $(event.target).closest(':header').attr('id');
    },
    edit: function(editInPlace, sectionId) {
      return editInPlace.editSection(sectionId);
    }
  }, onInPlaceEditing);

  if (window.location.hash === '#edit') {
    editButton.click();
  } else if (window.location.hash === '#translate') {
    translateButton.click();
  }
});

require(['jquery'], function($) {
  // Backup the document title before each editing session in order to catch changes.
  var previousPlainTitle;
  $('#xwikicontent').on('xwiki:actions:edit', function(event, data) {
    previousPlainTitle = data.document.getPlainTitle();
  });

  // Update the UI after each editing session.
  $(document).on('xwiki:actions:view', function(event, data) {
    var xwikiDocument = data.document;
    updateDocAuthorAndDate(xwikiDocument);
    updateDocExtraTabs(xwikiDocument);
    updateDrawer(xwikiDocument);
    updateContentMenu(xwikiDocument);
    if (xwikiDocument.getPlainTitle() !== previousPlainTitle) {
      updateDocTrees(xwikiDocument);
      updateLinks(xwikiDocument);
    }
  });

  var updateDocAuthorAndDate = function(xwikiDocument) {
    var urlWithSelector = xwikiDocument.getURL('get', 'xpage=contentheader') + ' .xdocLastModification';
    $('.xdocLastModification').load(urlWithSelector, function() {
      // load() replaces the content of the specified container but we want to replace the container itself. We can't do
      // this from the selector, e.g. by using '.xdocLastModification &gt; *' because we lose the text nodes.
      $(this).children().unwrap();
    });
  };

  var updateDocExtraTabs = function(xwikiDocument) {
    // Reload the selected tab and force the reload of the hidden tabs next time they are selected.
    $('#docextrapanes').children().addClass('empty').empty();
    var selectedTab = $('#docExtraTabs .active[data-template]');
    if (selectedTab.length) {
      var docExtraId = selectedTab.attr('id');
      docExtraId = docExtraId.substring(0, docExtraId.length - 'tab'.length);
      XWiki.displayDocExtra(docExtraId, selectedTab.data('template'), false);
    }
  };

  // Update the document trees (e.g. breadcrumb, navigation) if they have nodes that correspond to the edited document.
  // Note that we want to update the internal tree data not just the link label. This is especially useful if we're
  // going to implement refactoring operations (rename) in the document tree.
  var updateDocTrees = function(xwikiDocument) {
    var plainTitle = xwikiDocument.getPlainTitle();
    $('.jstree-xwiki').each(function() {
      $(this).jstree?.(true)?.set_text?.('document:' + xwikiDocument.id, plainTitle);
    });
  };

  // Update the links that target the edited document and whose label matches the document title. Note that this can
  // update links whose label was not generated dynamically (e.g. with server side scripting) based on the document
  // title. For instance there could be links with hard-coded labels or with labels generated using a translatin key
  // (like in the Applications panel). For simplicity we assume that if the link matches the document URL and its
  // previous title then it needs to be updated, but this happens only at the UI level.
  var updateLinks = function(xwikiDocument) {
    var docURL = xwikiDocument.getURL();
    var newPlainTitle = xwikiDocument.getPlainTitle();
    // Exclude the links from the document content.
    // Update the links that contain only text (no child elements) otherwise we can lose UI elements (e.g. icons).
    $('a').not('#xwikicontent a').not(':has(*)').filter(function() {
      var linkURL = $(this).attr('href')?.split(/[?#]/, 1)[0];
      return linkURL === docURL &amp;&amp; $(this).text() === previousPlainTitle;
    }).text(newPlainTitle);
  };

  // Update the list of available document translations in the drawer menu. This is needed for instance when a new
  // translation is created using the in-place editor.
  var updateDrawer = function(xwikiDocument) {
    var languageMenu = $('#tmLanguages_menu');
    var locale = xwikiDocument.getRealLocale();
    // Look for the language query string parameter, either inside or at the end.
    var localeSelector = 'a[href*="language=' + locale + '&amp;"], a[href$="language=' + locale + '"]';
    // Check if the language menu is present (multilingual is on) and the document locale is not listed.
    if (languageMenu.length &amp;&amp; !languageMenu.find(localeSelector).length) {
      // If we get here then it means a new document translation was created and it needs to be listed in the drawer.
      $('&lt;div/&gt;').load(xwikiDocument.getURL('get', $.param({
        'xpage': 'xpart',
        'vm': 'drawer.vm',
        'useLayoutVars': true
      // Pass the query string from the current URL so that it gets included in the translation URL.
      // XWIKI-11314: Changing the current language from the UI does not preserve the query string of the current URL
      })) + '&amp;' + location.search.substring(1) + ' #tmLanguages_menu', function() {
        $(this).find('a').each(function() {
          // Clean the query string.
          $(this).attr('href', $(this).attr('href').replace(/&amp;?(xpage=xpart|vm=drawer\.vm|useLayoutVars=true)/g, '')
            .replace('?&amp;', '?'));
        });
        languageMenu.replaceWith($(this).children());
      });
    }
  };

  // Update the links from the content menu to point to the real document locale. This is needed especially when a new
  // document translation is created in-place.
  var updateContentMenu = function(xwikiDocument) {
    var realLocale = xwikiDocument.getRealLocale();
    var defaultLocale = xwikiDocument.getDefaultLocale();
    if (realLocale != defaultLocale) {
      var defaultLocaleRegex = new RegExp('(\\blanguage=)' + defaultLocale + '($|&amp;|#)');
      $('#contentmenu a[href*="language=' + defaultLocale + '"]').each(function() {
        $(this).attr('href', $(this).attr('href').replace(defaultLocaleRegex, '$1' + realLocale + '$2'));
      });
    }
  };
});

})(JSON.parse(document.querySelector('[data-inplace-editing-config]')?.getAttribute('data-inplace-editing-config')) ||
  {});</code>
    </property>
    <property>
      <name/>
    </property>
    <property>
      <parse>0</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>XWiki.InplaceEditing</name>
    <number>0</number>
    <className>XWiki.StyleSheetExtension</className>
    <guid>bd0e5f70-8c74-48e4-97b9-81620b5d9394</guid>
    <class>
      <name>XWiki.StyleSheetExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <defaultValue>long</defaultValue>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <contentType>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>contentType</name>
        <number>6</number>
        <prettyName>Content Type</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>CSS|LESS</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </contentType>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage|onDemand|always</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>#document-title h1.editable {
  /* Move the title heading a bit to the top and to the left in order to accomodate the input border and padding. */
  margin-top: -@line-height-computed / 4;
  margin-left: -(ceil(@grid-gutter-width / 2));
  /* Reduce the bottom margin in order to accomodate the input border and bottom padding. */
  margin-bottom: @line-height-computed / 4;
}

@document-title-input-padding-vertical: @line-height-computed / 4 - 1;
input#document-title-input {
  /* Preserve the heading styles. */
  border: 1px solid transparent;
  box-shadow: none;
  color: inherit;
  font-size: inherit;
  /* It seems it's not enough to set the line height for the text input. We also need to set its height. */
  height: @font-size-document-title * @headings-line-height + 2 * (1 + @document-title-input-padding-vertical);
  line-height: @headings-line-height;
  padding: @document-title-input-padding-vertical (ceil(@grid-gutter-width / 2) - 1);
  width: 100%;
}

input#document-title-input:hover {
  border-color: @input-border;
}

input#document-title-input:focus,
#xwikicontent[contenteditable]:focus,
#xwikicontent[tabindex]:focus {
  .form-control-focus();
}

#xwikicontent[contenteditable],
#xwikicontent[tabindex] {
  border: 1px solid transparent;
  margin-top: -1px;
  margin-left: -1px;
}

#xwikicontent.loading {
  background: none;
  cursor: wait;
}

/* Leave more space at the top of the edited content by reducing the margin bottom of the preceding horizontal rule. */
.document-header + hr {
  margin-bottom: @line-height-computed / 4;
}
#xwikicontent {
  padding-top: @line-height-computed * 0.75;
}

.sticky-buttons-wrapper {
  /* Leave some space for the bottom box shadow of the editing area. */
  margin-top: 7px;
}</code>
    </property>
    <property>
      <contentType>LESS</contentType>
    </property>
    <property>
      <name/>
    </property>
    <property>
      <parse>0</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>XWiki.InplaceEditing</name>
    <number>0</number>
    <className>XWiki.UIExtensionClass</className>
    <guid>5c7fd93e-a308-4bd0-a53a-5e4d54b2640c</guid>
    <class>
      <name>XWiki.UIExtensionClass</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <async_cached>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_cached</name>
        <number>3</number>
        <prettyName>Cached</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_cached>
      <async_context>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>1</multiSelect>
        <name>async_context</name>
        <number>4</number>
        <prettyName>Context elements</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator>, </separator>
        <separators>|, </separators>
        <size>5</size>
        <unmodifiable>0</unmodifiable>
        <values>action=Action|doc.reference=Document|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.parameters=Request parameters|request.url=Request URL|request.wiki=Request wiki|user=User|wiki=Wiki</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </async_context>
      <async_enabled>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_enabled</name>
        <number>2</number>
        <prettyName>Asynchronous rendering</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_enabled>
      <content>
        <disabled>0</disabled>
        <editor>Text</editor>
        <name>content</name>
        <number>1</number>
        <prettyName>Executed Content</prettyName>
        <rows>25</rows>
        <size>120</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </content>
      <extensionPointId>
        <disabled>0</disabled>
        <name>extensionPointId</name>
        <number>5</number>
        <prettyName>Extension Point ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </extensionPointId>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>6</number>
        <prettyName>Extension ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parameters>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>parameters</name>
        <number>7</number>
        <prettyName>Extension Parameters</prettyName>
        <rows>10</rows>
        <size>40</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </parameters>
      <scope>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>scope</name>
        <number>8</number>
        <prettyName>Extension Scope</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>wiki=Current Wiki|user=Current User|global=Global</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </scope>
    </class>
    <property>
      <async_cached>0</async_cached>
    </property>
    <property>
      <async_context/>
    </property>
    <property>
      <async_enabled>0</async_enabled>
    </property>
    <property>
      <content>{{velocity output="false"}}
## TODO: Remove this when XWIKI-18511 (Add support for passing a query string when calling getSkinFile) is implemented.
#macro (getSkinFileWithParams $file $params)
#set ($url = $xwiki.getSkinFile($file, true))
$url#if ($url.contains('?'))&amp;#else?#end$escapetool.url($params)
#end
{{/velocity}}

{{velocity}}
{{html clean="false"}}
#if ($services.edit.document.inPlaceEditingEnabled() &amp;&amp; $hasEdit &amp;&amp; $xcontext.action == 'view' &amp;&amp; !$doc.isNew())
  ## We support in-place editing only for the WYSIWYG edit mode ATM.
  #getDefaultDocumentEditor($defaultEditMode)
  #if ($defaultEditMode == 'wysiwyg')
    #set ($l10nKeys = [
      'edit.inplace.page.renderFailed',
      'edit.inplace.page.lockFailed',
      'edit.inplace.close',
      'edit.inplace.page.loadFailed',
      'edit.inplace.actionButtons.loadFailed',
      'core.editors.content.titleField.label',
      ['edit.inplace.page.translate.messageBefore', $doc.realLocale.getDisplayName($xcontext.locale),
        $xcontext.locale.getDisplayName($xcontext.locale)],
      ['edit.inplace.page.translate.messageAfter', $xcontext.locale.getDisplayName($xcontext.locale)]
    ])
    #set ($l10n = {})
    #foreach ($key in $l10nKeys)
      #set ($params = $key.subList(1, $key.size()))
      #if ($params)
        #set ($discard = $l10n.put($key[0], $services.localization.render($key[0], $params)))
      #else
        #set ($discard = $l10n.put($key, $services.localization.render($key)))
      #end
    #end
    ## See stylesheets.vm
    #set ($cssParams = {
      'skin': $xwiki.skin,
      'colorTheme': $services.model.serialize($themeDoc.documentReference, 'default')
    })
    #set ($jsParams = {'language': $xcontext.locale})
    ## We have to explicitly enable the source mode for in-line edit because the latest version of the content editor
    ## could be installed on an older version of XWiki where the in-place editor didn't support the source mode (so the
    ## content editor cannot enable the source mode by default).
    #set ($inplaceEditingConfig = {
      'contentType': 'org.xwiki.rendering.syntax.SyntaxContent',
      'editMode': $defaultEditMode,
      'wysiwygEditor': $services.edit.syntaxContent.defaultWysiwygEditor.descriptor.id,
      'editButtonSelector': '#tmEdit &gt; a',
      'translateButtonSelector': '#tmTranslate &gt; a',
      'enableSourceMode': true,
      'enableOfficeImport': $services.officemanager.isConnected(),
      'paths': {
        'js': {
          'xwiki-actionButtons': "#getSkinFileWithParams('js/xwiki/actionbuttons/actionButtons.js' $jsParams)",
          'xwiki-autoSave': "#getSkinFileWithParams('js/xwiki/editors/autosave.js' $jsParams)",
          'xwiki-diff': $xwiki.getSkinFile('uicomponents/viewers/diff.js')
        },
        'css': [
          "#getSkinFileWithParams('js/xwiki/actionbuttons/actionButtons.css' $cssParams)",
          "#getSkinFileWithParams('js/xwiki/editors/autosave.css' $cssParams)",
          "#getSkinFileWithParams('uicomponents/viewers/diff.css' $cssParams)"
        ]
      },
      'l10n': $l10n
    })
    &lt;div class="hidden" data-inplace-editing-config="$escapetool.xml($jsontool.serialize($inplaceEditingConfig))"&gt;&lt;/div&gt;
    ## We didn't move this to the file system because it uses LESS and we didn't want to include it in the skin.
    #set ($discard = $xwiki.ssx.use('XWiki.InplaceEditing'))
    ## We can't move this to a WebJar until we have XWIKI-12788 (Introduce skin extension plugins for webjar resources).
    #set ($discard = $xwiki.jsx.use('XWiki.InplaceEditing'))
  #end
#end
{{/html}}
{{/velocity}}</content>
    </property>
    <property>
      <extensionPointId>org.xwiki.platform.template.header.after</extensionPointId>
    </property>
    <property>
      <name>org.xwiki.platform.template.header.after.inplaceEditing</name>
    </property>
    <property>
      <parameters/>
    </property>
    <property>
      <scope>wiki</scope>
    </property>
  </object>
</xwikidoc>
