{"version":3,"file":"index.umd.js","sources":["../src/markdown/internal/find-first-match-in.ts","../src/markdown/internal/remark-partial-gfm.ts","../src/markdown/internal-links/parser/parser-configuration-resolver.ts","../src/markdown/default-markdown-to-uni-ast-converter.ts","../src/markdown/internal-links/serializer/internal-links-serializer-resolver.ts","../src/markdown/default-uni-ast-to-markdown-converter.ts","../src/component-init.ts","../src/markdown/internal-links/serializer/xwiki-internal-link-serializer.ts","../src/markdown/internal-links/serializer/nextcloud-internal-link-serializer.ts","../src/markdown/internal-links/serializer/github-internal-link-serializer.ts","../src/markdown/internal-links/serializer/filesystem-internal-link-serializer.ts"],"sourcesContent":["/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\n\nexport type MatchResult<K extends string> = {\n  name: K;\n  match: string;\n  offset: number;\n};\n\nexport function findFirstMatchIn<K extends string>(\n  subject: string,\n  candidates: Array<{ name: K; match: string }>,\n): MatchResult<K> | null {\n  let first: MatchResult<K> | null = null;\n\n  for (const { name, match } of candidates) {\n    const offset = subject.indexOf(match);\n\n    if (offset !== -1 && (first === null || first.offset > offset)) {\n      first = { name, match, offset };\n    }\n  }\n\n  return first;\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { gfmStrikethroughFromMarkdown } from \"mdast-util-gfm-strikethrough\";\nimport { gfmTableFromMarkdown } from \"mdast-util-gfm-table\";\nimport { gfmTaskListItemFromMarkdown } from \"mdast-util-gfm-task-list-item\";\nimport { gfmStrikethrough } from \"micromark-extension-gfm-strikethrough\";\nimport { gfmTable } from \"micromark-extension-gfm-table\";\nimport { gfmTaskListItem } from \"micromark-extension-gfm-task-list-item\";\nimport type { Processor } from \"unified\";\n\n/**\n * Extension to *partially* support Github's Front Matter (Markdown) syntax flavor\n *\n * Does **NOT** include some of GFM features like autolinks or footnotes, which are implemented differently in another\n * part of the code\n */\nexport function remarkPartialGfm(this: Processor): void {\n  const data = this.data();\n\n  data.micromarkExtensions ??= [];\n  data.fromMarkdownExtensions ??= [];\n\n  data.micromarkExtensions.push(\n    gfmStrikethrough(),\n    gfmTable(),\n    gfmTaskListItem(),\n  );\n\n  data.fromMarkdownExtensions.push(\n    gfmStrikethroughFromMarkdown(),\n    gfmTableFromMarkdown(),\n    gfmTaskListItemFromMarkdown(),\n  );\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { inject, injectable } from \"inversify\";\nimport type { MarkdownParserConfiguration } from \"./markdown-parser-configuration\";\nimport type { CristalApp } from \"@xwiki/platform-api\";\n\n/**\n * @since 0.22\n */\n@injectable()\nexport class ParserConfigurationResolver {\n  constructor(@inject(\"CristalApp\") private readonly cristalApp: CristalApp) {}\n  get(): MarkdownParserConfiguration {\n    const type = this.cristalApp.getWikiConfig().getType();\n    try {\n      const factory: () => MarkdownParserConfiguration = this.cristalApp\n        .getContainer()\n        .get(\"Factory<MarkdownParserConfiguration>\", { name: type });\n      return factory();\n    } catch {\n      // Return the default value if no specific factory is found.\n      return {\n        supportFlexmarkInternalLinks: false,\n      };\n    }\n  }\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { findFirstMatchIn } from \"./internal/find-first-match-in\";\nimport { remarkPartialGfm } from \"./internal/remark-partial-gfm\";\nimport { ParserConfigurationResolver } from \"./internal-links/parser/parser-configuration-resolver\";\nimport { assertInArray, assertUnreachable } from \"@xwiki/platform-fn-utils\";\nimport { EntityType } from \"@xwiki/platform-model-api\";\nimport { inject, injectable } from \"inversify\";\nimport remarkParse from \"remark-parse\";\nimport { unified } from \"unified\";\nimport type { MatchResult } from \"./internal/find-first-match-in\";\nimport type { MarkdownToUniAstConverter } from \"./markdown-to-uni-ast-converter\";\nimport type { EntityReference } from \"@xwiki/platform-model-api\";\nimport type {\n  ModelReferenceHandlerProvider,\n  ModelReferenceParserProvider,\n} from \"@xwiki/platform-model-reference-api\";\nimport type {\n  Block,\n  Image,\n  InlineContent,\n  LinkTarget,\n  TableCell,\n  TableColumn,\n  TextStyles,\n  UniAst,\n} from \"@xwiki/platform-uniast-api\";\nimport type { Image as MdImage, PhrasingContent, RootContent } from \"mdast\";\n\n/**\n * @since 0.22\n */\n@injectable()\nexport class DefaultMarkdownToUniAstConverter\n  implements MarkdownToUniAstConverter\n{\n  constructor(\n    @inject(\"ModelReferenceParserProvider\")\n    private readonly modelReferenceParserProvider: ModelReferenceParserProvider,\n    @inject(\"ModelReferenceHandlerProvider\")\n    private readonly modelReferenceHandlerProvider: ModelReferenceHandlerProvider,\n    @inject(\"ParserConfigurationResolver\")\n    private readonly parserConfigurationResolver: ParserConfigurationResolver,\n  ) {}\n\n  async parseMarkdown(markdown: string): Promise<UniAst | Error> {\n    // TODO: auto-links (URLs + emails)\n    //     > https://jira.xwiki.org/browse/CRISTAL-513\n\n    const ast = unified()\n      .use(remarkParse)\n      .use(remarkPartialGfm)\n      .parse(markdown);\n\n    try {\n      const blocks = await Promise.all(\n        ast.children.map((item) => this.convertBlock(item)),\n      );\n      return { blocks };\n    } catch (e) {\n      return e instanceof Error ? e : new Error(String(e));\n    }\n  }\n\n  private async convertBlock(block: RootContent): Promise<Block> {\n    switch (block.type) {\n      case \"paragraph\": {\n        const content = await this.collectInlineContent(block.children, {});\n\n        // Paragraphs only made of a single inline macro are actually block macros\n        if (content.length === 1 && content[0].type === \"inlineMacro\") {\n          return {\n            type: \"macroBlock\",\n            name: content[0].name,\n            params: content[0].params,\n          };\n        }\n\n        return {\n          type: \"paragraph\",\n          content,\n          styles: {},\n        };\n      }\n\n      case \"heading\":\n        return {\n          type: \"heading\",\n          level: assertInArray(\n            block.depth,\n            [1, 2, 3, 4, 5, 6] as const,\n            \"Invalid heading depth in markdown parser\",\n          ),\n          content: await this.collectInlineContent(block.children, {}),\n          styles: {},\n        };\n\n      case \"blockquote\":\n        return {\n          type: \"quote\",\n          content: await Promise.all(\n            block.children.map((item) => this.convertBlock(item)),\n          ),\n          styles: {},\n        };\n\n      case \"list\":\n        // TODO: \"token.loose\" property\n        return {\n          type: \"list\",\n          items: await Promise.all(\n            block.children.map(async (item, i) => ({\n              number: block.ordered ? (block.start ?? 1) + i : undefined,\n              checked: item.checked ?? undefined,\n              content: await Promise.all(\n                item.children.map((item) => this.convertBlock(item)),\n              ),\n              styles: {},\n            })),\n          ),\n          styles: {},\n        };\n      case \"code\":\n        // TODO: \"token.escaped\" property\n        // TODO: \"token.codeBlockStyle\" property\n        return {\n          type: \"code\",\n          content: block.value,\n          language: block.lang ?? undefined,\n        };\n\n      case \"table\": {\n        const [headers, ...rows] = block.children;\n        const columns = await Promise.all(\n          headers?.children.map(\n            async (cell): Promise<TableColumn> => ({\n              headerCell: {\n                content: await this.collectInlineContent(cell.children, {}),\n                styles: {},\n              },\n            }),\n          ),\n        );\n        const tableRows = await Promise.all(\n          rows.map(async (row) => {\n            const map = row.children.map(\n              async (cell): Promise<TableCell> => ({\n                content: await this.collectInlineContent(cell.children, {}),\n                styles: {},\n              }),\n            );\n            return await Promise.all(map);\n          }),\n        );\n        return {\n          type: \"table\",\n          columns: columns,\n          rows: tableRows,\n          styles: {},\n        };\n      }\n\n      case \"image\":\n        return {\n          type: \"image\",\n          ...(await this.convertImage(block)),\n        };\n\n      case \"break\":\n      case \"thematicBreak\":\n        return { type: \"break\" };\n\n      case \"imageReference\":\n      case \"linkReference\":\n      case \"definition\":\n      case \"footnoteDefinition\":\n      case \"footnoteReference\":\n      case \"html\":\n        throw new Error(\"TODO: handle blocks of type \" + block.type);\n\n      // NOTE: These are handled in the `convertInline` function below\n      case \"text\":\n      case \"delete\":\n      case \"strong\":\n      case \"emphasis\":\n      case \"inlineCode\":\n      case \"link\":\n      case \"tableCell\":\n      case \"tableRow\":\n      case \"yaml\":\n      case \"listItem\":\n        throw new Error(\n          \"Unexpected block type in markdown parser: \" + block.type,\n        );\n\n      default:\n        assertUnreachable(block);\n    }\n  }\n\n  private async convertInline(\n    inline: PhrasingContent,\n    styles: TextStyles,\n  ): Promise<InlineContent[]> {\n    switch (inline.type) {\n      case \"image\":\n        return [\n          {\n            type: \"image\",\n            ...(await this.convertImage(inline)),\n          },\n        ];\n\n      case \"strong\":\n        return this.collectInlineContent(inline.children, {\n          ...styles,\n          bold: true,\n        });\n\n      case \"emphasis\":\n        return this.collectInlineContent(inline.children, {\n          ...styles,\n          italic: true,\n        });\n\n      case \"delete\":\n        return this.collectInlineContent(inline.children, {\n          ...styles,\n          strikethrough: true,\n        });\n\n      case \"inlineCode\":\n        return [\n          {\n            type: \"text\",\n            content: inline.value,\n            styles: {},\n          },\n        ];\n\n      case \"text\":\n        return this.convertText(inline.value, styles);\n\n      case \"html\":\n      case \"footnoteReference\":\n      case \"linkReference\":\n      case \"imageReference\":\n      case \"break\":\n        throw new Error(\"TODO: handle inlines of type \" + inline.type);\n\n      case \"link\": {\n        return await this.convertLink(inline, styles);\n      }\n\n      default:\n        assertUnreachable(inline);\n    }\n  }\n\n  private async convertLink(\n    inline: PhrasingContent & { type: \"link\" },\n    styles: TextStyles,\n  ): Promise<InlineContent[]> {\n    // TODO: change here for Github and nextcloud + resolve the entity reference in case the link can be resolved as\n    //  internal.\n    // For Nextcloud, resolve based on the note on AnyType (from docid to url)\n    // TODO: the same must be done for attachments!\n    let target: LinkTarget;\n    if (!this.supportFlexmark()) {\n      // If flexmark is not supported, we need to parse the url to find out if it's pointing to an internal entity.\n      try {\n        const parsed = await this.modelReferenceParserProvider\n          .get()!\n          .parseAsync(inline.url);\n        target = {\n          type: \"internal\",\n          parsedReference: parsed,\n          rawReference: inline.url,\n        };\n      } catch (e) {\n        console.debug(\"Error parsing reference: \", e);\n        target = { type: \"external\", url: inline.url };\n      }\n    } else {\n      target = { type: \"external\", url: inline.url };\n    }\n    const label = await this.collectInlineContent(inline.children, styles);\n    return [\n      {\n        type: \"link\",\n        content: label.map((token) => {\n          if (token.type !== \"text\") {\n            throw new Error(\"Unexpected link inside link in markdown parser\");\n          }\n          return token;\n        }),\n        target,\n      },\n    ];\n  }\n\n  private async convertImage(image: MdImage): Promise<Image> {\n    // TODO: \"token.text\" property\n    let target: LinkTarget;\n    const url = image.url;\n    try {\n      const parsed = await this.modelReferenceParserProvider\n        .get()!\n        .parseAsync(url, { type: EntityType.ATTACHMENT });\n      target = {\n        type: \"internal\",\n        parsedReference: parsed,\n        rawReference: url,\n      };\n    } catch {\n      target = { type: \"external\", url: url };\n    }\n\n    return {\n      target,\n      caption: undefined,\n      alt: image.alt ?? undefined,\n      styles: {},\n    };\n  }\n\n  // eslint-disable-next-line max-statements\n  private convertText(text: string, styles: TextStyles): InlineContent[] {\n    const out: InlineContent[] = [];\n\n    let treated = 0;\n\n    while (true) {\n      // Try to find the first XWiki-specific-element syntax in the text (precedence order)\n      // Do not use the expressions for internal images and links when not supported.\n      const internalLinksOrImage: Array<{\n        name: \"image\" | \"link\";\n        match: string;\n      }> = this.supportFlexmark()\n        ? [\n            { name: \"image\", match: \"![[\" },\n            { name: \"link\", match: \"[[\" },\n          ]\n        : [];\n      const candidates: Array<{\n        name: \"image\" | \"link\" | \"macro\";\n        match: string;\n      }> = [...internalLinksOrImage, { name: \"macro\", match: \"{{\" }];\n      const firstItem: MatchResult<\"image\" | \"link\" | \"macro\"> | null =\n        findFirstMatchIn(text.substring(treated), candidates);\n\n      // If none is found, exit immediately\n      // This also means texts that don't contain any specific syntax will have a very low conversion cost\n      if (!firstItem) {\n        break;\n      }\n\n      const match = treated + firstItem.offset;\n\n      // Ensure the current element is not being escaped with backslashes\n      const precedingBackslashes = text.substring(0, match).match(/\\\\+/);\n\n      // Backslashes are counted as pairs, as two consecutive backslashes are not escaping the next character\n      if (precedingBackslashes && precedingBackslashes[0].length % 2 !== 0) {\n        continue;\n      }\n\n      // Push the text between the last match and the current one as plain text\n      if (text.substring(treated, match).length > 0) {\n        out.push({\n          type: \"text\",\n          content: text.substring(treated, match),\n          styles,\n        });\n      }\n\n      switch (firstItem.name) {\n        case \"image\":\n        case \"link\": {\n          treated = this.handleLinkOrImage(\n            firstItem,\n            match,\n            text,\n            treated,\n            styles,\n            out,\n          );\n          break;\n        }\n\n        case \"macro\": {\n          treated = this.handleMacro(firstItem, match, text, treated, out);\n\n          break;\n        }\n\n        default:\n          assertUnreachable(firstItem.name);\n      }\n    }\n\n    // Push the leftover text after the last XWiki-specific element as plain text\n    if (text.substring(treated).length > 0) {\n      out.push({\n        type: \"text\",\n        content: text.substring(treated),\n        styles,\n      });\n    }\n\n    return out;\n  }\n\n  // eslint-disable-next-line max-statements\n  private handleLinkOrImage(\n    firstItem: { name: string; match: string },\n    match: number,\n    text: string,\n    treated: number,\n    styles: TextStyles,\n    out: InlineContent[],\n  ): number {\n    const isImage = firstItem.name === \"image\";\n\n    let i;\n\n    // Is the next character being escaped?\n    let escaping = false;\n    // Is the link or image being closed?\n    let closing = false;\n    // Has the link or image been closed properly?\n    let closed = false;\n\n    for (i = match + firstItem.match.length; i < text.length; i++) {\n      if (escaping) {\n        escaping = false;\n\n        continue;\n      }\n\n      const char = text.charAt(i);\n\n      if (char === \"\\\\\") {\n        escaping = true;\n        continue;\n      }\n\n      if (char === \"]\") {\n        if (closing) {\n          closed = true;\n          break;\n        }\n\n        closing = true;\n      }\n    }\n\n    if (!closed) {\n      return treated;\n    }\n\n    treated = i + 1;\n\n    const substr = text.substring(match + firstItem.match.length, i - 1);\n\n    let title: string | null;\n    let targetStr: string;\n\n    const pipeCharPos = substr.indexOf(\"|\");\n\n    if (pipeCharPos !== -1) {\n      title = substr.substring(0, pipeCharPos);\n      targetStr = substr.substring(pipeCharPos + 1);\n    } else {\n      title = null;\n      targetStr = substr;\n    }\n\n    let reference: EntityReference | null;\n    try {\n      reference = this.modelReferenceParserProvider.get()!.parse(targetStr, {\n        type: isImage ? EntityType.ATTACHMENT : EntityType.DOCUMENT,\n      });\n    } catch {\n      reference = null;\n    }\n\n    const target: LinkTarget = {\n      type: \"internal\",\n      rawReference: targetStr,\n      parsedReference: reference,\n    };\n\n    title ??= reference\n      ? this.modelReferenceHandlerProvider.get()!.getTitle(reference)\n      : \"<invalid reference>\";\n\n    const items: InlineContent = isImage\n      ? {\n          type: \"image\",\n          target,\n          styles: { alignment: \"left\" },\n          alt: title,\n        }\n      : {\n          type: \"link\",\n          target,\n          content: [{ type: \"text\", content: title, styles }],\n        };\n    out.push(items);\n    return treated;\n  }\n\n  // eslint-disable-next-line max-statements\n  private handleMacro(\n    firstItem: { name: string; match: string },\n    match: number,\n    text: string,\n    treated: number,\n    out: InlineContent[],\n  ): number {\n    // Find the macro's name\n    const macroNameMatch = text.substring(match + firstItem.match.length).match(\n      // This weird group matches valid accentuated Unicode letters\n      /\\s*([A-Za-zÀ-ÖØ-öø-ÿ\\d]+)(\\s+(?=[A-Za-zÀ-ÖØ-öø-ÿ\\d/])|(?=\\/))/,\n    );\n\n    if (!macroNameMatch) {\n      treated = match + firstItem.match.length;\n      out.push({ type: \"text\", content: firstItem.match, styles: {} });\n      return treated;\n    }\n\n    const macroName = macroNameMatch[1];\n\n    let i;\n\n    // Is the next character being escaped?\n    let escaping = false;\n\n    // Parameters are built character by character\n    // First the name is parsed from the source, then the value\n    let buildingParameter: { name: string; value: string | null } | null = null;\n\n    // The list of parsed parameters\n    const parameters: Record<string, string> = {};\n\n    // Is the macro being closed?\n    let closingMacro = false;\n\n    for (\n      i = match + firstItem.match.length + macroNameMatch[0].length;\n      i < text.length;\n      i++\n    ) {\n      // Escaping is possible only inside parameter values\n      if (escaping) {\n        if (!buildingParameter || buildingParameter.value === null) {\n          throw new Error(\"Unexpected\");\n        }\n\n        escaping = false;\n        buildingParameter.value += text[i];\n\n        continue;\n      }\n\n      // If we're not building a parameter, we are expecting one thing between...\n      if (!buildingParameter) {\n        // ...a space (no particular meaning)\n        if (text[i] === \" \") {\n          continue;\n        }\n\n        // ...a valid identifier character which will begin the parameter's name\n        if (text[i].match(/[A-Za-zÀ-ÖØ-öø-ÿ_\\d]/)) {\n          buildingParameter = { name: text[i], value: null };\n          continue;\n        }\n\n        // ...or a closing slash which indicates the macro has no more parameter\n        if (text[i] === \"/\") {\n          closingMacro = true;\n          break;\n        }\n\n        // Invalid character, stop building macro here\n        break;\n      }\n\n      // If we're building a parameter's name, we are expecting one thing between...\n      if (buildingParameter.value === null) {\n        // ...a valid identifier character which will continue the parameter's name\n        if (text[i].match(/[A-Za-zÀ-ÖØ-öø-ÿ_\\d]/)) {\n          buildingParameter.name += text[i];\n          continue;\n        }\n\n        // ...or an '=' operator sign which indicates we are going to assign a value to the parameter\n        if (text[i] === \"=\") {\n          // Usually parameters start with a double quote to indicate they have a string-like value\n          if (text[i + 1] === '\"') {\n            i += 1;\n            buildingParameter.value = \"\";\n            continue;\n          }\n\n          // But unquoted integers are also accepted\n          const number = text\n            .substring(i + 1)\n            .match(/\\d+(?=[^A-Za-zÀ-ÖØ-öø-ÿ\\d])/);\n\n          if (!number) {\n            // Invalid character, stop building macro here\n            break;\n          }\n\n          parameters[buildingParameter.name] = number[0];\n          buildingParameter = null;\n\n          i += number[0].length;\n          continue;\n        }\n\n        // Invalid character, stop building macro here\n        break;\n      }\n\n      // If we reach this point, we are building the parameter's value.\n      // Which means we are expecting either:\n      // ...an escaping character\n      if (text[i] === \"\\\\\") {\n        escaping = true;\n      }\n      // ...a closing double quote to indicate the parameter's value's end\n      else if (text[i] === '\"') {\n        parameters[buildingParameter.name] = buildingParameter.value;\n        buildingParameter = null;\n      }\n      // ...or any other character that will continue the parameter's value\n      else {\n        buildingParameter.value += text[i];\n      }\n    }\n\n    // When the macro closes, we expect double braces afterwards\n    const closingBraces = text.substring(i).match(/\\s*}}/);\n\n    // If the macro has not been closed properly (with a '/') or doesn't have the closing braces, it's invalid\n    if (!closingMacro || !closingBraces) {\n      treated = match + firstItem.match.length;\n      out.push({ type: \"text\", content: firstItem.match, styles: {} });\n    }\n    // Otherwise, we can properly build the macro\n    else {\n      treated = i + 1 + closingBraces[0].length;\n\n      // NOTE: If a paragraph only contains an inline macro, it will be converted to a macro block instead\n      //       by the calling function\n      out.push({\n        type: \"inlineMacro\",\n        name: macroName,\n        params: parameters,\n      });\n    }\n    return treated;\n  }\n\n  private supportFlexmark(): boolean {\n    return this.parserConfigurationResolver.get().supportFlexmarkInternalLinks;\n  }\n\n  private async collectInlineContent(\n    children: PhrasingContent[],\n    styles: TextStyles = {},\n  ): Promise<InlineContent[]> {\n    return (\n      await Promise.all(\n        children.map((item) => this.convertInline(item, styles)),\n      )\n    ).flat();\n  }\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { inject, injectable } from \"inversify\";\nimport type { InternalLinksSerializer } from \"./internal-links-serializer\";\nimport type { CristalApp } from \"@xwiki/platform-api\";\n\n/**\n * @since 0.22\n */\n@injectable()\nexport class InternalLinksSerializerResolver {\n  constructor(@inject(\"CristalApp\") private readonly cristalApp: CristalApp) {}\n\n  async get(): Promise<InternalLinksSerializer> {\n    const type = this.cristalApp.getWikiConfig().getType();\n    try {\n      const factory: () => Promise<InternalLinksSerializer> =\n        await this.cristalApp\n          .getContainer()\n          .getAsync(\"Factory<InternalLinksSerializer>\", { name: type });\n      return factory();\n    } catch (e) {\n      console.debug(e);\n      throw new Error(`Could not resolve serializer for type ${type}`);\n    }\n  }\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { InternalLinksSerializerResolver } from \"./internal-links/serializer/internal-links-serializer-resolver\";\nimport { tryFallibleOrError } from \"@xwiki/platform-fn-utils\";\nimport { inject, injectable } from \"inversify\";\nimport type { UniAstToMarkdownConverter } from \"./uni-ast-to-markdown-converter\";\nimport type {\n  Block,\n  Image,\n  InlineContent,\n  Link,\n  ListItem,\n  TableCell,\n  Text,\n  UniAst,\n} from \"@xwiki/platform-uniast-api\";\n\n/**\n * @since 0.22\n */\n@injectable()\nexport class DefaultUniAstToMarkdownConverter\n  implements UniAstToMarkdownConverter\n{\n  constructor(\n    @inject(\"InternalLinksSerializerResolver\")\n    private readonly internalLinksSerializerResolver: InternalLinksSerializerResolver,\n  ) {}\n\n  /**\n   * Converts the provided AST to Markdown.\n   *\n   * @param uniAst - the AST to convert to markdown\n   *\n   * understand the impacts\n   */\n  async toMarkdown(uniAst: UniAst): Promise<string | Error> {\n    const { blocks } = uniAst;\n\n    const out: Promise<string>[] = [];\n\n    for (const element of blocks) {\n      // TODO: fix this (can't error as it's a promise)\n      const md = tryFallibleOrError(() => this.blockToMarkdown(element));\n\n      if (md instanceof Error) {\n        return md;\n      }\n\n      out.push(md);\n    }\n\n    // TODO: try fallible here as this could throw\n    return (await Promise.all(out)).join(\"\\n\\n\");\n  }\n\n  private async blockToMarkdown(block: Block): Promise<string> {\n    switch (block.type) {\n      case \"paragraph\":\n        return this.convertInlineContents(block.content);\n\n      case \"heading\":\n        return `${\"#\".repeat(block.level)} ${await this.convertInlineContents(block.content)}`;\n\n      case \"list\": {\n        return (\n          await Promise.all(\n            block.items.map((item) => this.convertListItem(item)),\n          )\n        ).join(\"\\n\");\n      }\n\n      case \"quote\": {\n        const values = block.content\n          .map((item) => this.blockToMarkdown(item))\n          .flatMap(async (item) => (await item).split(\"\\n\"))\n          .flatMap(async (line) => {\n            const strings = await line;\n            return strings.map((s) => `> ${s}`).join(\"\\n\");\n          });\n        return (await Promise.all(values)).join(\"\\n\");\n      }\n\n      case \"code\":\n        return `\\`\\`\\`${block.language ?? \"\"}\\n${block.content}\\n\\`\\`\\``;\n\n      case \"table\":\n        return this.convertTable(block);\n\n      case \"image\":\n        return this.convertImage(block);\n\n      case \"break\":\n        return \"---\";\n\n      case \"macroBlock\":\n        return this.convertMacro(block.name, block.params);\n    }\n  }\n\n  private async convertListItem(listItem: ListItem): Promise<string> {\n    let prefix = listItem.number !== undefined ? `${listItem.number}. ` : \"* \";\n\n    if (listItem.checked !== undefined) {\n      prefix += `[${listItem.checked ? \"x\" : \" \"}] `;\n    }\n\n    const contents: string[] = [];\n    for (const item of listItem.content) {\n      const md = await this.blockToMarkdown(item);\n      const lines = md.split(\"\\n\");\n      contents.push(\n        lines\n          .map((line, i) => (i > 0 ? \" \".repeat(prefix.length) : \"\") + line)\n          .join(\"\\n\"),\n      );\n    }\n    return `${prefix}${contents.join(\"\\n\")}`;\n  }\n\n  private async convertImage(image: Image): Promise<string> {\n    // TODO: alt text\n    return image.target.type === \"external\"\n      ? `![${image.alt ?? \"\"}](${image.target.url})`\n      : await (\n          await this.internalLinksSerializerResolver.get()\n        ).serializeImage(image.target, image.alt);\n  }\n\n  private async convertTable(\n    table: Extract<Block, { type: \"table\" }>,\n  ): Promise<string> {\n    const { columns, rows } = table;\n\n    const out = [\n      (\n        await Promise.all(\n          columns.map((column) =>\n            column.headerCell ? this.convertTableCell(column.headerCell) : \"\",\n          ),\n        )\n      ).join(\" | \"),\n      columns.map(() => \" - \").join(\" | \"),\n    ];\n\n    for (const cell of rows) {\n      out.push(\n        (\n          await Promise.all(cell.map((item) => this.convertTableCell(item)))\n        ).join(\" | \"),\n      );\n    }\n\n    return out.map((line) => `| ${line} |`).join(\"\\n\");\n  }\n\n  private convertTableCell(cell: TableCell): Promise<string> {\n    return this.convertInlineContents(cell.content);\n  }\n\n  async convertInlineContents(\n    inlineContents: InlineContent[],\n  ): Promise<string> {\n    return (\n      await Promise.all(\n        inlineContents.map((item) => this.convertInlineContent(item)),\n      )\n    ).join(\"\");\n  }\n\n  async convertInlineContent(inlineContent: InlineContent): Promise<string> {\n    switch (inlineContent.type) {\n      case \"text\":\n        return this.convertText(inlineContent);\n      case \"image\":\n        return this.convertImage(inlineContent);\n      case \"link\":\n        return this.convertLink(inlineContent);\n      case \"inlineMacro\":\n        return this.convertMacro(inlineContent.name, inlineContent.params);\n    }\n  }\n\n  private async convertLink(inlineContent: Link): Promise<string> {\n    switch (inlineContent.target.type) {\n      case \"external\":\n        return `[${await this.convertInlineContents(inlineContent.content)}](${inlineContent.target.url})`;\n\n      case \"internal\": {\n        const linksSerializer =\n          await this.internalLinksSerializerResolver.get();\n        return linksSerializer.serialize(\n          inlineContent.content,\n          inlineContent.target,\n          this,\n        );\n      }\n    }\n  }\n\n  private convertMacro(\n    name: string,\n    parameters: Record<string, boolean | number | string>,\n  ): string {\n    return `{{${name}${Object.entries(parameters)\n      .map(\n        ([name, value]) =>\n          ` ${name}=\"${value.toString().replace(/\\\\/g, \"\\\\\\\\\\\\\").replace(/\"/g, '\\\\\\\\\"')}\"`,\n      )\n      .join(\"\")} /}}`;\n  }\n\n  // eslint-disable-next-line max-statements\n  private convertText(text: Text): string {\n    const { content, styles } = text;\n\n    const { bold, italic, strikethrough, code } = styles;\n\n    const surroundings = [];\n\n    // Code must be first as it's going to be the most outer surrounding\n    // Otherwise other surroundings would be \"trapped\" inside the inline code content\n    if (code) {\n      surroundings.push(\"`\");\n    }\n\n    if (strikethrough) {\n      surroundings.push(\"~~\");\n    }\n\n    if (italic) {\n      surroundings.push(\"_\");\n    }\n\n    if (bold) {\n      surroundings.push(\"**\");\n    }\n\n    return `${surroundings.join(\"\")}${content}${surroundings.reverse().join(\"\")}`;\n  }\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { DefaultMarkdownToUniAstConverter } from \"./markdown/default-markdown-to-uni-ast-converter\";\nimport { DefaultUniAstToMarkdownConverter } from \"./markdown/default-uni-ast-to-markdown-converter\";\nimport { ParserConfigurationResolver } from \"./markdown/internal-links/parser/parser-configuration-resolver\";\nimport { InternalLinksSerializerResolver } from \"./markdown/internal-links/serializer/internal-links-serializer-resolver\";\nimport type { MarkdownParserConfiguration } from \"./markdown/internal-links/parser/markdown-parser-configuration\";\nimport type { InternalLinksSerializer } from \"./markdown/internal-links/serializer/internal-links-serializer\";\nimport type { MarkdownToUniAstConverter } from \"./markdown/markdown-to-uni-ast-converter\";\nimport type { UniAstToMarkdownConverter } from \"./markdown/uni-ast-to-markdown-converter\";\nimport type { Container, Factory, Newable, ResolutionContext } from \"inversify\";\n\n/**\n * @since 0.22\n * @beta\n */\nconst markdownToUniAstConverterName = \"MarkdownToUniAstConverter\";\n\n/**\n * @since 0.22\n * @beta\n */\nconst uniAstToMarkdownConverterName = \"UniAstToMarkdownConverter\";\n\n/**\n * @since 0.22\n * @beta\n */\nclass ComponentInit {\n  constructor(container: Container) {\n    container\n      .bind<MarkdownToUniAstConverter>(markdownToUniAstConverterName)\n      .to(DefaultMarkdownToUniAstConverter)\n      .whenDefault();\n\n    container\n      .bind<UniAstToMarkdownConverter>(uniAstToMarkdownConverterName)\n      .to(DefaultUniAstToMarkdownConverter)\n      .whenDefault();\n\n    // New components loading pattern attempt (as of Cristal 0.22).\n    // A resolver is declared. Its job is to resolve the right factory based\n    // on the current configuration type.\n    // Then, the factory is loaded asynchronously with a dynamic import so that\n    // only the code corresponding to the current configuration is loaded.\n    container\n      .bind<InternalLinksSerializerResolver>(\"InternalLinksSerializerResolver\")\n      .to(InternalLinksSerializerResolver);\n    // Factories for the officially supported backends are registered statically\n    // But nothing prevents factories for other backends to be registered at\n    // initialization time.\n    // The main side effect of regisering those factories is a few kb of\n    // initialization code being bundled for nothing (i.e., for the backends\n    // that are not going to be used).\n    this.initXWikiFactory(container);\n    this.initNextcloudFactory(container);\n    this.initGitHubFactory(container);\n    this.initFileSystemFactory(container);\n\n    container\n      .bind<ParserConfigurationResolver>(\"ParserConfigurationResolver\")\n      .to(ParserConfigurationResolver)\n      .whenDefault();\n\n    // Overrides the configuration for the XWiki backend\n    container\n      .bind<Factory<MarkdownParserConfiguration>>(\n        \"Factory<MarkdownParserConfiguration>\",\n      )\n      .toFactory(() => {\n        return () => {\n          return {\n            supportFlexmarkInternalLinks: true,\n          };\n        };\n      })\n      .whenNamed(\"XWiki\");\n  }\n\n  private initXWikiFactory(container: Container) {\n    const name = \"XWiki\";\n    container\n      .bind<Factory<Promise<InternalLinksSerializer>>>(\n        \"Factory<InternalLinksSerializer>\",\n      )\n      .toFactory((context) => {\n        return async () => {\n          const component = (\n            await import(\n              \"./markdown/internal-links/serializer/xwiki-internal-link-serializer\"\n            )\n          ).XWikiInternalLinkSerializer;\n          return this.bindAndLoad(container, name, component, context);\n        };\n      })\n      .whenNamed(name);\n  }\n  private initNextcloudFactory(container: Container) {\n    const name = \"Nextcloud\";\n    container\n      .bind<Factory<Promise<InternalLinksSerializer>>>(\n        \"Factory<InternalLinksSerializer>\",\n      )\n      .toFactory((context) => {\n        return async () => {\n          const component = (\n            await import(\n              \"./markdown/internal-links/serializer/nextcloud-internal-link-serializer\"\n            )\n          ).NextcloudInternalLinkSerializer;\n          return this.bindAndLoad(container, name, component, context);\n        };\n      })\n      .whenNamed(name);\n  }\n  private initGitHubFactory(container: Container) {\n    const name = \"GitHub\";\n    container\n      .bind<Factory<Promise<InternalLinksSerializer>>>(\n        \"Factory<InternalLinksSerializer>\",\n      )\n      .toFactory((context) => {\n        return async () => {\n          const component = (\n            await import(\n              \"./markdown/internal-links/serializer/github-internal-link-serializer\"\n            )\n          ).GitHubInternalLinkSerializer;\n          return this.bindAndLoad(container, name, component, context);\n        };\n      })\n      .whenNamed(name);\n  }\n  private initFileSystemFactory(container: Container) {\n    const name = \"FileSystem\";\n    container\n      .bind<Factory<Promise<InternalLinksSerializer>>>(\n        \"Factory<InternalLinksSerializer>\",\n      )\n      .toFactory((context) => {\n        return async () => {\n          const component = (\n            await import(\n              \"./markdown/internal-links/serializer/filesystem-internal-link-serializer\"\n            )\n          ).FilesystemInternalLinkSerializer;\n          return this.bindAndLoad(container, name, component, context);\n        };\n      })\n      .whenNamed(name);\n  }\n\n  /**\n   * Registed the component in the container on demand.\n   *\n   * @param container - the container\n   * @param name - the name of the component interface\n   * @param component - the actual component to register\n   * @param context - the context\n   */\n  private bindAndLoad<T extends InternalLinksSerializer>(\n    container: Container,\n    name: string,\n    component: Newable<T>,\n    context: ResolutionContext,\n  ) {\n    if (!container.isBound(\"InternalLinksSerializer\", { name: name })) {\n      container\n        .bind<InternalLinksSerializer>(\"InternalLinksSerializer\")\n        .to(component)\n        .whenNamed(name);\n    }\n    return context.get<InternalLinksSerializer>(\"InternalLinksSerializer\", {\n      name: name,\n    });\n  }\n}\n\nexport {\n  ComponentInit,\n  markdownToUniAstConverterName,\n  uniAstToMarkdownConverterName,\n};\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { injectable } from \"inversify\";\nimport type { InternalLinksSerializer } from \"./internal-links-serializer\";\nimport type { UniAstToMarkdownConverter } from \"../../uni-ast-to-markdown-converter\";\nimport type { Link, LinkTarget } from \"@xwiki/platform-uniast-api\";\n\n/**\n * @since 0.22\n */\n@injectable()\nexport class XWikiInternalLinkSerializer implements InternalLinksSerializer {\n  async serialize(\n    content: Link[\"content\"],\n    target: Extract<LinkTarget, { type: \"internal\" }>,\n    uniAstToMarkdownConverter: UniAstToMarkdownConverter,\n  ): Promise<string> {\n    return `[[${await uniAstToMarkdownConverter.convertInlineContents(\n      content,\n    )}|${target.rawReference}]]`;\n  }\n\n  async serializeImage(\n    target: Extract<LinkTarget, { type: \"internal\" }>,\n    alt?: string,\n  ): Promise<string> {\n    return `![[${alt ?? \"\"}${alt ? \"|\" : \"\"}${target.rawReference}]]`;\n  }\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { EntityType } from \"@xwiki/platform-model-api\";\nimport { XMLParser } from \"fast-xml-parser\";\nimport { inject, injectable } from \"inversify\";\nimport type { InternalLinksSerializer } from \"./internal-links-serializer\";\nimport type { UniAstToMarkdownConverter } from \"../../uni-ast-to-markdown-converter\";\nimport type { CristalApp } from \"@xwiki/platform-api\";\nimport type { DocumentService } from \"@xwiki/platform-document-api\";\nimport type { RemoteURLSerializerProvider } from \"@xwiki/platform-model-remote-url-api\";\nimport type { Link, LinkTarget } from \"@xwiki/platform-uniast-api\";\n\n/**\n * @since 0.22\n */\n@injectable()\nexport class NextcloudInternalLinkSerializer\n  implements InternalLinksSerializer\n{\n  constructor(\n    @inject(\"RemoteURLSerializerProvider\")\n    private readonly remoteURLSerializerProvider: RemoteURLSerializerProvider,\n    @inject(\"CristalApp\") private readonly cristalApp: CristalApp,\n    @inject(\"DocumentService\")\n    private readonly documentService: DocumentService,\n  ) {}\n\n  async serialize(\n    content: Link[\"content\"],\n    target: Extract<LinkTarget, { type: \"internal\" }>,\n    uniAstToMarkdownConverter: UniAstToMarkdownConverter,\n  ): Promise<string> {\n    const label =\n      await uniAstToMarkdownConverter.convertInlineContents(content);\n    const urlFromReference = this.remoteURLSerializerProvider\n      .get()!\n      .serialize(target.parsedReference ?? undefined)!;\n    const response = await fetch(urlFromReference, {\n      method: \"PROPFIND\",\n      body: `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <d:propfind xmlns:d=\"DAV:\">\n   <d:prop xmlns:oc=\"http://owncloud.org/ns\">\n    <oc:fileid/>\n   </d:prop>\n </d:propfind>`,\n      headers: {\n        Authorization: `Basic ${btoa(\"admin:admin\")}`,\n      },\n    });\n    const xml = new XMLParser().parse(await response.text());\n    const fileId =\n      xml[\"d:multistatus\"][\"d:response\"][\"d:propstat\"][\"d:prop\"][\"oc:fileid\"];\n    const baseURL = this.cristalApp.getWikiConfig().baseURL;\n    const url = `${baseURL}/f/${fileId}`;\n    return `[${label}](${url})`;\n  }\n\n  // eslint-disable-next-line max-statements\n  async serializeImage(\n    target: Extract<LinkTarget, { type: \"internal\" }>,\n    alt?: string,\n  ): Promise<string> {\n    let ref: string;\n    if (target.parsedReference) {\n      const currentDocumentReference =\n        this.documentService.getCurrentDocumentReference().value!;\n      if (target.parsedReference.type == EntityType.ATTACHMENT) {\n        const parsedReference = target.parsedReference;\n        const imageDocumentReference = parsedReference.document;\n        if (currentDocumentReference === imageDocumentReference) {\n          ref = `.${imageDocumentReference.name}/attachments/${parsedReference.name}`;\n        } else {\n          const down = [\n            ...(currentDocumentReference.space &&\n            currentDocumentReference.space.names.length > 0\n              ? currentDocumentReference.space.names.map(() => \"..\")\n              : [\".\"]),\n          ].join(\"/\");\n          const up = [\n            ...(parsedReference.document.space?.names ?? []),\n            \".\" + parsedReference.document.name,\n          ]\n            .map(encodeURI)\n            .join(\"/\");\n          ref = `${down}/${up}/attachments/${encodeURI(parsedReference.name)}`;\n        }\n      } else {\n        throw new Error(\n          `Unexpected type ${target.parsedReference.type} for link serialization`,\n        );\n      }\n    } else {\n      ref = target.rawReference;\n    }\n\n    return `![${alt ?? \"\"}](${ref})`;\n  }\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { AttachmentReference, EntityType } from \"@xwiki/platform-model-api\";\nimport { inject, injectable } from \"inversify\";\nimport type { InternalLinksSerializer } from \"./internal-links-serializer\";\nimport type { UniAstToMarkdownConverter } from \"../../uni-ast-to-markdown-converter\";\nimport type { DocumentService } from \"@xwiki/platform-document-api\";\nimport type { EntityReference } from \"@xwiki/platform-model-api\";\nimport type { Link, LinkTarget } from \"@xwiki/platform-uniast-api\";\n\n/**\n * @since 0.22\n */\n@injectable()\nexport class GitHubInternalLinkSerializer implements InternalLinksSerializer {\n  constructor(\n    @inject(\"DocumentService\")\n    private readonly documentService: DocumentService,\n  ) {}\n\n  async serialize(\n    content: Link[\"content\"],\n    target: Extract<LinkTarget, { type: \"internal\" }>,\n    uniAstToMarkdownConverter: UniAstToMarkdownConverter,\n  ): Promise<string> {\n    const label =\n      await uniAstToMarkdownConverter.convertInlineContents(content);\n\n    const ref = this.computeRef(target);\n    return `[${label}](${ref})`;\n  }\n\n  async serializeImage(\n    target: Extract<LinkTarget, { type: \"internal\" }>,\n    alt?: string,\n  ): Promise<string> {\n    const ref = this.computeRef(target);\n    return `![${alt ?? \"\"}](${ref})`;\n  }\n\n  // eslint-disable-next-line max-statements\n  private computeRef(\n    target: Extract<\n      {\n        type: \"internal\";\n        rawReference: string;\n        parsedReference: EntityReference | null;\n      },\n      { type: \"internal\" }\n    >,\n  ) {\n    if (target.parsedReference) {\n      const currentDocumentReference =\n        this.documentService.getCurrentDocumentReference().value!;\n      let parsedReference = target.parsedReference;\n      const isAttachment = parsedReference.type === EntityType.ATTACHMENT;\n      if (isAttachment) {\n        parsedReference = (parsedReference as AttachmentReference).document;\n      } else if (parsedReference.type !== EntityType.DOCUMENT) {\n        throw new Error(\n          `Unexpected type ${parsedReference.type} for link serialization`,\n        );\n      }\n\n      const down = [\n        ...(currentDocumentReference.space &&\n        currentDocumentReference.space.names.length > 0\n          ? currentDocumentReference.space.names.map(() => \"..\")\n          : [\".\"]),\n      ].join(\"/\");\n\n      const name = (isAttachment ? \".\" : \"\") + parsedReference.name;\n      const up = [...(parsedReference.space?.names ?? []), name]\n        .map(encodeURI)\n        .join(\"/\");\n      if (!isAttachment) {\n        return `${down}/${up}.md`.replace(/^\\.\\//, \"\");\n      } else {\n        return `${down}/${up}/attachments/${encodeURI((target.parsedReference as AttachmentReference).name)}`.replace(\n          /^\\.\\//,\n          \"\",\n        );\n      }\n    } else {\n      return target.rawReference;\n    }\n  }\n}\n","/**\n * See the LICENSE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\nimport { AttachmentReference, EntityType } from \"@xwiki/platform-model-api\";\nimport { inject, injectable } from \"inversify\";\nimport type { InternalLinksSerializer } from \"./internal-links-serializer\";\nimport type { UniAstToMarkdownConverter } from \"../../uni-ast-to-markdown-converter\";\nimport type { DocumentService } from \"@xwiki/platform-document-api\";\nimport type { EntityReference } from \"@xwiki/platform-model-api\";\nimport type { Link, LinkTarget } from \"@xwiki/platform-uniast-api\";\n\n/**\n * @since 0.22\n */\n@injectable()\nexport class FilesystemInternalLinkSerializer\n  implements InternalLinksSerializer\n{\n  constructor(\n    @inject(\"DocumentService\")\n    private readonly documentService: DocumentService,\n  ) {}\n\n  async serialize(\n    content: Link[\"content\"],\n    target: Extract<LinkTarget, { type: \"internal\" }>,\n    uniAstToMarkdownConverter: UniAstToMarkdownConverter,\n  ): Promise<string> {\n    const linkText = `${await uniAstToMarkdownConverter.convertInlineContents(\n      content,\n    )}`;\n    return `[${linkText}](${this.serializeTarget(target)})`;\n  }\n\n  async serializeImage(\n    target: Extract<LinkTarget, { type: \"internal\" }>,\n    alt?: string,\n  ): Promise<string> {\n    return `![${alt ?? \"\"}](${this.serializeTarget(target)})`;\n  }\n\n  // eslint-disable-next-line max-statements\n  private serializeTarget(\n    target: Extract<\n      {\n        type: \"internal\";\n        rawReference: string;\n        parsedReference: EntityReference | null;\n      },\n      { type: \"internal\" }\n    >,\n  ) {\n    if (target.parsedReference) {\n      const currentDocumentReference =\n        this.documentService.getCurrentDocumentReference().value!;\n      let parsedReference = target.parsedReference;\n      const isAttachment = parsedReference.type === EntityType.ATTACHMENT;\n      if (isAttachment) {\n        parsedReference = (parsedReference as AttachmentReference).document;\n      } else if (parsedReference.type !== EntityType.DOCUMENT) {\n        throw new Error(\n          `Unexpected type ${parsedReference.type} for link serialization`,\n        );\n      }\n\n      const down = [\n        ...(currentDocumentReference.space &&\n        currentDocumentReference.space.names.length > 0\n          ? currentDocumentReference.space.names.map(() => \"..\")\n          : [\".\"]),\n      ].join(\"/\");\n\n      const name = (isAttachment ? \".\" : \"\") + parsedReference.name;\n      const up = [...(parsedReference.space?.names ?? []), name]\n        .map(encodeURI)\n        .join(\"/\");\n      if (!isAttachment) {\n        return `${down}/${up}.md`.replace(/^\\.\\//, \"\");\n      } else {\n        return `${down}/${up}/attachments/${encodeURI((target.parsedReference as AttachmentReference).name)}`.replace(\n          /^\\.\\//,\n          \"\",\n        );\n      }\n    } else {\n      return target.rawReference;\n    }\n  }\n}\n"],"names":["findFirstMatchIn","subject","candidates","first","name","match","offset","remarkPartialGfm","data","gfmStrikethrough","gfmTable","gfmTaskListItem","gfmStrikethroughFromMarkdown","gfmTableFromMarkdown","gfmTaskListItemFromMarkdown","ParserConfigurationResolver","cristalApp","type","__decorateClass","injectable","__decorateParam","DefaultMarkdownToUniAstConverter","modelReferenceParserProvider","modelReferenceHandlerProvider","parserConfigurationResolver","markdown","ast","unified","remarkParse","item","e","block","content","assertInArray","i","headers","rows","columns","cell","tableRows","row","map","assertUnreachable","inline","styles","target","token","image","url","EntityType","text","out","treated","firstItem","precedingBackslashes","isImage","escaping","closing","closed","char","substr","title","targetStr","pipeCharPos","reference","items","macroNameMatch","macroName","buildingParameter","parameters","closingMacro","number","closingBraces","children","InternalLinksSerializerResolver","DefaultUniAstToMarkdownConverter","internalLinksSerializerResolver","uniAst","blocks","element","md","tryFallibleOrError","values","line","s","listItem","prefix","contents","lines","table","column","inlineContents","inlineContent","value","bold","italic","strikethrough","code","surroundings","markdownToUniAstConverterName","uniAstToMarkdownConverterName","ComponentInit","container","context","component","xwikiInternalLinkSerializer","nextcloudInternalLinkSerializer","githubInternalLinkSerializer","filesystemInternalLinkSerializer","XWikiInternalLinkSerializer","uniAstToMarkdownConverter","alt","NextcloudInternalLinkSerializer","remoteURLSerializerProvider","documentService","label","urlFromReference","response","fileId","XMLParser","ref","currentDocumentReference","parsedReference","imageDocumentReference","down","up","GitHubInternalLinkSerializer","isAttachment","FilesystemInternalLinkSerializer"],"mappings":"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"}