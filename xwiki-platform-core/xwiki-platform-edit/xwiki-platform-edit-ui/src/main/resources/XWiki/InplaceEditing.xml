<?xml version="1.1" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc version="1.4" reference="XWiki.InplaceEditing" locale="">
  <web>XWiki</web>
  <name>InplaceEditing</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <parent>WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <version>1.1</version>
  <title/>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>true</hidden>
  <content>{{velocity wiki="false"}}
#if ($request.action == 'lock')
  ## This could be moved later to a Velocity template (e.g. lock.vm).
  #template('edit_macros.vm')
  #getEditConfirmation()
  #if ($editConfirmation)
    ## Ask for confirmation to force the lock.
    #set ($discard = $response.setStatus(423))
    #jsonResponse($editConfirmation)
  #else
    ## Lock the document for editing.
    #set ($discard = $response.sendRedirect($tdoc.getURL('lock', $escapetool.url({
      'ajax': 1,
      'action': $request.lockAction,
      'language': $tdoc.realLocale
    }))))
  #end
#end
{{/velocity}}</content>
  <object>
    <name>XWiki.InplaceEditing</name>
    <number>0</number>
    <className>XWiki.JavaScriptExtension</className>
    <guid>700dc756-1a3a-49e0-854f-c2ecb0d8e970</guid>
    <class>
      <name>XWiki.JavaScriptExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <defaultValue>long</defaultValue>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage|onDemand|always</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>require.config({
  paths: {
    'actionButtons': $jsontool.serialize($xwiki.getSkinFile('js/xwiki/actionbuttons/actionButtons.js', true)),
    // Required in case the user needs to resolve merge conflicts on save.
    'diff': $jsontool.serialize($xwiki.getSkinFile('uicomponents/viewers/diff.js'))
  }
});

define('xwiki-document-api', ['jquery'], function($) {
  var getOldAPI = function(xwikiDocument) {
    return (xwikiDocument.documentReference &amp;&amp; new XWiki.Document(xwikiDocument.documentReference)) ||
      XWiki.currentDocument;
  };

  return {
    /**
     * @return this document's real locale
     */
    getRealLocale: function() {
      return this.language || (this.translations &amp;&amp; this.translations['default']) || $('html').attr('lang');
    },

    /**
     * @return the URL that can be used to perform the specified action on this document
     */
    getURL: function(action, queryString, fragment) {
      if (queryString &amp;&amp; typeof queryString === 'object') {
        queryString = $.param(queryString, true);
      }
      // Forward the call to the old API.
      var oldAPI = getOldAPI(this);
      return oldAPI.getURL.call(oldAPI, action, queryString, fragment);
    },

    /**
     * @param queryString the query string to add to the URL; it can be a string or a plain JavaScript object
     * @return the URL that can be used to retrieve this document's (JSON) data, taking into account whether this is the
     *         original document or a translation
     */
    getRestURL: function(queryString) {
      var oldAPI = getOldAPI(this);
      if (queryString &amp;&amp; typeof queryString === 'object') {
        queryString = $.param(queryString, true);
      }
      var entity = this.language &amp;&amp; ('translations/' + encodeURIComponent(this.language));
      return oldAPI.getRestURL(entity, queryString);
    },

    /**
     * Render the title and the content of this document.
     *
     * @param forView whether to render the document for view (without the rendering annotations) or for edit (with the
     *          rendering annotations); when rendering for edit some transformations might not be executed
     * @return a promise that resolves to this document instance if the render request succeeds
     */
    render: function(forView) {
      var queryString = {
        xpage: 'rendercontent',
        outputTitle: true,
        outputSyntax: forView ? null : 'annotatedxhtml',
        language: this.getRealLocale(),
        // Make sure the response is not retrieved from cache (IE11 doesn't obey the caching HTTP headers).
        timestamp: new Date().getTime()
      };
      var thisXWikiDocument = this;
      return $.get(this.getURL('view'), queryString).fail(function() {
        new XWiki.widgets.Notification(
          $jsontool.serialize($services.localization.render('edit.inplace.page.renderFailed')),
          'error'
        );
      }).then(function(html) {
        var container = $('&lt;div/&gt;').html(html);
        return $.extend(thisXWikiDocument, {
          renderedTitle: container.find('#document-title h1').html(),
          renderedContent: container.find('#xwikicontent').html()
        });
      });
    },

    /**
     * Reload this document's (JSON) data.
     *
     * @return a promise that resolves to this document instance if the reload request succeeds
     */
    reload: function() {
      var thisXWikiDocument = this;
      return $.getJSON(this.getRestURL(), {
        // Make sure the response is not retrieved from cache (IE11 doesn't obey the caching HTTP headers).
        timestamp: new Date().getTime()
      }).then(function(newXWikiDocument) {
        // Resolve the document reference.
        thisXWikiDocument.documentReference = XWiki.Model.resolve(newXWikiDocument.id, XWiki.EntityType.DOCUMENT);
        // We were able to load the document so it's not new.
        thisXWikiDocument.isNew = false;
        return $.extend(thisXWikiDocument, newXWikiDocument);
      });
    },

    /**
     * Lock this document for the specified action. The request fails if the document is already locked, unless the lock
     * is forced.
     *
     * @return a promise that resolves to this document instance if the lock request succeeds
     */
    lock: function(action, force) {
      var thisXWikiDocument = this;
      action = action || 'edit';
      return $.getJSON(this.getURL('get'), {
        sheet: 'XWiki.InplaceEditing',
        action: 'lock',
        lockAction: action,
        force: force,
        language: this.getRealLocale(),
        outputSyntax: 'plain',
        // Make sure the response is not retrieved from cache (IE11 doesn't obey the caching HTTP headers).
        timestamp: new Date().getTime()
      }).then(function() {
        thisXWikiDocument.locked = action;
        return thisXWikiDocument;
      });
    },

    /**
     * Unlock this document for the specified action, by sending a beacon, if the browser supports it, or by making a
     * synchronous HTTP request, because this function can be called just before the window is unloaded.
     */
    unlock: function(action) {
      action = action || 'edit';
      this.locked = false;
      var url = this.getURL('cancel', $.param({
        ajax: 1,
        action: action,
        language: this.getRealLocale()
      }));
      if (navigator.sendBeacon) {
        navigator.sendBeacon(url);
      } else {
        // Make a synchronous request otherwise, because the page can unload before the unlock request is sent.
        // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests
        $.ajax({type: 'GET', url: url, async: false});
      }
    }
  };
});

define('editInPlace', [
  'jquery',
  // We need this in order to access information about the current page.
  'xwiki-meta',
  // We need this in order to easily work with the XWiki document JSON.
  'xwiki-document-api',
  // We need this for the confirmation modals.
  'bootstrap',
  // We need this in order to catch events triggered by actionButtons.js using Prototype.js
  'xwiki-events-bridge'
], function($, xcontext, xwikiDocumentAPI) {
  var preload = function() {
    loadCSS($jsontool.serialize($xwiki.getSkinFile('js/xwiki/actionbuttons/actionButtons.css', true)));
    // Required in case the user needs to resolve merge conflicts on save.
    loadCSS($jsontool.serialize($xwiki.getSkinFile('uicomponents/viewers/diff.css', true)));
    return initActionButtons();
  };

  var loadCSS = function(url) {
    var link = $('&lt;link&gt;').attr({
      type: 'text/css',
      rel: 'stylesheet',
      href: url
    }).appendTo('head');
  };

  var editPage = function() {
    return editInPlace({
      afterEdit: function() {
        $('#document-title-input').focus().select();
      }
    });
  };

  var editSection = function(sectionId) {
    return editInPlace({
      lockFailed: function() {
        // Revert the changes done on #xwikicontent.
        $('#xwikicontent').removeAttr('tabindex').children(':header').children('.edit_section').removeClass('hidden');
      },
      afterEdit: function() {
        // We don't need the tabindex attribute anymore now that the content is editable.
        $('#xwikicontent').removeAttr('tabindex');
        if (sectionId) {
          // Select the heading of the specified section.
          $('#xwikicontent &gt; #' + escapeSelector(sectionId)).each(function() {
            selectText(this);
          });
        }
      }
    });
  };

  var escapeSelector = function(selector) {
    if (window.CSS &amp;&amp; typeof CSS.escape === 'function') {
      // Not supported by Internet Explorer.
      return CSS.escape(selector);
    } else if (typeof $.escapeSelector === 'function') {
      // Added in jQuery 3.0
      return $.escapeSelector(selector);
    } else if (typeof selector === 'string') {
      // Simple implementation.
      // See https://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/
      return selector.replace(/(:|\.|\[|\]|,|=|@)/g, '\\$1');
    } else {
      return selector;
    }
  };

  // We preserve the document data between edits in order to be able to know which document translation should be edited
  // (e.g. when the document translation is missing and we create it, the next edit session should target the created
  // translation).
  var currentXWikiDocument = $.extend({
    language: xcontext.locale
  }, xwikiDocumentAPI);

  var editInPlace = function(options) {
    options = $.extend({
      afterEdit: function() {},
      lockFailed: function() {}
    }, options);
    $('#xwikicontent').addClass('loading');
    return lock(currentXWikiDocument).fail(options.lockFailed)
      .then(load)
      .then(edit).done(options.afterEdit).always(function() {
        $('#xwikicontent').removeClass('loading');
      }).then(maybeSave)
      .then(unlock)
      .then(view);
  };

  var lock = function(xwikiDocument) {
    return xwikiDocument.lock().then(null, function(response) {
      var confirmation = response.responseJSON;
      // If the document was already locked then we need to ask the user if they want to force the lock.
      if (response.status === 423 &amp;&amp; confirmation) {
        return maybeForceLock(confirmation).then($.proxy(xwikiDocument, 'lock', 'edit', true));
      } else {
        new XWiki.widgets.Notification(
          $jsontool.serialize($services.localization.render('edit.inplace.page.lockFailed')),
          'error'
        );
      }
    });
  };

  var maybeForceLock = function(confirmation) {
    var deferred = $.Deferred();
    // Reuse the confirmation modal once it is created.
    var modal = $('.force-edit-lock-modal');
    if (modal.length === 0) {
      modal = createForceLockModal();
    }
    // Update the deferred that needs to be resolved or rejected.
    modal.data('deferred', deferred);
    // Update the confirmation modal.
    modal.find('.modal-title').text(confirmation.title);
    modal.find('.modal-body').html(confirmation.message);
    modal.find('.modal-footer .btn-default').text(confirmation.reject);
    if (confirmation.confirm) {
      modal.find('.modal-footer .btn-warning').show().text(confirmation.confirm);
    } else {
      modal.find('.modal-footer .btn-warning').hide();
    }
    // Show the confirmation modal.
    modal.modal('show');
    return deferred.promise();
  };

  var createForceLockModal = function() {
    var modal = $([
      '&lt;div class="modal fade force-edit-lock-modal" tabindex="-1" role="dialog"&gt;',
        '&lt;div class="modal-dialog" role="document"&gt;',
          '&lt;div class="modal-content"&gt;',
            '&lt;div class="modal-header"&gt;',
              '&lt;button type="button" class="close" data-dismiss="modal"&gt;',
                '&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;',
              '&lt;/button&gt;',
              '&lt;h4 class="modal-title"&gt;&lt;/h4&gt;',
            '&lt;/div&gt;',
            '&lt;div class="modal-body"&gt;&lt;/div&gt;',
            '&lt;div class="modal-footer"&gt;',
              '&lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;&lt;/button&gt;',
              '&lt;button type="button" class="btn btn-warning"&gt;&lt;/button&gt;',
            '&lt;/div&gt;',
          '&lt;/div&gt;',
        '&lt;/div&gt;',
      '&lt;/div&gt;'
    ].join(''));
    modal.find('.close').attr('aria-label', $jsontool.serialize($services.localization.render('edit.inplace.close')));
    modal.find('.modal-footer .btn-warning').click(function() {
      // The user has confirmed they want to force the lock.
      modal.data('deferred').resolve();
      modal.modal('hide');
    });
    modal.on('hide.bs.modal', function() {
      // If the lock promise is not yet resolved when the modal is closing then it means the modal was canceled,
      // i.e. the user doesn't want to force the lock.
      var deferred = modal.data('deferred');
      if (deferred.state() === 'pending') {
        deferred.reject();
      }
    });
    return modal.appendTo('body').modal();
  };

  var load = function(xwikiDocument) {
    return xwikiDocument.reload().done(function(xwikiDocument) {
      // Clone the current document version and keep a reference to it in order to be able to restore it on cancel.
      xwikiDocument.originalDocument = $.extend(true, {
        renderedTitle: $('#document-title h1').html(),
        renderedContent: $('#xwikicontent').html()
      }, xwikiDocument);
    }).fail(function() {
      new XWiki.widgets.Notification($jsontool.serialize($services.localization.render('edit.inplace.page.loadFailed')),
        'error');
    // Render the document for edit, in order to have the annotated content HTML. The annotations are used to protect
    // the rendering transformations (e.g. macros) when editing the content.
    }).then($.proxy(render, null, false));
  };

  /**
   * @param forView whether to render the document for view (without the rendering annotations) or for edit (with the
   *          rendering annotations); when rendering for edit some transformations might not be executed
   * @param xwikiDocument the document to render
   */
  var render = function(forView, xwikiDocument) {
    return xwikiDocument.render(forView);
  };

  var maybeSave = function(xwikiDocument) {
    return waitForAction(xwikiDocument).then(function(action) {
      switch(action.name) {
        case 'save': return save({
          document: action.document,
          'continue': action.data &amp;&amp; action.data['continue']
        });
        case 'reload': return reload(action.document);
        default: return cancel(action.document);
      }
    });
  };

  var waitForAction = function(xwikiDocument) {
    var deferred = $.Deferred();
    // We wait for the first save, reload or cancel event, whichever is triggered first. Note that the event listeners
    // that are not executed first will remain registered but that doesn't cause any problems because the state of a
    // deferred object (promise) cannot change once it was resolved. So the first event that fires will resolve the
    // promise and the remaining events won't be able to change that. The remaining event listeners could be called
    // later but they won't have any effect on the deferred object.
    $(document).one([
      'xwiki:actions:save',
      'xwiki:actions:reload',
      'xwiki:actions:cancel',
    ].join(' '), function(event, data) {
      deferred.resolve({
        name: event.type.substring('xwiki:actions:'.length),
        document: xwikiDocument,
        data: data
      });
    });
    return deferred.promise();
  };

  var save = function(data) {
    // Push the changes to the server then render the document for view. We need the view HTML both if we stop editing
    // now and if we continue but cancel the edit later.
    return push(data.document).then($.proxy(render, null, true)).then(function(xwikiDocument) {
      // Save succeeded.
      if (data['continue']) {
        // Update the original version in order to be able to restore it on cancel.
        delete xwikiDocument.originalDocument;
        xwikiDocument.originalDocument = $.extend(true, {}, xwikiDocument);
        // Continue editing.
        return maybeSave(xwikiDocument);
      } else {
        // This is the final version.
        return xwikiDocument;
      }
    }, function(xwikiDocument) {
      // Save failed. Continue editing.
      return maybeSave(xwikiDocument);
    });
  };

  var push = function(xwikiDocument) {
    // Let actionButtons.js do the push. We just catch the result.
    var deferred = $.Deferred();
    // We wait for the save request to either succeed or fail. Note that one of the event listeners will remain
    // registered but that doesn't cause any problems because the state of a deferred object (promise) cannot change
    // once it was resolved or rejected. So the first event that fires will resolve/reject the promise and the remaining
    // event won't be able to change that. The remaining event listener could be called later but it won't have any
    // effect.
    $(document).one('xwiki:document:saved', $.proxy(deferred, 'resolve', xwikiDocument));
    $(document).one('xwiki:document:saveFailed', $.proxy(deferred, 'reject', xwikiDocument));
    return deferred.promise().then($.proxy(xwikiDocument, 'reload'));
  };

  var cancel = function(xwikiDocument) {
    // Simply return the original version to be restored.
    return xwikiDocument.originalDocument;
  };

  // Unlock the document so that other users can edit it.
  var unlock = function(xwikiDocument) {
    // Check if we're still editing.
    if (xwikiDocument.locked &amp;&amp; $('#document-title-input').length &gt; 0) {
      xwikiDocument.unlock();
    }
    return xwikiDocument;
  };

  // Make sure we unlock the document when the user navigates to another page.
  $(window).on('unload pagehide', $.proxy(unlock, null, currentXWikiDocument));

  var reload = function(xwikiDocument) {
    // Leave the edit mode and then re-enter.
    return view(xwikiDocument, true).then(editInPlace);
  };

  var view = function(xwikiDocument, reload) {
    // Destroy the editors before returning to view.
    $(document).trigger('xwiki:actions:view', {document: xwikiDocument});
    $('#document-title h1').html(xwikiDocument.renderedTitle);
    $('#xwikicontent').html(xwikiDocument.renderedContent);
    if (!reload) {
      // If the user has canceled the edit then the restored page content may include the section edit links. Show them
      // in case they were hidden.
      $('#xwikicontent').children(':header').children('.edit_section').removeClass('hidden');
      // Let others know that the DOM has been updated, in order to enhance it.
      $(document).trigger('xwiki:dom:updated', {'elements': $('#xwikicontent').toArray()});
    }
    return $.Deferred().resolve(xwikiDocument).promise();
  };

  var edit = function(xwikiDocument) {
    return initActionButtons(xwikiDocument).then(initTitleEditor).then(initContentEditor)
      .then(startRealTimeEditingSession);
  };

  var initActionButtons = function(xwikiDocument) {
    if (xwikiDocument) {
      maybeShowTranslateButton(xwikiDocument);
    }
    var editContent = $('#xwikicontent');
    // We need the wrapper because #xwikicontent uses Bootstrap grid (col-xs-12) which is implemented with CSS float.
    // Thus we need to use the grid for the sticky buttons also otherwise the postion is badly computed when scrolling
    // (because of the float on the previous element). This wouldn't be needed if we were using position:sticky, which
    // we can't use yet because it's not implemented on IE11 which we still have to support.
    var actionButtonsWrapper = editContent.nextAll('.sticky-buttons-wrapper');
    if (actionButtonsWrapper.length === 0) {
      actionButtonsWrapper = $('&lt;div class="sticky-buttons-wrapper col-xs-12"&gt;&lt;div class="sticky-buttons"/&gt;&lt;/div&gt;')
        .insertAfter(editContent);
      var actionButtons = actionButtonsWrapper.children('.sticky-buttons').data('xwikiDocument', xwikiDocument)
        .toggle(!!xwikiDocument);
      return loadActionButtons(actionButtons);
    } else {
      // If we're editing a page..
      if (xwikiDocument) {
        // ..then make sure the action buttons are displayed right away (don't wait for the user to scroll).
        actionButtonsWrapper.children('.sticky-buttons').data('xwikiDocument', xwikiDocument).show();
        // The action buttons are disabled on Save &amp; View. We don't reload the page on Save &amp; View and we reuse the
        // action buttons so we need to re-enable them each time we enter the edit mode.
        fakeForm.enable();
        $(document).trigger('xwiki:dom:refresh');
      }
      return $.Deferred().resolve(xwikiDocument).promise();
    }
  };

  var maybeShowTranslateButton = function(xwikiDocument) {
    var xwikiDocumentLocale = xwikiDocument.getRealLocale();
    var uiLocale = $('html').attr('lang');
    if (xwikiDocumentLocale &amp;&amp; xwikiDocumentLocale !== uiLocale) {
      $('#tmTranslate').off('click.translate').on('click.translate', function(event) {
        event.preventDefault();
        $(this).addClass('hidden');
        xwikiDocument.language = uiLocale;
        // Update the document translation fields that are not 'shared' with the original document.
        xwikiDocument.isNew = true;
        delete xwikiDocument.version;
        delete xwikiDocument.majorVersion;
        delete xwikiDocument.minorVersion;
        $('#document-title-input').focus().select();
        var message = $jsontool.serialize($services.localization.render('edit.inplace.page.translation',
          ['__locale__']));
        new XWiki.widgets.Notification(
          message.replace('__locale__', uiLocale),
          'info'
        );
      }).removeClass('hidden');
      var message = $jsontool.serialize($services.localization.render('edit.inplace.page.original', ['__locale__']));
      new XWiki.widgets.Notification(
        message.replace('__locale__', xwikiDocumentLocale),
        'info'
      );
    }
  };

  var loadActionButtons = function(actionButtons) {
    $(document).on('xwiki:actions:view', function() {
      // Hide the action buttons and disable the shortcut keys (by disabling the buttons).
      actionButtons.hide().find(':input').prop('disabled', true);
      // Hide the translate button because it can be used only in edit mode for the moment.
      $('#tmTranslate').addClass('hidden');
    });
    return $.get(XWiki.currentDocument.getURL('get'), {
      xpage: 'editactions'
    }).then(function(html) {
      actionButtons.html(html);
      // Fix the name of the Save &amp; View action.
      actionButtons.find('.btn-primary').first().attr('name', 'action_save');
      // Append the hidden input field that keeps the CSRF token.
      $('&lt;input type="hidden" name="form_token" /&gt;').val(xcontext.form_token).appendTo(actionButtons);
      // We need a place where actionButtons.js can add more hidden inputs.
      actionButtons.append('&lt;div class="hidden extra"/&gt;');
      var deferred = $.Deferred();
      require(['actionButtons'], function() {
        overrideEditActions();
        overrideAjaxSaveAndContinue();
        var xwikiDocument = actionButtons.data('xwikiDocument');
        // Enable the action buttons (and their shortcut keys) only if we're editing a document.
        actionButtons.find(':input').prop('disabled', !xwikiDocument);
        deferred.resolve(xwikiDocument);
      });
      return deferred.promise();
    }, function() {
      new XWiki.widgets.Notification(
        $jsontool.serialize($services.localization.render('edit.inplace.actionButtons.loadFailed')),
        'error'
      );
    });
  };

  // actionButtons.js expects a form so we use a fake form. Refactoring actionButtons.js is too dangerous ATM.
  var fakeForm = {
    action: XWiki.currentDocument.getURL('save'),
    async: true,
    _getActionButtons: function() {
      if (!this._actionButtons) {
        this._actionButtons = $('#xwikicontent').nextAll('.sticky-buttons-wrapper').children('.sticky-buttons');
      }
      return this._actionButtons;
    },
    disable: function() {
      this._getActionButtons().find(':input').prop('disabled', true);
    },
    enable: function() {
      // Clear the extra hidden input fields, that actionButtons.js might have added, each time the form is (re)enabled
      // (i.e. after a failed Save &amp; View or before entering the edit mode) because they are designed to be used once.
      this._getActionButtons().find('.hidden.extra').empty();
      this._getActionButtons().find(':input').prop('disabled', false);
    },
    insert: function(element) {
      this._getActionButtons().find('.hidden.extra').append(element);
    },
    serialize: function() {
      var extra = this._getActionButtons().find(':input').serializeArray().reduce(function(extra, entry) {
        var value = extra[entry.name] || [];
        value.push(entry.value);
        extra[entry.name] = value;
        return extra;
      }, {});
      var xwikiDocument = this._getActionButtons().data('xwikiDocument');
      var formData = {
        title: xwikiDocument.title,
        content: xwikiDocument.renderedContent,
        RequiresHTMLConversion: 'content',
        content_syntax: xwikiDocument.syntax,
        language: xwikiDocument.getRealLocale(),
        isNew: xwikiDocument.isNew
      };
      // Check for merge conflicts only if the document is not new and we know the current version.
      if (!xwikiDocument.isNew &amp;&amp; xwikiDocument.version) {
        formData.previousVersion = xwikiDocument.version;
        // It would have been easier to send the timestamp but that's what the Save action expects.
        formData.editingVersionDate = new Date(xwikiDocument.modified).toISOString();
      }
      return $.extend(formData, extra);
    }
  };

  var overrideEditActions = function() {
    // Override the EditActions.notify() function in order to pass a fake form in the event parameters.
    var originalNotify = XWiki.actionButtons.EditActions.prototype.notify;
    XWiki.actionButtons.EditActions.prototype.notify = function(originalEvent, action, params) {
      if (params) {
        // actionButtons.js expects a form so we use a fake form. Refactoring actionButtons.js is too dangerous ATM.
        // Note that we do this only when the event has parameters because we want to exclude the cancel event for which
        // actionButtons.js changes the window location if a form is specified, and we want to prevent that.
        params.form = fakeForm;
      }
      return originalNotify.apply(this, arguments);
    };
  };

  var overrideAjaxSaveAndContinue = function() {
    $.extend(XWiki.actionButtons.AjaxSaveAndContinue.prototype, {
      reloadEditor: function() {
        $(document).trigger('xwiki:actions:reload');
      },
      maybeRedirect: function() {
        // Never redirect when leaving the edit mode because we're already in view mode.
        return false;
      }
    });
  };

  var initTitleEditor = function(xwikiDocument) {
    var label = $('&lt;label for="document-title-input" class="sr-only"/&gt;')
      .text($jsontool.serialize($services.localization.render('core.editors.content.titleField.label')));
    var input = $('&lt;input type="text" id="document-title-input"/&gt;').val(xwikiDocument.title);
    var placeholder = xwikiDocument.documentReference.name;
    if (placeholder === 'WebHome') {
      placeholder = xwikiDocument.documentReference.parent.name;
    }
    input.attr('placeholder', placeholder);
    $('#document-title h1').addClass('editable').empty().append([label, input]);
    $(document).on('xwiki:actions:beforeSave.titleEditor', function(event) {
      xwikiDocument.title = input.val();
    });
    $(document).one('xwiki:actions:view', function(event, data) {
      // Destroy the title editor.
      $(document).off('xwiki:actions:beforeSave.titleEditor');
      $('#document-title h1').removeClass('editable').text(xwikiDocument.title);
    });
    return xwikiDocument;
  };

  var initContentEditor = function(xwikiDocument) {
    var editContent = $('#xwikicontent');
    var withFocus = document.activeElement &amp;&amp; document.activeElement === editContent[0];
    // Keep showing the view content until the edit content is ready in order to avoid UI flicker.
    var viewContent = editContent.clone().insertAfter(editContent);
    // Note that we don't trigger the xwiki:dom:updated event here because we want to let the editor trigger the event
    // only for the content areas that are safe to be updated from JavaScript (i.e. the macro output).
    editContent.hide().html(xwikiDocument.renderedContent);
    if (withFocus) {
      // Keep the focus while the edit content is being prepared.
      viewContent.focus();
    }
    var data = {
      contentType: 'org.xwiki.rendering.syntax.SyntaxContent',
      editMode: 'wysiwyg',
      document: xwikiDocument,
      // The content editor is loaded on demand, asynchronously.
      deferred: $.Deferred()
    };
    var editContentPromise = data.deferred.promise();
    editContentPromise.done(function() {
      editContent.show();
      viewContent.remove();
      if (withFocus) {
        // Restore the focus when the edit content is ready but make sure we don't scroll the page.
        editContent[0].focus({preventScroll: true});
      }
    });
    editContent.trigger('xwiki:actions:edit', data);
    return editContentPromise;
  };

  var startRealTimeEditingSession = function(xwikiDocument) {
    // TODO
    return xwikiDocument;
  };

  var selectText = function(node) {
    if (window.getSelection) {
      var selection = window.getSelection();
      var range = document.createRange();
      range.selectNodeContents(node);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  };

  return {
    preload: preload,
    editPage: editPage,
    editSection: editSection
  };
});

require(['jquery'], function($) {
  var inplaceEditingConfig = $('div[data-inplace-editing-config]').data('inplaceEditingConfig') || {};
  var wysiwygEditorModule = 'xwiki-' + inplaceEditingConfig.wysiwygEditor + '-inline';

  var preloadEditor = function() {
    require(['editInPlace', wysiwygEditorModule], function(editInPlace) {
      editInPlace.preload();
    // Fallback on the standalone edit mode if we fail to load the required modules.
    }, disableInPlaceEditing);
  };

  // Preload the WYSIWYG editor code without slowing down the page view.
  if (document.readyState === 'complete') {
    setTimeout(preloadEditor, 0);
  } else {
    $(window).on('load', function() {
      setTimeout(preloadEditor, 0);
    });
  }

  var editButton = $('#tmEdit &gt; a');
  editButton.on('click.inPlaceEditing', function(event) {
    event.preventDefault();
    // Make sure the user doesn't try to re-activate the edit mode while we are in edit mode.
    editButton.addClass('disabled');
    // Load the code needed to edit in place only when the edit button is clicked.
    require(['editInPlace', wysiwygEditorModule], function(editInPlace) {
      editInPlace.editPage().always(function() {
        editButton.removeClass('disabled');
      });
    // Fallback on the standalone edit mode if we fail to load the required modules.
    }, $.proxy(disableInPlaceEditing, event.target));
  });

  // Section in-place editing.
  $('#xwikicontent').on('click.inPlaceEditing', '&gt; :header &gt; a.edit_section:not(.disabled)', function(event) {
    event.preventDefault();
    // Make sure the user doesn't try to re-activate the edit mode while we are in edit mode.
    editButton.addClass('disabled');
    // Hide the section editing links and focus the content right away. We could have replaced the section editing icon
    // with a loading animation / spinner but giving instant visual feedback about what is going to happen is perceived
    // better by the users (it feels faster).
    $('#xwikicontent').attr('tabindex', '0').focus().children(':header').children('.edit_section').addClass('hidden');
    var heading = $(event.target).closest(':header');
    // Load the code needed to edit in place only when the edit button is clicked.
    require(['editInPlace', wysiwygEditorModule], function(editInPlace) {
      editInPlace.editSection(heading.attr('id')).always(function() {
        editButton.removeClass('disabled');
      });
    // Fallback on the standalone edit mode if we fail to load the required modules.
    }, $.proxy(disableInPlaceEditing, event.target));
  });

  var disableInPlaceEditing = function() {
    editButton.off('click.inPlaceEditing').removeClass('disabled');
    $('#xwikicontent').off('click.inPlaceEditing').removeAttr('tabindex').children(':header').children('.edit_section')
      .removeClass('hidden');
    // Fallback on the standalone edit mode.
    $(this).click();
  };
});</code>
    </property>
    <property>
      <name/>
    </property>
    <property>
      <parse>1</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>XWiki.InplaceEditing</name>
    <number>0</number>
    <className>XWiki.StyleSheetExtension</className>
    <guid>bd0e5f70-8c74-48e4-97b9-81620b5d9394</guid>
    <class>
      <name>XWiki.StyleSheetExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <defaultValue>long</defaultValue>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <contentType>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>contentType</name>
        <number>6</number>
        <prettyName>Content Type</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>CSS|LESS</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </contentType>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage|onDemand|always</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>#document-title h1.editable {
  /* Move the title heading a bit to the top and to the left in order to accomodate the input border and padding. */
  margin-top: -@line-height-computed / 4;
  margin-left: -(ceil(@grid-gutter-width / 2));
  /* Reduce the bottom margin in order to accomodate the input border and bottom padding. */
  margin-bottom: @line-height-computed / 4;
}

input#document-title-input {
  /* Preserve the heading styles. */
  border: 1px solid transparent;
  box-shadow: none;
  color: inherit;
  font-size: inherit;
  height: auto;
  line-height: @headings-line-height;
  padding: (@line-height-computed / 4 - 1) (ceil(@grid-gutter-width / 2) - 1);
  width: 100%;
}

input#document-title-input:hover {
  border-color: @input-border;
}

input#document-title-input:focus,
#xwikicontent[contenteditable]:focus,
#xwikicontent[tabindex]:focus {
  .form-control-focus();
}

#xwikicontent[contenteditable],
#xwikicontent[tabindex] {
  border: 1px solid transparent;
  margin-top: -1px;
  margin-left: -1px;
}

#xwikicontent.loading {
  background: none;
  cursor: wait;
}

/* Leave more space at the top of the edited content by reducing the margin bottom of the preceding horizontal rule. */
.document-header + hr {
  margin-bottom: @line-height-computed / 4;
}
#xwikicontent {
  padding-top: @line-height-computed * 0.75;
}</code>
    </property>
    <property>
      <contentType>LESS</contentType>
    </property>
    <property>
      <name/>
    </property>
    <property>
      <parse>0</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>XWiki.InplaceEditing</name>
    <number>0</number>
    <className>XWiki.UIExtensionClass</className>
    <guid>5c7fd93e-a308-4bd0-a53a-5e4d54b2640c</guid>
    <class>
      <name>XWiki.UIExtensionClass</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <async_cached>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_cached</name>
        <number>3</number>
        <prettyName>Cached</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_cached>
      <async_context>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>1</multiSelect>
        <name>async_context</name>
        <number>4</number>
        <prettyName>Context elements</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>5</size>
        <unmodifiable>0</unmodifiable>
        <values>doc.reference=Document|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.parameters=Request parameters|request.url=Request URL|request.wiki=Request wiki|user=User|wiki=Wiki</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </async_context>
      <async_enabled>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_enabled</name>
        <number>2</number>
        <prettyName>Asynchronous rendering</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_enabled>
      <content>
        <disabled>0</disabled>
        <editor>Text</editor>
        <name>content</name>
        <number>1</number>
        <prettyName>Executed Content</prettyName>
        <rows>25</rows>
        <size>120</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </content>
      <extensionPointId>
        <disabled>0</disabled>
        <name>extensionPointId</name>
        <number>5</number>
        <prettyName>Extension Point ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </extensionPointId>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>6</number>
        <prettyName>Extension ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parameters>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>parameters</name>
        <number>7</number>
        <prettyName>Extension Parameters</prettyName>
        <rows>10</rows>
        <size>40</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </parameters>
      <scope>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>scope</name>
        <number>8</number>
        <prettyName>Extension Scope</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>wiki=Current Wiki|user=Current User|global=Global</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </scope>
    </class>
    <property>
      <async_cached>0</async_cached>
    </property>
    <property>
      <async_context/>
    </property>
    <property>
      <async_enabled>0</async_enabled>
    </property>
    <property>
      <content>{{velocity}}
{{html clean="false"}}
#if ($xcontext.action == 'view' &amp;&amp; !$doc.isNew())
  ## We support in-place editing only for the WYSIWYG edit mode ATM.
  #getDefaultDocumentEditor($defaultEditMode)
  #if ($defaultEditMode == 'wysiwyg')
    #set ($inplaceEditingConfig = {
      'editMode': $defaultEditMode,
      'wysiwygEditor': $services.edit.syntaxContent.defaultWysiwygEditor.descriptor.id
    })
    &lt;div class="hidden" data-inplace-editing-config="$escapetool.xml($jsontool.serialize($inplaceEditingConfig))"&gt;&lt;/div&gt;
    ## We didn't move this to the file system because it uses LESS and we didn't want to include it in the skin.
    #set ($discard = $xwiki.ssx.use('XWiki.InplaceEditing'))
    ## We can't move this to a WebJar until we have XWIKI-12788 (Introduce skin extension plugins for webjar resources).
    #set ($discard = $xwiki.jsx.use('XWiki.InplaceEditing'))
  #end
#end
{{/html}}
{{/velocity}}</content>
    </property>
    <property>
      <extensionPointId>org.xwiki.platform.template.header.after</extensionPointId>
    </property>
    <property>
      <name>org.xwiki.platform.template.header.after.inplaceEditing</name>
    </property>
    <property>
      <parameters/>
    </property>
    <property>
      <scope>wiki</scope>
    </property>
  </object>
  <object>
    <name>XWiki.InplaceEditing</name>
    <number>1</number>
    <className>XWiki.UIExtensionClass</className>
    <guid>13939f90-1cd4-4517-8c42-2dbeee198357</guid>
    <class>
      <name>XWiki.UIExtensionClass</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <async_cached>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_cached</name>
        <number>3</number>
        <prettyName>Cached</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_cached>
      <async_context>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>1</multiSelect>
        <name>async_context</name>
        <number>4</number>
        <prettyName>Context elements</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>5</size>
        <unmodifiable>0</unmodifiable>
        <values>doc.reference=Document|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.parameters=Request parameters|request.url=Request URL|request.wiki=Request wiki|user=User|wiki=Wiki</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </async_context>
      <async_enabled>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_enabled</name>
        <number>2</number>
        <prettyName>Asynchronous rendering</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_enabled>
      <content>
        <disabled>0</disabled>
        <editor>Text</editor>
        <name>content</name>
        <number>1</number>
        <prettyName>Executed Content</prettyName>
        <rows>25</rows>
        <size>120</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </content>
      <extensionPointId>
        <disabled>0</disabled>
        <name>extensionPointId</name>
        <number>5</number>
        <prettyName>Extension Point ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </extensionPointId>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>6</number>
        <prettyName>Extension ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parameters>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>parameters</name>
        <number>7</number>
        <prettyName>Extension Parameters</prettyName>
        <rows>10</rows>
        <size>40</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </parameters>
      <scope>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>scope</name>
        <number>8</number>
        <prettyName>Extension Scope</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>wiki=Current Wiki|user=Current User|global=Global</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </scope>
    </class>
    <property>
      <async_cached>0</async_cached>
    </property>
    <property>
      <async_context/>
    </property>
    <property>
      <async_enabled>0</async_enabled>
    </property>
    <property>
      <content>{{velocity}}
{{html clean="false"}}
## Output the translation button if all the following conditions are met:
## * multilingual is on
## * we're loading the original document version
## * the original document version has a locale specified (it doesn't make sense to translate technical documents)
## * the current UI locale doesn't match the original document locale
#if ($xwiki.isMultiLingual() &amp;&amp; $tdoc.realLocale == $doc.realLocale &amp;&amp; "$!doc.realLocale" != ''
    &amp;&amp; $doc.realLocale != $xcontext.locale)
  #set ($url = $doc.getURL('edit', $escapetool.url({'language': $xcontext.locale})))
  #set ($hint = $services.localization.render('edit.inplace.page.translate.hint',
    [$xcontext.locale.getDisplayName($xcontext.locale)]))
  ## We show the translate button only while editing in-place.
  &lt;div class="btn-group hidden" id="tmTranslate"&gt;
    &lt;a class="btn btn-default" href="$url" role="button" title="$escapetool.xml($hint)"&gt;
      $services.icon.renderHTML('translate')
      &lt;span class="btn-label"&gt;$escapetool.xml($services.localization.render('edit.inplace.page.translate'))&lt;/span&gt;
    &lt;/a&gt;
  &lt;/div&gt;
#end
{{/html}}
{{/velocity}}</content>
    </property>
    <property>
      <extensionPointId>org.xwiki.plaftorm.menu.content</extensionPointId>
    </property>
    <property>
      <name>org.xwiki.plaftorm.menu.content.translate</name>
    </property>
    <property>
      <parameters>order=5000</parameters>
    </property>
    <property>
      <scope>wiki</scope>
    </property>
  </object>
</xwikidoc>
