<?xml version="1.0" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc version="1.2" reference="CKEditor.VelocityMacros" locale="">
  <web>CKEditor</web>
  <name>VelocityMacros</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <creationDate>1464773839000</creationDate>
  <parent>CKEditor.WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <date>1465811713000</date>
  <contentUpdateDate>1465575055000</contentUpdateDate>
  <version>1.1</version>
  <title/>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>true</hidden>
  <content>{{velocity output="false"}}
#macro (convert $text $toHTML $fromHTML $stripHTMLEnvelope)
  #set ($sourceSyntax = $request.sourceSyntax)
  #if ("$!sourceSyntax" != '')
    #set ($sourceSyntax = $services.rendering.resolveSyntax($sourceSyntax))
  #end
  #if (!$sourceSyntax)
    #set ($sourceSyntax = $doc.syntax)
  #end
  #if ($toHTML)
    #set ($source = {
      'documentReference': $doc.documentReference,
      'syntax': $sourceSyntax
    })
    #if ($fromHTML)
      #set ($source.html = $text)
    #else
      #set ($source.content = $text)
    #end
    #if ($stripHTMLEnvelope)
      ## Don't wrap the rendered content with the HTML and BODY tags. This is needed when the HTML fragment is injected
      ## directly in the current page, e.g. when CKEditor is used in-line (no iframe). We still need to send back the
      ## required style sheets and JavaScript files because some of them might not be available in the target page, e.g.
      ## when a macro is inserted and it needs resource files not available on every page.
      #initRequiredSkinExtensions()
      #set ($output = "#getRenderedContent($source)$!html")
      #set ($discard = $response.setHeader('X-XWIKI-HTML-HEAD', "#getRequiredSkinExtensions()"))
    #else
      ## Returns a full HTML page, including the HEAD tag with the style sheets and possibly the JavaScript includes.
      ## This is needed when the edited content is loaded in an iframe, which is the case when CKEditor replaces a text
      ## area (classical editor).
      #set ($output = "#renderContentSheet($source)")
    #end
  #else
    #set ($output = $services.wysiwyg.fromAnnotatedXHTML($text, $sourceSyntax.toIdString()))
    #if ("$!output" == '' &amp;&amp; $output != '')
      ## $output is null, probably because $services.wysiwyg.fromAnnotatedXHTML() is not available (before 10.10RC1)
      #set ($xdom = $services.rendering.parse($text, 'xhtml/1.0'))
      #set ($output = $services.rendering.render($xdom, $sourceSyntax.toIdString()))
    #end
  #end
  #if ("$!output" != '' || $output == '')
    $output##
  #else
    ## The output is null so an exception must have been thrown.
    $response.sendError(500)
  #end
#end

#macro (renderContentSheet $source)
  ## The $source variable is used inside the content sheet.
  #set ($output = $services.wysiwyg.render('CKEditor.ContentSheet'))
  #if ("$!output" == '' &amp;&amp; $output != '')
    ## $output is null, probably because $services.wysiwyg.render() is not available (before 7.4.1)
    #set ($output = $xwiki.getDocument('CKEditor.ContentSheet').getRenderedContent())
    #set ($skinExtensionHooks = {
      'ssx': 'CssSkinExtensionPlugin',
      'ssfx': 'CssSkinFileExtensionPlugin',
      'ssrx': 'CssResourceSkinExtensionPlugin'
    })
    #foreach ($entry in $skinExtensionHooks.entrySet())
      #set ($output = $output.replace("&lt;!-- com.xpn.xwiki.plugin.skinx.$entry.value --&gt;",
        $xwiki.get($entry.key).importString))
    #end
  #end
  ## Unescape {{ which happened in CKEditor.ContentSheet for protecting the {{html}} macro.
  $!output.replace('&amp;amp;#123;&amp;amp;#123;', '{{')##
#end

#macro (getRenderedContent $source)
  #if ($source.html)
    #set ($html = $services.wysiwyg.parseAndRender($source.html, $source.syntax, $source.documentReference))
    #if ("$!html" == '' &amp;&amp; $html != '')
      ## Before XWiki 11.9RC1 (see XWIKI-16737)
      #set ($html = $services.wysiwyg.parseAndRender($source.html, $source.syntax.toIdString()))
    #end
  #else
    #set ($html = $services.wysiwyg.toAnnotatedXHTML($source.content, $source.syntax, $source.documentReference))
    #if ("$!html" == '' &amp;&amp; $html != '')
      ## Before XWiki 11.9RC1 (see XWIKI-16737)
      #set ($html = $services.wysiwyg.toAnnotatedXHTML($source.content, $source.syntax.toIdString()))
    #end
  #end
  #if ("$!html" == '')
    ## Prevent Firefox from inserting bogus whitespace when the text area is empty.
    ## CKEDITOR-185: Whitespace is generated in Firefox when creating a page without typing the content
    #set ($html = '&lt;p&gt;&lt;/p&gt;')
  #end
#end

#macro (importCSS $groupId $artifactId $path $evaluate)
  #set ($url = $services.webjars.url("$groupId:$artifactId", $path, {'evaluate': $evaluate}))
  #set ($discard = $xwiki.linkx.use($url, {'type': 'text/css', 'rel': 'stylesheet'}))
#end

#macro (importCKEditorCSS $path $evaluate)
  #importCSS('org.xwiki.contrib' 'application-ckeditor-webjar' $path $evaluate)
#end

#macro (importCKEditorResources)
  #set ($discard = $xwiki.ssx.use('CKEditor.EditSheet'))
  #set ($discard = $xwiki.jsx.use('CKEditor.EditSheet'))
  #importCKEditorCSS('plugins/xwiki-resource/resourcePicker.min.css' true)
  #importCKEditorCSS('plugins/xwiki-macro/macroWizard.min.css' true)
  ## Tree styles needed for the document/attachment tree picker.
  #set ($discard = $xwiki.linkx.use($services.webjars.url('org.xwiki.platform:xwiki-platform-tree-webjar', 'tree.min.css',
    {'evaluate': true}), {'type': 'text/css', 'rel': 'stylesheet'}))
  #set ($discard = $xwiki.linkx.use($services.webjars.url('org.xwiki.platform:xwiki-platform-tree-webjar',
    'finder.min.css', {'evaluate': true}), {'type': 'text/css', 'rel': 'stylesheet'}))
#end

#macro (ckeditor $parameters)
  #importCKEditorResources
  #set ($sourceDocumentReference = $parameters.attributes.get('data-sourceDocumentReference'))
  ## Use the current document as source document, if possible, because it may contain unsaved changes (e.g. changes
  ## coming from a template specified in the URL or from other URL parameters). This is important for instance in order
  ## to ensure that for new (unsaved) documents we use the syntax that has been copied from the template and not the
  ## default wiki syntax.
  #if (!$sourceDocumentReference || $sourceDocumentReference.equals($tdoc.documentReference))
    #set ($sourceDocument = $tdoc)
    #set ($sourceDocumentReference = $tdoc.documentReference)
  #else
    #set ($sourceDocument = $xwiki.getDocument($sourceDocumentReference))
  #end
  #set ($escapedName = $escapetool.xml($parameters.attributes.name))
  &lt;input value="$!escapedName" name="RequiresHTMLConversion" type="hidden"/&gt;
  &lt;input value="$!escapetool.xml($sourceDocument.syntax.toIdString())" name="$!{escapedName}_syntax" type="hidden"/&gt;
  ## Chrome doesn't cache the enabled/disabled state of the form fields so we must store this state in the value of
  ## another form field. For instance, the enabled/disabled state of the RequiresHTMLConversion hidden input
  ## determines which editor mode (WYSIWYG vs. Source) is loaded initially.
  ## See CKEDITOR-34: Wiki syntax gets escaped when you click "Back" in the browser
  &lt;input value="" name="$!{escapedName}_cache" type="hidden" class="cache"/&gt;
  ## Verify if the office import feature is supported.
  ##
  ## It's not enough to check if the Office server is connected because the 'importOfficeAttachment' API is available
  ## only since XWiki 9.8 (see XWIKI-14739) while the CKEditor Integration extension can be installed on older versions
  ## of XWiki where the users won't be able to import office documents from the CKEditor even if the Office server is
  ## connected. On these older versions the users will have to use the Create Page dialog with the Page from Office
  ## option.
  ##
  ## We check if the 'importOfficeAttachment' API is available by trying to import an attachment that doesn't exist
  ## using the Office Viewer macro, which should output an error message saying that the attachment doesn't exist. This
  ## way the Office server is not actually called so there's no risk of slowing down or blocking the CKEditor load (see
  ## CKEDITOR-294).
  #set ($missingAttachmentReference = $services.model.resolveAttachment('CKEditor.OfficeImporter@doesNotExist.txt'))
  #set ($officeServerConnected = $services.officemanager.isConnected())
  #if ("$!officeServerConnected" == '')
    ## Before XWiki 12.3 and 11.10.5
    #set ($officeServerConnected = $services.officemanager.serverState == 'Connected')
  #end
  #set ($officeImporterSupported = $officeServerConnected &amp;&amp;
    "$!services.wysiwyg.importOfficeAttachment($missingAttachmentReference, {'useOfficeViewer': true})" != '')
  #set ($discard = $parameters.attributes.putAll({
    'class': "$!parameters.attributes.get('class') ckeditor-textarea loading",
    'spellcheck': false,
    'data-sourceDocumentSyntax': $sourceDocument.syntax.toIdString(),
    'data-officeImporterSupported': $officeImporterSupported
  }))
  &lt;textarea
    #foreach ($entry in $parameters.attributes.entrySet())
      $entry.key="$!escapetool.xml($entry.value)"
    #end
  ## We render the content sheet at the end because the edited content can overwrite the variables used by this macro.
  #set ($source = {
    'documentReference': $sourceDocumentReference,
    'syntax': $sourceDocument.syntax,
    'content': $parameters.content
  })
  #set ($content = "#renderContentSheet($source)")
  &gt;$!escapetool.xml($content)&lt;/textarea&gt;
#end

#macro (displayCKEditorConfigProperty $configDoc $propName $action)
  &lt;dt&gt;
    &lt;label&gt;$configDoc.displayPrettyName($propName)&lt;/label&gt;
    &lt;span class="xHint"&gt;$services.localization.render("CKEditor.ConfigClass_${propName}.hint")&lt;/span&gt;
  &lt;/dt&gt;
  &lt;dd&gt;#displayCKEditorConfigPropertyValue($configDoc $propName $action)&lt;/dd&gt;
#end

#macro (displayCKEditorConfigBooleanProperty $configDoc $propName $action)
  &lt;dt&gt;
    &lt;label&gt;
      #displayCKEditorConfigPropertyValue($configDoc $propName $action)
      $configDoc.displayPrettyName($propName)
    &lt;/label&gt;
    &lt;span class="xHint"&gt;$services.localization.render("CKEditor.ConfigClass_${propName}.hint")&lt;/span&gt;
  &lt;/dt&gt;
  &lt;dd&gt;&lt;/dd&gt;
#end

#macro (displayCKEditorConfigPropertyValue $configDoc $propName $action)
  #set ($output = $configDoc.display($propName, $action))
  #set ($output = $stringtool.removeStart($output, '{{html clean="false" wiki="false"}}'))
  #set ($output = $stringtool.removeEnd($output, '{{/html}}'))
  $output
#end

#macro (displayCKEditorConfig $configDoc $action)
  #set ($discard = $xwiki.ssx.use('CKEditor.ConfigSheet'))
  #set ($discard = $xwiki.jsx.use('CKEditor.ConfigSheet'))
  #importCSS('org.webjars' 'bootstrap-select' 'css/bootstrap-select.min.css')
  &lt;dl class="ckeditor-config#if ($configDoc.isNew()) new#end"&gt;
    #displayCKEditorConfigProperty($configDoc 'removePlugins' $action)
    #displayCKEditorConfigProperty($configDoc 'removeButtons' $action)
    #displayCKEditorConfigBooleanProperty($configDoc 'linkShowAdvancedTab' $action)
    #displayCKEditorConfigBooleanProperty($configDoc 'linkShowTargetTab' $action)
    #displayCKEditorConfigBooleanProperty($configDoc 'loadJavaScriptSkinExtensions' $action)
    &lt;dt&gt;
      &lt;label&gt;$configDoc.displayPrettyName('advanced')&lt;/label&gt;
      &lt;span class="xHint"&gt;$services.localization.render('CKEditor.ConfigClass_advanced.hint',
        ['&lt;a href="http://docs.ckeditor.com/#!/api/CKEDITOR.config"&gt;', '&lt;/a&gt;'])&lt;/span&gt;
    &lt;/dt&gt;
    &lt;dd&gt;#displayCKEditorConfigPropertyValue($configDoc 'advanced' $action)&lt;/dd&gt;
  &lt;/dl&gt;
#end

#macro (initRequiredSkinExtensions)
  #set ($requiredSkinExtensions = $collectiontool.orderedMap)
  #if ("$!requiredSkinExtensions" == '')
    ## For XWiki versions older than 12.1RC1 fallback on the old $collectionstool (available since 4.0M1).
    #set ($requiredSkinExtensions = $collectionstool.orderedMap)
  #end
  ## Save the import string for each skin extension plugin in order to be able to remove the always used extensions
  ## (they are aready available on the edit page so there's no need to load them).
  #foreach ($pluginName in ['ssrx', 'ssfx', 'ssx', 'linkx', 'jsrx', 'jsfx', 'jsx'])
    #set ($discard = $requiredSkinExtensions.put($pluginName, $xwiki.get($pluginName).importString))
  #end
#end

#macro (getRequiredSkinExtensions)
  #foreach ($entry in $requiredSkinExtensions.entrySet())
    #set ($importString = $xwiki.get($entry.key).importString)
    ## Remove the always used skin extensions, keep only those that have been requested by the macro parameter pickers.
    $!stringtool.removeStart($importString, $entry.value).trim()##
  #end
#end

#macro (defineSortTool $sortToolVariable)
  #set ($checkedExtension = "org.xwiki.commons:xwiki-commons-velocity")
  ## Because of an API collision, $collectionstool has been replaced by $collectiontool in XCOMMONS-1861
  #if ($services.extension.core.getCoreExtension($checkedExtension).id.version.compareTo("12.1-SNAPSHOT") &gt;= 0)
    #setVariable ($sortToolVariable, $collectiontool)
  ## With the upgrade of Velocity $sorttool has been replaced by $collectionstool (XCOMMONS-1296)
  #elseif ($services.extension.core.getCoreExtension($checkedExtension).id.version.compareTo("12.0-SNAPSHOT") &gt;= 0)
    #setVariable ($sortToolVariable, $collectionstool)
  ## Old API for sorting was $sorttool
  #else
    #setVariable ($sortToolVariable, $sorttool)
  #end
#end

#defineSortTool("$resolvedSortTool")
{{/velocity}}</content>
</xwikidoc>
