<?xml version="1.0" encoding="UTF-8"?>

<xwikidoc>
  <web>XWiki</web>
  <name>ExtensionManagerMacros</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <parent>XWiki.AdminSheet</parent>
  <creator>xwiki:XWiki.Admin</creator>
  <author>xwiki:XWiki.Admin</author>
  <customClass/>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <creationDate>1321509118000</creationDate>
  <date>1344433141000</date>
  <contentUpdateDate>1344433141000</contentUpdateDate>
  <version>1.1</version>
  <title/>
  <template/>
  <defaultTemplate/>
  <validationScript/>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>true</hidden>
  <object>
    <class>
      <name>XWiki.JavaScriptExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators> ,|</separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <disabled>0</disabled>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators> ,|</separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage=Always on this page|onDemand=On demand|always=Always on this wiki</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <name>XWiki.ExtensionManagerMacros</name>
    <number>0</number>
    <className>XWiki.JavaScriptExtension</className>
    <guid>ce6647d0-aa85-4972-a890-a76e852f7be6</guid>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>var XWiki = (function (XWiki) {
// Start XWiki augmentation.
/**
 * Enhances the behaviour of an extension.
 */
XWiki.ExtensionBehaviour = Class.create({
  initialize : function (container) {
    // Make sure the extension is not already initialized.
    this.finalize();

    this.container = container;

    // The extension links (links to extension dependencies, links inside log messages) use the 'get' action when
    // extension details are loaded asynchronously so we need to replace it with 'view' or 'admin' action, depending
    // whether the extension is displayed alone or in the administration.
    this._fixExtensionLinks();

    // Handle extension details.
    this._enhanceShowDetailsBehaviour();

    // Asynchronous fetch of install/uninstall plan.
    this._enhanceInstallBehaviour();
    this._enhanceUninstallBehaviour();

    // Enhances the behaviour of the extension details menu (Description/Dependencies/Progress).
    this._enhanceMenuBehaviour();

    // Enhances the behaviour of the Progress section.
    this._enhanceProgressBehaviour();

    // Refresh the extension display if the extension has a job running.
    this._maybeScheduleRefresh();
  },

  /**
   * Releases the event listeners and detaches the extension.
   */
  finalize : function() {
    this.container &amp;&amp; this.container.remove();
    this.container = undefined;
  },

  /**
   * Returns the URL of the service used to retrieve extension details and to install/uninstall extensions.
   */
  _getServiceURL : function(serviceDocument) {
    if (serviceDocument) {
      serviceDocument = XWiki.getResource(serviceDocument);
      serviceDocument = new XWiki.Document(serviceDocument.name, serviceDocument.space, serviceDocument.wiki);
    } else {
      serviceDocument = XWiki.currentDocument;
    }
    return serviceDocument.getURL('get');
  },

  /**
   * Submit a form asynchronously.
   */
  _submit : function(event, ajaxRequestParameters) {
    event.stop();

    // Prepare the data for the AJAX call.
    var form = event.element().form;
    var formData = new Hash(form.serialize({submit: event.element().name}));

    // Disable the form to prevent it from being re-submitted while we wait for the response.
    form.disable();

    // Default AJAX request parameters.
    var defaultAJAXRequestParameters = {
      parameters : formData,
      onFailure : function (response) {
        var failureReason = response.statusText;
        if (response.statusText == '' /* No response */ || response.status == 12031 /* In IE */) {
          failureReason = 'Server not responding';
        }
        new XWiki.widgets.Notification("$msg.get('extensions.info.fetch.failed')" + failureReason, "error");
      },
      on0 : function (response) {
        response.request.options.onFailure(response);
      },
      onComplete : function() {
        // Re-enable the form.
        form.enable();
      }
    }

    // Inject a reference to the (cloned) default AJAX request parameters to be able
    // to access the defaults even when they are overwritten by the provided values.
    defaultAJAXRequestParameters.defaultValues = Object.clone(defaultAJAXRequestParameters);

    // Launch the AJAX call.
    new Ajax.Request(this._getServiceURL(formData.get('section')), Object.extend(defaultAJAXRequestParameters, ajaxRequestParameters));
  },

  _update : function(html) {
    // Save the current state of the extension display so that it can be restored afterwards.
    var extensionBody = this.container.down('.extension-body');
    var extensionBodyHidden = !extensionBody || extensionBody.hasClassName('hidden');
    var currentMenuItem = this.container.down('.innerMenu li a.current');
    currentMenuItem &amp;&amp; (this._previouslySelectedMenuItem = currentMenuItem.getAttribute('href'));
    // Replace the current extension container element with the one that was just fetched.
    this.container.addClassName('hidden');
    this.container.insert({after : html});
    // Attach behaviour to the new element.
    this.initialize(this.container.next());
    // Restore the state of the extension display.
    extensionBodyHidden &amp;&amp; this._onToggleShowHideDetails({
      stop : function() {},
      element : function() {return this.container.down('input[name="hideDetails"]')}.bind(this)
    });
  },

  /**
   * Load the extension details asynchronously.
   */
  _onShowDetails : function(event) {
    // Launch the AJAX call to fetch extension details.
    this._submit(event, {
      onCreate : function() {
        // Don't panic, the content is loading.
        this.container.insert({bottom: new Element('div', {'class' : 'extension-body loading'})});
      }.bind(this),
      onSuccess : function(response) {
        this._update(response.responseText);
      }.bind(this),
      onComplete : function(response) {
        response.request.options.defaultValues.onComplete(response);
        // Remove the loading marker if it's still there (i.e. fetching failed).
        var loadingMarker = this.container.down('.extension-body.loading');
        loadingMarker &amp;&amp; loadingMarker.remove();
      }.bind(this)
    });
  },

  /**
   * Enables the asynchronous loading of extension details and the show/hide extension details toggle.
   */
  _enhanceShowDetailsBehaviour : function() {
    var showDetailsButton = this.container.down('input[name="actionShowDetails"]');
    if (showDetailsButton) {
      // Load the extension details asynchronously.
      showDetailsButton.observe('click', this._onShowDetails.bindAsEventListener(this));
    } else {
      showDetailsButton = this.container.down('input[name="showDetails"]');
      if (!showDetailsButton) {
        return;
      }
      // Show/hide extension details toggle.
      showDetailsButton = showDetailsButton.up();
      var hideDetailsButton = this.container.down('input[name="hideDetails"]').up();
      showDetailsButton.__otherButton = hideDetailsButton;
      hideDetailsButton.__otherButton = showDetailsButton;
      this.container.select('.visibilityAction').invoke('observe', 'click', this._onToggleShowHideDetails.bindAsEventListener(this));
      showDetailsButton.remove();
    }
  },

  /**
   * Toggles the visibility of the extension details.
   */
  _onToggleShowHideDetails : function(event) {
    event.stop();
    var button = event.element().up('span');
    this.container.down('.extension-body').toggleClassName('hidden');
    button.replace(button.__otherButton);
  },

  /**
   * Enhances the behaviour of the install button: computes the install plan asynchronously.
   */
  _enhanceInstallBehaviour : function() {
    var installButton = this.container.down('input[name="actionInstall"]');
    installButton &amp;&amp; installButton.observe('click', this._startJob.bindAsEventListener(this));
    var installGloballyButton = this.container.down('input[name="actionInstallGlobally"]');
    installGloballyButton &amp;&amp; installGloballyButton.observe('click', this._startJob.bindAsEventListener(this));
  },

  /**
   * Enhances the behaviour of the uninstall button: computes the uninstall plan asynchronously.
   */
  _enhanceUninstallBehaviour : function() {
    var uninstallButton = this.container.down('input[name="actionUninstall"]');
    uninstallButton &amp;&amp; uninstallButton.observe('click', this._startJob.bindAsEventListener(this));
    var uninstallGloballyButton = this.container.down('input[name="actionUninstallGlobally"]');
    uninstallGloballyButton &amp;&amp; uninstallGloballyButton.observe('click', this._startJob.bindAsEventListener(this));
  },

  /**
   * Indicate to the user that a job has been started.
   */
  _onBeforeStartJob : function() {
    // Check if the extension details have been fetched.
    var extensionBody = this.container.down('.extension-body');
    if (extensionBody) {
      // Make sure the extension details are visible.
      extensionBody.hasClassName('hidden') &amp;&amp; this._onToggleShowHideDetails({
        stop : function() {},
        element : function() {return this.container.down('input[name="showDetails"]')}.bind(this)
      });
      // Prepare the progress section: create one if it is missing, clear its contents otherwise.
      var progressSection = this._prepareProgressSectionForLoading();
      // Activate the progress section.
      this._activateMenuItem(extensionBody.down('.innerMenu li a[href="#' + progressSection.previous().id + '"]'));
    } else {
      this.container.insert({bottom: new Element('div', {'class' : 'extension-body loading'})});
    }
  },

  /**
   * This method is called before a request related to the progress section is made. Creates an empty
   * progress section if none is found, otherwise hides its contents and displays the loading animation.
   * @see #_restoreProgressSection()
   */
  _prepareProgressSectionForLoading : function() {
    // Check if the progress section is available.
    var progressSection = this.container.down('.extension-body-progress');
    if (!progressSection) {
      // Add an empty progress section.
      var lastSection = this.container.select('.extension-body-section').last();
      progressSection = new Element('div', {'class': 'extension-body-progress extension-body-section loading'});
      lastSection.insert({after: progressSection});
      // Add the section anchor.
      var progressSectionAnchor = 'extension-body-progress' + lastSection.previous().id.substr($w(lastSection.className)[0].length);
      lastSection.insert({after: new Element('div', {id: progressSectionAnchor})});
      // Add the progress menu.
      this.container.down('.innerMenu').insert('&lt;li&gt;&lt;span class="wikilink"&gt;&lt;a href="#' + progressSectionAnchor + '"&gt;$msg.get('extensions.info.category.progress')&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;');
    } else if (progressSection.down('.extension-log-item-loading')) {
      // Just hide the question that has been answered if there is any progress item loading.
      progressSection.down('form').hide();
    } else {
      // Hide all the contents of the progress section and display the loading animation.
      progressSection.childElements().invoke('hide');
      progressSection.addClassName('loading');
    }
    return progressSection;
  },

  /**
   * Removes the loading markers if the request for starting an Extension Manager job failed.
   */
  _onAfterStartJob : function(response) {
    response.request.options.defaultValues.onComplete(response);
    // Remove the loading markers if they are still present (i.e. request failed).
    var extensionBodyLoading = this.container.down('.extension-body.loading');
    if (extensionBodyLoading) {
      extensionBodyLoading.remove();
    } else {
      this._restoreProgressSection();
    }
  },

  /**
   * This method is called when a request related to the progress section fails. Removes the loading
   * animation and restores the previous contents of the progress section is they were saved.
   * @see #_prepareProgressSectionForLoading()
   */
  _restoreProgressSection : function() {
    var progressSection = this.container.down('.extension-body-progress');
    if (progressSection) {
      // Show the contents of the progress section and remove the loading animation.
      progressSection.childElements().invoke('show');
      progressSection.removeClassName('loading');
    }
  },

  /**
   * Starts an Extension Manager asynchronous job. Examples of Extension Manager jobs are: compute install plan, install.
   */
  _startJob : function(event) {
    // Launch the AJAX call to start the asynchronous job.
    this._submit(event, {
      onCreate : this._onBeforeStartJob.bind(this),
      onSuccess : function(response) {
        this._update(response.responseText);
      }.bind(this),
      onComplete : this._onAfterStartJob.bind(this)
    });
  },

  /**
   * Redisplays the extension using updated information from the server.
   */
  _refresh : function() {
    // Prepare the data for the AJAX call.
    var form = this.container.down('.extension-actions').up('form');
    var formData = new Hash(form.serialize({submit: false}));

    // Launch the AJAX call.
    new Ajax.Request(this._getServiceURL(formData.get('section')), {
      parameters : formData,
      onSuccess : function(response) {
        this._update(response.responseText);
      }.bind(this),
      onFailure : this._maybeScheduleRefresh.bind(this)
    });
  },

  /**
   * Schedule a new refresh if the extension has a job running.
   */
  _maybeScheduleRefresh : function() {
    this.container.hasClassName('extension-item-loading') &amp;&amp; !this.container.down('input[name="confirm"]') &amp;&amp; this._refresh.bind(this).delay(1);
  },

  /**
   * Enhances the behaviour of the extension details menu (Description/Dependencies/Progress).
   */
  _enhanceMenuBehaviour : function() {
    var menuItemSelector = '.innerMenu li a';
    // Expand the current menu item.
    var currentMenuItem = this.container.down(menuItemSelector + '.current');
    if (!currentMenuItem) {
      // Expand the previously selected menu item, if specified, to preserve the state of the extension display.
      if (this._previouslySelectedMenuItem) {
        currentMenuItem = this.container.down(menuItemSelector + '[href="' + this._previouslySelectedMenuItem + '"]');
      } else {
        // Expand the first menu item.
        currentMenuItem = this.container.down(menuItemSelector);
      }
    }
    if (currentMenuItem) {
      this._activateMenuItem(currentMenuItem);
      // Make the activation of menu items persistent.
      this.container.select(menuItemSelector).invoke('observe', 'click', function(event) {
        event.stop();
        this._activateMenuItem(event.element());
      }.bindAsEventListener(this));
    }
  },

  _activateMenuItem : function(menuItem) {
    // Hide all sections (each section is associated with a menu item).
    this.container.select('.extension-body-section').invoke('setStyle', {'display' : 'none'});
    // Unmark the currently active menu item.
    var currentMenuItem = this.container.down('.innerMenu li a.current');
    if (currentMenuItem) {
       currentMenuItem.removeClassName('current');
    }
    // Display the section associated with the given menu item (the menu item that was clicked).
    // (the href attribute is expected be "#id-of-an-anchor-placed-before-the-section-to-display)
    $(menuItem.getAttribute('href').substring(1)).next('.extension-body-section').setStyle({'display' : 'block'});
    // Mark the given menu item as active (i.e. select the menu item that was clicked).
    menuItem.addClassName('current');
  },

  /**
   * Fix the extension links (links to extension dependencies, links inside log messages) when the extension details
   * are loaded asynchronously because they use the 'get' action (specific to AJAX requests) instead of the 'view' or
   * 'admin' action (depending whether the extension is displayed alone or in the administration section).
   */
  _fixExtensionLinks : function() {
    this.container.select("a.extension-link").each(function (link) {
      var action = XWiki.currentDocument.page == 'XWikiPreferences' ? 'admin' : 'view';
      var queryString = link.getAttribute('href').replace(/.*\?/, '');
      link.setAttribute('href', XWiki.currentDocument.getURL(action, queryString));
    });
  },

  /**
   * Enhances the behaviour of the Progress section within the extension details.
   */
  _enhanceProgressBehaviour : function() {
    // Toggle stacktrace display in extension log.
    this.container.select('.extension-log-item').each(function (logItem) {
      var stacktrace = logItem.down('.stacktrace');
      if (stacktrace) {
        // Hide the stacktrace by default.
        stacktrace.toggle();
        // Show the stacktrace when the log message is clicked.
        var logMessage = logItem.down('p');
        logMessage.setStyle({"cursor": "pointer"});
        logMessage.observe('click', function() {
          stacktrace.toggle();
        });
      }
    });
    // Execute Extension Manager jobs asynchronously.
    var confirmJobButton = this.container.down('input[name="confirm"]');
    confirmJobButton &amp;&amp; confirmJobButton.observe('click', this._startJob.bindAsEventListener(this));
    // Compute the changes asynchronously when there is a merge conflict.
    var diffButton = this.container.down('input[name="diff"]');
    diffButton &amp;&amp; diffButton.observe('click', this._startJob.bindAsEventListener(this));
  }
});


/**
 * Enhances the behaviour of the extension search form.
 */
XWiki.ExtensionSearchFormBehaviour = Class.create({
  initialize : function () {
    this._enhanceSimpleSearch();
    this._enhanceAdvancedSearch();
  },

  _enhanceSimpleSearch : function() {
    var simpleSearchBox = $('extension-search-simple');
    if (!simpleSearchBox) {
      return;
    }
    // Submit the search form whenever the user selects a different repository.
    $('extensionSearchRepositoryList').observe('change', function(event) {
      // Make sure we don't submit the search tip.
      $('extensionSearchInput').focus();
      // Defer the submit so that the search input is properly focused.
      var form = event.element().form;
      form.submit.bind(form).defer();
    }.bindAsEventListener(this));
  },

  _enhanceAdvancedSearch : function() {
    var advancedSearchBox = $('extension-search-advanced');
    if (!advancedSearchBox) {
      return;
    }
    var advancedSearchTrigger = advancedSearchBox.down('legend a');//ry :)
    if (advancedSearchTrigger) {
      var target = advancedSearchTrigger.up('legend').next();
      if (target) {
        advancedSearchTrigger.observe('click', function(event) {
          event.stop();
          advancedSearchTrigger.blur();
          target.toggleClassName('hidden');
          advancedSearchTrigger.toggleClassName('expanded');
        });
        var cancelTrigger = target.down('a.actionCancel');
        if (cancelTrigger) {
          cancelTrigger.observe('click', function(event) {
            event.stop();
            cancelTrigger.up('form').select('input[type=text]').each(function(input) {
              input.value = '';
            });
            advancedSearchTrigger.click();
          });
        }
      }
    }
  }
});


function init() {
  new XWiki.ExtensionSearchFormBehaviour();
  $$('.extension-item').each(function (extension) {
    new XWiki.ExtensionBehaviour(extension);
  });
  return true;
}

// When the document is loaded, trigger the Extension Manager form enhancements.
(XWiki.domIsLoaded &amp;&amp; init()) || document.observe("xwiki:dom:loaded", init);

// End XWiki augmentation.
return XWiki;
}(XWiki || {}));</code>
    </property>
    <property>
      <name>Code</name>
    </property>
    <property>
      <parse>1</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <class>
      <name>XWiki.StyleSheetExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators> ,|</separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <disabled>0</disabled>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators> ,|</separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage=Always on this page|onDemand=On demand|always=Always on this wiki</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <name>XWiki.ExtensionManagerMacros</name>
    <number>0</number>
    <className>XWiki.StyleSheetExtension</className>
    <guid>9a7ab38c-4990-415a-beed-6968710f3b02</guid>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>#template('colorThemeInit.vm')
.extension-item {
  border-color: $theme.borderColor $theme.pageContentBackgroundColor $theme.pageContentBackgroundColor $theme.borderColor;
  border-style: solid solid solid;
  border-width: 1px 4px 1px 1px;
  display: block;
  -moz-box-shadow: 1px 0 0 $theme.borderColor;
  -webkit-box-shadow:  1px 0 0 $theme.borderColor;
  box-shadow:  1px 0 0 $theme.borderColor;
  margin-right: 1px;
  position: relative;
}
.extension-item &gt; * {
  padding: 0.8em 1em 1em 2.7em;
}
.extension-item:last-of-type {
  border-bottom-color: $theme.borderColor;
}

.extension-name {
  color: $theme.titleColor;
  font-size: 1.2em;
  font-weight: 700;
  border: none;
  background: none no-repeat scroll 0.2em 0.3em transparent;
  margin: 0 0 0 -1.8em;
  padding: 2px 0 2px 1.8em;
}

.extension-version, .extension-namespace {
  color: $theme.textSecondaryColor;
  margin-left: 1em;
  font-weight: normal;
  font-size: .8em;
}

.extension-item:hover .extension-header {
  background-color: $theme.highlightColor;
}
.extension-header .buttonwrapper {
  margin: 0 0 0 5px;
}

.extension-header-right {
  float: right;
  text-align: right;
}

.extension-status {
  font-size: 0.8em;
}
.extension-header-right .extension-status {
  margin: -2em 0 1em;
}

.extension-authors {
  color: $theme.textSecondaryColor;
  font-size: .9em;
}

.extension-item-core .extension-status, .extension-item-installed .extension-status,
/* We have to duplicate the selectors to force the style to be applied to extension dependencies, which are nested inside extension display. */
.extension-item .extension-item-core .extension-status, .extension-item .extension-item-installed .extension-status {
  color: $theme.notificationSuccessColor;
}
.extension-item-remote-core .extension-status, .extension-item-remote-installed .extension-status,
.extension-item .extension-item-remote-core .extension-status, .extension-item .extension-item-remote-installed .extension-status {
  color: $theme.notificationWarningColor;
}
/* This applies only to dependencies. */
.extension-item-remote-core-incompatible .extension-status, .extension-item-remote-installed-incompatible .extension-status {
  color: $theme.notificationErrorColor;
}

.extension-description {
  font-size: .9em;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.extension-body {
  border: 1px dotted $theme.borderColor;;
  padding: 0 .8em .8em 1.8em !important;
  margin: 0 1em 1em;
}
.extension-body.loading {
  padding: 16px !important;
}

*[id^="extension-body-"]:target {
  display: none;
}
*[class^="extension-body-"] {
  display: none;
  font-size: 0.9em;
  /* Make sure we have space for the loading animation. */
  min-height: 16px;
}
*[id^="extension-body-"]:target + *[class^="extension-body-"] {
  display: block;
}

ul.extension-metadata {
  list-style-type: none;
  margin: 0;
}
ul.extension-metadata li {
  padding-top: 0.5em;
}

.extension-body-dependencies ul, .extension-body-progress &gt; ul {
  border-top: 1px dotted #E8E8E8;
  list-style-type: none;
  margin: 0;
}
.extension-body-dependencies li:hover, .extension-body-progress &gt; ul li:hover {
  background-color: $theme.highlightColor;
}
.dependency-item, .extension-log-item {
  background: transparent none no-repeat left;
  border-bottom: 1px dotted #E8E8E8;
  border-right: 7px solid $theme.pageContentBackgroundColor;
  padding: 0.3em 0 0.3em 20px;
  position: relative;
}
.dependency-item &gt; p, .extension-log-item &gt; p {
  margin: 0;
}
.extension-item-core .extension-name, .extension-item-remote-core .extension-name,
.dependency-item.extension-item-core, .dependency-item.extension-item-remote-core, .dependency-item.extension-item-remote-core-incompatible {
  background-image: url("$xwiki.getSkinFile('icons/silk/cog.png')");
}
.extension-item-installed .extension-name, .extension-item-remote-installed .extension-name,
.dependency-item.extension-item-installed, .dependency-item.extension-item-remote-installed, .dependency-item.extension-item-remote-installed-incompatible {
  background-image: url("$xwiki.getSkinFile('icons/silk/plugin.png')");
}
.extension-item-remote .extension-name, .dependency-item.extension-item-remote {
  background-image: url("$xwiki.getSkinFile('icons/silk/world.png')");
}
.extension-item-loading .extension-name, .dependency-item.extension-item-loading {
  background-image: url("$xwiki.getSkinFile('icons/xwiki/spinner.gif')");
}
.dependency-item.extension-item-unknown {
  background-image: url("$xwiki.getSkinFile('icons/silk/plugin_error.png')");
}
.dependency-item .extension-status {
  position: absolute;
  right: 1.5em;
}

.extension-item-core, .extension-item-installed {
  border-right-color: $theme.notificationSuccessColor;
}
.extension-item-remote-installed, .extension-item-remote-core {
  border-right-color: $theme.notificationWarningColor;
}
.extension-item-remote-core-incompatible, .extension-item-remote-installed-incompatible {
  border-right-color: $theme.notificationErrorColor;
}

.extension-diff-title {
  margin: 1.2em 0 .6em;
}
.extension-diff-options {
  margin-bottom: .6em;
}
.extension-diff-options .label {
  font-size: 0.85em;
  font-weight: 700;
  margin-right: 0.3em;
  text-transform: uppercase;
}
.extension-diff-options select {
  margin-right: 0.3em;
  width: auto;
}

.extension-body-progress &gt; ul {
  margin-top: .5em;
}
.extension-log-item {
  background-position: left .3em;
}
.extension-log-item-info {
  background-image: url("$xwiki.getSkinFile('icons/silk/information.png')");
  color: $theme.notificationInfoColor;
}
.extension-log-item-loading {
  background-image: url("$xwiki.getSkinFile('icons/xwiki/spinner.gif')");
  color: $theme.notificationInfoColor;
}
.extension-log-item-warn {
  background-image: url("$xwiki.getSkinFile('icons/silk/error.png')");
  color: $theme.notificationWarningColor;
}
.extension-log-item-error {
  background-image: url("$xwiki.getSkinFile('icons/silk/exclamation.png')");
  color: $theme.notificationErrorColor;
}
.extension-log-item .stacktrace {
  white-space: pre-wrap;
}

.extension-search-bar {
  background-color: $theme.panelCollapsedBackgroundColor;
  border: 1px solid $theme.borderColor;
  border-bottom: 0;
  color: $theme.panelCollapsedTextColor;
  font-size: .8em;
  padding: .3em 1.2em .3em .3em;
  position: relative;
}

#extension-search-simple {
  float: left;
}
#extensionSearchInput {
  background: url("$xwiki.getSkinFile('icons/xwiki/search.png')") no-repeat scroll left center $theme.pageContentBackgroundColor;
  padding-left: 18px;
  width: 340px;
}

#extensionSearchRepositoryList {
  padding: 3px;
}

#extension-search-advanced {
  float: right;
  margin: 8px 0 0;
}

#extension-search-advanced legend {
  font-size: .875em;
  margin: 0;
  border: 0 none;
  text-align: right;
}

#extension-search-advanced legend a:after {
  content: " \bb";
}
#extension-search-advanced legend a.expanded:after {
  color: transparent;
}
#extension-search-advanced-body {
  display: none;
}
#extension-search-advanced-body:target ~ div.hidden {
  display: block;
}
.extension-search-advanced-popup {
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.25);
  padding: .3em .5em;
  position: absolute;
  right: 1.2em;
  text-align: left;
  width: 40%;
  z-index: 200;
}

.innerMenu {
  color: $theme.textSecondaryColor;
  font-size: 1em;
  font-size: 0.8em;
  /*padding: 0 1.55em .1em 3.35em;*/
  padding: 0 0 .1em;
  margin: 0 0 0 0 !important;
  margin-top: -5px !important;
}
.innerMenu li {
  display: inline-block;
  sborder: 1px solid red;
  vertical-align: top;
  margin-left: -1px;
}
.innerMenu li a {
  border-radius: 5px 5px 0 0 / 3px 3px 0 0;
  border-top: 3px solid $theme.borderColor;
  display: inline-block;
  margin: 2px 2em 0 0;
  padding: 6px .5em .2em;
  position: relative;
  top: 0px;
}
.innerMenu li a:hover {
  border-radius: 5px 5px 0 0;
  border-top: 5px solid $theme.borderColor;
  margin-top: 0px;
}
.innerMenu li a.current {
  background-color: $theme.panelCollapsedBackgroundColor;
  border: 0 none;
  border-top: 5px solid $theme.panelCollapsedBackgroundColor;
  margin-top: 0;
  border-radius: 0 0 5px 5px;
  box-shadow: 3px;
}
.innerMenu li a.current:after {
  border-style: solid;
  border-color: transparent transparent  $theme.borderColor;
  border-width: 0 5px 5px 0;
  width: 0;
  display: block;
  position: absolute;
  height: 0;
  content: "";
  top: -5px;
  right: -5px;
}
.innerMenu li a.current {
  color: $theme.panelCollapsedTextColor;
  text-decoration: none;
}

.ui-progress {
  margin-top: .5em;
}

.ui-progress-bar {
  background-image:-moz-repeating-linear-gradient(-45deg, rgba(255, 255, 255, 0.2) 0, rgba(255, 255, 255, 0.2) 5px, transparent 5px, transparent 10px);
  background-repeat: repeat;
  background-color: $theme.notificationSuccessColor !important;
  background-position: left;
  -moz-animation-duration: 0.2s;
  -moz-animation-iteration-count: infinite;
  -moz-animation-name: progress-animation;
  -moz-animation-timing-function: linear;
}

@-moz-keyframes progress-animation {
  0% {background-position: -14.142px 0;}
  100% {background-position: 0px 0;}
}

.ui-progress-background {
  background-color: transparent;
  border-radius: 8px 8px 8px 8px;
  box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.3) inset, 0 1px 0 0 $theme.pageContentBackgroundColor;
  height: 8px;
}

.ui-progress-bar {
  background-color: $theme.backgroundSecondaryColor;
  border-radius: 8px 8px 8px 8px;
  height: 8px;
}

.ui-progress-bar.green {
  -webkit-box-shadow:
    inset 0 2px 9px  rgba(255,255,255,0.3),
    inset 0 -2px 6px rgba(0,0,0,0.4);
  -moz-box-shadow:
    inset 0 2px 9px  rgba(255,255,255,0.3),
    inset 0 -2px 6px rgba(0,0,0,0.4);
  box-shadow:
    inset 0 2px 9px  rgba(255,255,255,0.3),
    inset 0 -2px 6px rgba(0,0,0,0.4);

  background-image:
     -webkit-gradient(linear, 0 0, 100% 100%,
        color-stop(.25, rgba(255, 255, 255, .2)),
        color-stop(.25, transparent), color-stop(.5, transparent),
        color-stop(.5, rgba(255, 255, 255, .2)),
        color-stop(.75, rgba(255, 255, 255, .2)),
        color-stop(.75, transparent), to(transparent)
     );

  -webkit-background-size: 50px 50px;
  -moz-background-size: 50px 50px;
}

.ui-progress-bar.orange {
  /*other*/ background: -moz-repeating-linear-gradient(left top -30deg, rgba(255, 255, 255, 0.17), rgba(255, 255, 255, 0.17) 15px, rgba(255, 255, 255, 0) 15px, rgba(255, 255, 255, 0) 30px) repeat scroll 0 0%, -moz-linear-gradient(center top , #F1A165, #D09000) repeat scroll 0 0 transparent;
}

.ui-progress-bar.red {
  /*other*/ background: -moz-repeating-linear-gradient(left top -30deg, rgba(255, 255, 255, 0.17), rgba(255, 255, 255, 0.17) 15px, rgba(255, 255, 255, 0) 15px, rgba(255, 255, 255, 0) 30px) repeat scroll 0 0%, -moz-linear-gradient(center top , #F0A3A3, #F42323) repeat scroll 0 0 transparent;
}

.ui-progress-message {
  color: $theme.textSecondaryColor;
  font-size: .85em;
  line-height: inherit;
  margin: 0;
  min-width: 100px;
}</code>
    </property>
    <property>
      <name>Style</name>
    </property>
    <property>
      <parse>1</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <content>{{velocity output="false"}}
#set ($discard = $xwiki.ssx.use('ExtensionManagerMacros'))
#set ($discard = $xwiki.jsx.use('ExtensionManagerMacros'))
#set ($discard = $xwiki.ssfx.use('uicomponents/viewers/diff.css', true))

#set ($extensionManager = $services.extension)
#set ($extensionNamespace = "wiki:$xcontext.database")

#macro (displayExtensionSearchBar)
  (% class="extension-search-bar" %)(((
    {{html clean="false"}}
    ## Simple search form.
    &lt;form action="" id="extension-search-simple"&gt;
      &lt;div&gt;
        #if ($request.section)
          &lt;input type="hidden" name="section" value="$escapetool.xml($request.section)" /&gt;
        #end
        &lt;label class="hidden" for="extensionSearchInput"&gt;$msg.get('extensions.search.tip')&lt;/label&gt;
        &lt;input type="text" #if ("$!request.search" == '')class="withTip" #{end}id="extensionSearchInput" name="search" value="#if ("$!request.search" != '')$escapetool.xml($request.search)#{else}$msg.get('extensions.search.tip')#{end}" /&gt;
        &lt;label class="hidden" for="extensionSearchRepositoryList"&gt;$msg.get('extensions.search.repository.label')&lt;/label&gt;
        &lt;select id="extensionSearchRepositoryList" name="repo"&gt;
          &lt;option value=""&gt;$msg.get('extensions.search.repository.all.label')&lt;/option&gt;
          #if ($request.repo)
            #set ($selectedRepositoryId = $request.repo)
          #end
          #foreach ($repositoryId in ['core', 'installed', 'local'])
            &lt;option value="$repositoryId"#if ($selectedRepositoryId == $repositoryId) selected="selected"#end&gt;$msg.get("extensions.search.repository.${repositoryId}.label")&lt;/option&gt;
          #end
        &lt;/select&gt;
      &lt;/div&gt;
    &lt;/form&gt;
    ## Advanced search form.
    &lt;form action="" class="xform"&gt;
      &lt;fieldset id="extension-search-advanced"&gt;
        &lt;div id="extension-search-advanced-body"&gt;&lt;/div&gt;
        &lt;legend&gt;&lt;a href="#extension-search-advanced-body"&gt;$msg.get('extensions.advancedSearch.title')&lt;/a&gt;&lt;/legend&gt;
        &lt;div class="plainmessage extension-search-advanced-popup hidden"&gt;
          #if ($request.section)
            &lt;input type="hidden" name="section" value="$escapetool.xml($request.section)" /&gt;
          #end
          &lt;dl&gt;
            &lt;dt&gt;&lt;label for="advancedExtensionSearch-id"&gt;$msg.get('extensions.advancedSearch.id.label')&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input type="text" name="extensionId" id="advancedExtensionSearch-id" value="" /&gt;&lt;/dd&gt;
            &lt;dt&gt;&lt;label for="advancedExtensionSearch-version"&gt;$msg.get('extensions.advancedSearch.version.label')&lt;/label&gt;&lt;/dt&gt;
            &lt;dd&gt;&lt;input type="text" name="extensionVersion" id="advancedExtensionSearch-version" value="" /&gt;&lt;/dd&gt;
          &lt;/dl&gt;
          &lt;p&gt;
            #em_submitButton('extensions.advancedSearch.actions.submit')
            #em_linkButton('#extension-search-simple' 'extensions.advancedSearch.actions.cancel' 'actionCancel')
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/fieldset&gt;
    &lt;/form&gt;
    {{/html}}
    (% class="clearfloats" %)((()))
  )))
#end

#macro (displayExtensionName $extension)
  #set ($name = "$!{extension.name}")
  #if ($name == '')
    #set ($name = "$!{extension.id.id}")
    #if ($name.indexOf(':') &gt;= 0)
      #set ($name = $name.substring($mathtool.add($name.indexOf(':'), 1)))
    #end
  #end
  ${name}##
#end

#macro (displayExtensionActionButtons $extension)
  {{html}}
  &lt;form action=""&gt;
    &lt;div class="extension-actions"&gt;
      #extensionHiddenFormFields($extension.id.id $extension.id.version true)
      ##
      ## Generic actions.
      ##
      #computeXBack()
      ## Check if the current request targets the given extension.
      #if ($request.extensionId == $extension.id.id &amp;&amp; $request.extensionVersion == $extension.id.version.value)
        #if ($xcontext.action == 'get')
          ## AJAX request to show extension details.
          #em_submitButton('extensions.actions.showDetails' 'showDetails' true 'visibilityAction')
          #em_submitButton('extensions.actions.hideDetails' 'hideDetails' true 'visibilityAction')
        #else
          ## The given extension is displayed alone.
          #em_linkButton($xback 'extensions.actions.back')
        #end
      #else
        ## The given extension is displayed in a list of extensions.
        #em_submitButton('extensions.actions.showDetails' 'actionShowDetails' true)
        &lt;input type="hidden" name="xback" value="${xback}" /&gt;
      #end
      ##
      ## Specific actions.
      ##
      #if(!$extensionStatus)
        #determineExtensionStatus($extension $extensionStatus $extensionStatusMessage)
      #end
      #if ($extensionStatus == 'installed')
        ## This extension can be uninstalled.
        #extensionActionButton($extension 'uninstall' true)
      #elseif ($extensionStatus == 'remote')
        ## Installable extension.
        #extensionActionButton($NULL 'install')
      #elseif ($extensionStatus == 'remote-installed')
        ## An extension that can be either upgraded or downgraded.
        ## Compare this version with the version that is currently installed to determine which button to display.
        #set ($installedExtension = $extensionManager.getInstalledExtension($extension.id.id, $extensionNamespace))
        #if ($extension.id.version.compareTo($installedExtension.id.version) &gt; 0)
          #extensionActionButton($installedExtension 'upgrade')
        #else
          #extensionActionButton($installedExtension 'downgrade' true)
        #end
      #end
    &lt;/div&gt;
  &lt;/form&gt;
  {{/html}}
#end

#macro (displayExtensionAuthors $extension)
  (% class="extension-authors" %)(((
    $msg.get('extensions.info.authors') ##
    #foreach ($author in $extension.authors)
      #if ($author.name == 'devs')
        [[$msg.get('extensions.info.authors.xwikiorg')&gt;&gt;http://www.xwiki.org/]]##
      #elseif ("$!author.url" != '' &amp;&amp; "$!author.name" != '')
        [[${author.name}&gt;&gt;${author.url}]]##
      #else
        ${author.name}##
      #end
      #if ($foreach.hasNext), ##
      #else )))

      #end
    #end
#end

#macro (displayProgressBar $extension)
  #getExtensionJobStatus($extension.id.id $extension.id.version.value $jobStatus)
  #if ($jobStatus &amp;&amp; $jobStatus.state != 'FINISHED')
    (% class="ui-progress" %)(((
      (% class="ui-progress-background" %)(((
        #set ($percent = $jobStatus.progress.offset)
        #set ($percent = $mathtool.toInteger($mathtool.mul($percent, 100)))
        (% class="ui-progress-bar green" style="width:${percent}%" %)((()))
      )))
      #if (!$jobStatus.log.isEmpty())
        (% class="ui-progress-message" %)
        ## We need the tail of the log queue.
        #set ($logList = [])
        #set ($discard = $logList.addAll($jobStatus.log))
        #printLogMessage($logList.get($mathtool.sub($logList.size(), 1)))
      #end
    )))
  #end
#end

#macro (displayExtensionDetails_menuLink $detail $selected)
  [[$msg.get("extensions.info.category.$detail")&gt;&gt;||anchor="extension-body-${detail}-${extension.id.id}-${extension.id.version}"#if ($selected) class="current"#end]]
#end

#macro (displayExtensionDetails_menu $extension)
  (% class="innerMenu" %)
  * #displayExtensionDetails_menuLink('description')
  #if ("$!{extension.releaseNotes}" != '')
    * #displayExtensionDetails_menuLink('releaseNotes')
  #end
  #if ($extension.dependencies.size() &gt; 0 || $backwardDependencies.size() &gt; 0)
    * #displayExtensionDetails_menuLink('dependencies')
  #end
  ## Display the progress tab if the install/uninstall plan is requested or if there is 
  ## a previously stored job status for this extension (a previous install or uninstall).
  #set ($planRequested = $request.actionInstall || $request.actionInstallGlobally || $request.actionUninstall || $request.actionUninstallGlobally)
  #if (!$planRequested)
    #getExtensionJobStatus($extension.id.id $extension.id.version.value $jobStatus)
  #end
  #if ($planRequested || $jobStatus)
    #set ($selected = $planRequested || $jobStatus.state != 'FINISHED')
    * #displayExtensionDetails_menuLink('progress' $selected)
  #end
#end

#macro (displayExtensionDetails_description $extension)
  {{id name="extension-body-description-${extension.id.id}-${extension.id.version}" /}}
  (% class="extension-body-description extension-body-section" %)(((
    (% class="extension-metadata" %)
    * $msg.get('extensions.info.license', [$extension.licenses.size()]) ##
    #foreach ($license in $extension.licenses)
      ${license.name}##
      #if ($foreach.hasNext), #end
    #end

    #if ($extension.repository.id.URI &amp;&amp; $extension.repository.id.URI.scheme != 'file')
      * $msg.get('extensions.info.repository') [[$extension.repository.id.id&gt;&gt;$extension.repository.id.URI]]
    #end
    #if ($extension.dependency)
      * $msg.get('extensions.info.dependency')
    #end
    #if ("$!{extension.webSite}" != '')
      * $msg.get('extensions.info.website') [[$extension.webSite.replaceAll('^[^/]++//([^/]++)/?.*+$', '$1')&gt;&gt;$extension.webSite]]
    #end
    #if ($extension.features.size() &gt; 0)
      * $msg.get('extensions.info.features') $extension.features
    #end
    #if ($xwiki.isVirtualMode())
      * #displayExtensionDetails_description_wikis($extension)
    #end
    ##
    ## TODO: need a decision on what exactly is the description and how it should be safely displayed (wiki syntax, server side generated HTML, etc)
    ## $!extension.description
  )))
#end

#macro (displayExtensionDetails_description_wikis $extension)
  #if (!$extension.namespaces || $extension.namespaces.isEmpty())
    ## The given extension was installed globally.
    $msg.get('extensions.info.namespaces.global')
  #else
    ## List the wikis where the given extension was installed.
    #set ($firstWiki = true)
    $msg.get('extensions.info.namespaces.list') ##
    #foreach ($namespace in $extension.namespaces)
      #if (!$firstWiki), #end##
      #if ($namespace.startsWith('wiki:'))
        #set ($firstWiki = false)
        $namespace.substring(5)##
      #end
    #end

  #end
#end

#macro (displayExtensionDetails_releaseNotes $extension)
  #if ("$!{extension.releaseNotes}" != '')

    {{id name="extension-body-releaseNotes-${extension.id.id}-${extension.id.version}"/}}
    (% class="extension-body-releaseNotes extension-body-section" %)(((
      $!{extension.releaseNotes}
    )))
  #end
#end

#macro (displayDependency $dependencyOrExtension $namespace)
  #if ($dependencyOrExtension.versionConstraint)
    ## Dependency object.
    #set ($dependencyId = $dependencyOrExtension.id)
    #set ($dependencyVersion = $dependencyOrExtension.versionConstraint)
    #set ($dependencyExtension = $extensionManager.resolve($dependencyOrExtension))
  #else
    ## Extension object.
    #set ($dependencyId = $dependencyOrExtension.id.id)
    #set ($dependencyVersion = $dependencyOrExtension.id.version.value)
    #set ($dependencyExtension = $dependencyOrExtension)
  #end
  #set ($dependencyStatus = 'unknown')
  #set ($dependencyStatusMessage = $NULL)
  #set ($dependencyName = $dependencyId)
  #if ($dependencyExtension)
    #determineExtensionStatus($dependencyExtension $dependencyStatus $dependencyStatusMessage $dependencyOrExtension.versionConstraint)
    #set ($dependencyURL = "#getExtensionURL($dependencyId $dependencyVersion)")
    #set ($dependencyName = "[[#displayExtensionName($dependencyExtension)&gt;&gt;path:$dependencyURL||class=""extension-link""]]")
  #end
  (% class="dependency-item extension-item-$dependencyStatus" %)(((
    ${dependencyName}(% class="extension-version" %)$!{dependencyVersion}##
    #if ($xwiki.isVirtualMode() &amp;&amp; $namespace.startsWith('wiki:'))
      (% class="extension-namespace" %)$msg.get('extensions.info.dependency.wiki', [$namespace.substring(5)])##
    #end
    (% class="extension-status" %)$!dependencyStatusMessage
  )))
#end

#macro (displayExtensionDetails_dependencies_upstream $extension)
  $msg.get('extensions.info.dependencies.directDependencies', [$extension.dependencies.size()])
  #foreach ($dependency in $extension.dependencies)
    * #displayDependency($dependency)
    #if (!$foreach.hasNext)

    #end
  #end
#end

#macro (displayExtensionDetails_dependencies_downstream $backwardDependencies)
  $msg.get('extensions.info.dependencies.backwardDependencies', [$backwardDependencies.size()])
  #foreach ($namespace in $backwardDependencies.entrySet())
    #foreach ($dependency in $namespace.value)
      * #displayDependency($dependency $namespace.key)
    #end
  #end
#end

#macro (displayExtensionDetails_dependencies $extension $backwardDependencies)
  #if ($extension.dependencies.size() &gt; 0 || $backwardDependencies.size() &gt; 0)

    {{id name="extension-body-dependencies-${extension.id.id}-${extension.id.version}" /}}
    #computeXBack()
    (% class="extension-body-dependencies extension-body-section" %)(((
      #displayExtensionDetails_dependencies_upstream($extension)
      #displayExtensionDetails_dependencies_downstream($backwardDependencies)
    )))
  #end
#end

#macro (displayExtensionDetails_progress $extension)
  #getExtensionJobStatus($extension.id.id $extension.id.version.value $jobStatus)
  #if ($jobStatus || $request.actionInstall || $request.actionInstallGlobally || $request.actionUninstall || $request.actionUninstallGlobally)

    {{id name="extension-body-progress-${extension.id.id}-${extension.id.version}" /}}
    (% class="extension-body-progress extension-body-section" %)(((
      #if ($request.actionInstall)
        #computeInstallPlan($extension.id.id $extension.id.version.value $extensionNamespace)
      #elseif ($request.actionInstallGlobally)
        #computeInstallPlan($extension.id.id $extension.id.version.value $NULL)
      #elseif ($request.actionUninstall)
        #computeUninstallPlan($extension.id.id $extension.id.version.value $extensionNamespace)
      #elseif ($request.actionUninstallGlobally)
        #computeUninstallPlan($extension.id.id $extension.id.version.value $NULL)
      #else
        #printStatusLog($jobStatus)
        #if ($jobStatus.state == 'WAITING')

          #displayExtensionDetails_progressQuestion($extension $jobStatus)
        #end
      #end
    )))
  #end
#end

#macro (displayExtensionDetails_progressQuestion $extension $jobStatus)
  #set ($question = $jobStatus.question)
  {{html wiki="true"}}
    &lt;form action="" method="post" class="xform"&gt;
      (((
        #extensionHiddenFormFields($extension.id.id $extension.id.version)
        &lt;input name="actionContinue" type="hidden" /&gt;
        ; &lt;label&gt;$msg.get('extensions.upgrade.mergeConflict.label')&lt;/label&gt;##
          (% class="xHint" %)$msg.get('extensions.upgrade.mergeConflict.hint', ["[[$question.currentDocument&gt;&gt;doc:$services.model.serialize($question.currentDocument.documentReference)]]"])&lt;/label&gt;
        : &lt;select name="versionToKeep"&gt;
          #set ($versions = {'NEXT': $question.nextDocument, 'MERGED': $question.mergedDocument, 'CURRENT': $question.currentDocument})
          #foreach($entry in $versions.entrySet())
            ## Make sure that each version has a document associated. We don't have for instance a merged document when
            ## there is no previous installed version of a XAR extension but the imported documents already exist in the wiki.
            #if ($entry.value)
              &lt;option value="$entry.key"#if ($question.globalAction == $entry.key) selected="selected"#end&gt;$msg.get("extensions.upgrade.mergeConflict.versionToKeep.$entry.key.toLowerCase()")&lt;/option&gt;
            #end
          #end
          &lt;/select&gt;

        &lt;p&gt;#em_submitButton('extensions.actions.continue' 'confirm')&lt;/p&gt;

        #displayExtensionDetails_progressChanges($question)
      )))
    &lt;/form&gt;
  {{/html}}
#end

#macro (displayExtensionDetails_progressChanges $question)
  (% class="extension-diff-title" %)
  === $msg.get('extensions.upgrade.mergeConflict.changes.title', ["[[$question.currentDocument&gt;&gt;doc:$services.model.serialize($question.currentDocument.documentReference)]]"]) ===

  (% class="extension-diff-options" %)(((
    #set ($versions = {'PREVIOUS': $question.previousDocument, 'CURRENT': $question.currentDocument, 'NEXT': $question.nextDocument, 'MERGED': $question.mergedDocument})
    (% class="label" %)$msg.get('extensions.upgrade.mergeConflict.changes.original')(%%)##
    &lt;select name="original"&gt;
    #if ("$!request.original" != '')
      #set ($originalVersion = $request.original)
    #else
      #set ($originalVersion = 'CURRENT')
    #end
    #set ($originalDocument = $versions.get($originalVersion))
    #foreach($entry in $versions.entrySet())
      #if ($entry.value)
        &lt;option value="$entry.key"#if ($entry.key == $originalVersion) selected="selected"#end&gt;$msg.get("extensions.upgrade.mergeConflict.changes.versionToCompare.$entry.key.toLowerCase()")&lt;/option&gt;
      #end
    #end
    &lt;/select&gt;##
    (% class="label" %)$msg.get('extensions.upgrade.mergeConflict.changes.revised')(%%)##
    &lt;select name="revised"&gt;
    #if ("$!request.revised" != '')
      #set ($revisedVersion = $request.revised)
    #elseif ($question.mergedDocument)
      #set ($revisedVersion = 'MERGED')
    #else
      #set ($revisedVersion = 'NEXT')
    #end
    #set ($revisedDocument = $versions.get($revisedVersion))
    #foreach($entry in $versions.entrySet())
      #if ($entry.value)
        &lt;option value="$entry.key"#if ($entry.key == $revisedVersion) selected="selected"#end&gt;$msg.get("extensions.upgrade.mergeConflict.changes.versionToCompare.$entry.key.toLowerCase()")&lt;/option&gt;
      #end
    #end
    &lt;/select&gt;##
    #em_submitButton('extensions.actions.diff' 'diff' true)
  )))
  #if ($originalDocument &amp;&amp; $revisedDocument)
    (% id="changescontent" %)(((
      {{html}}
      #set ($rev1 = $originalVersion.toLowerCase())
      #set ($rev2 = $revisedVersion.toLowerCase())
      #set ($wrappedDocs = $xwiki.wrapDocs([$originalDocument, $revisedDocument]))
      #set ($origdoc = $wrappedDocs.get(0))
      #set ($newdoc = $wrappedDocs.get(1))
      #set ($headingLevel = 4)
      #template('changesdoc.vm')
      {{/html}}
    )))
  #end
#end

#macro (displayExtensionDetails $extension)
  #set ($backwardDependencies = $extensionManager.getBackwardDependencies($extension.id.id, $extension.id.version.value))
  #if (!$backwardDependencies)
    #set ($backwardDependencies = {})
  #end
  (% class="extension-body" %)(((
    #displayExtensionDetails_menu($extension)

    #displayExtensionDetails_description($extension)
    #displayExtensionDetails_releaseNotes($extension)
    #displayExtensionDetails_dependencies($extension $backwardDependencies)
    #displayExtensionDetails_progress($extension)
  )))
#end

#macro (displayExtension $extension)
  #determineExtensionStatus($extension $extensionStatus $extensionStatusMessage)
  (% class="extension-item extension-item-${extensionStatus}" %)(((
    (% class="extension-header" %)(((
      (% class="extension-name" %)
      == #displayExtensionName($extension) (% class="extension-version" %)$extension.id.version ==

      (% class="extension-header-right" %)(((
        #if ($extensionStatusMessage)
          (% class="extension-status" %)
          $extensionStatusMessage

        #end
        #displayExtensionActionButtons($extension)
      )))

      #if ($extension.authors.size() &gt; 0)
        #displayExtensionAuthors($extension)
      #end
      #if ("$!{extension.summary}" != '')
        (% class="extension-description" %)
        {{{
          $extension.summary.replaceAll('\s+', ' ')
        }}}

      #end
      #displayProgressBar($extension)
      (% class="clearfloats" %)((()))
    )))
    #if ($request.extensionId == $extension.id.id &amp;&amp; $request.extensionVersion == $extension.id.version.value)
      #displayExtensionDetails($extension)
    #end
  )))
#end

#macro (installExtension $extensionId $extensionVersion $extensionNamespace)
  #set ($discard = $extensionManager.install($extensionId, $extensionVersion, $extensionNamespace))
  #set ($lastError = $extensionManager.lastError)
  #if ($lastError)
    #set ($errorMessage = $msg.get('extensions.install.error.installFailure', [$extensionId, $extensionVersion]))
    #if ($xcontext.action == 'get')
      ## AJAX request. Send error back.
      $response.sendError(400, $errorMessage)
    #else
      {{error}}$errorMessage #printThrowable($lastError){{/error}}
    #end
  #else
    ## Redirect to extension display.
    $response.sendRedirect("#getExtensionURL()")
  #end
#end

#macro (computeInstallPlan $extensionId $extensionVersion $extensionNamespace)
  #set($installPlan = $extensionManager.createInstallPlan($extensionId, $extensionVersion, $extensionNamespace))
  #if (!$installPlan)
    {{error}}$msg.get('extensions.install.error.prepareFailure', [$extensionId, $extensionVersion, $extensionManager.lastError.message]){{/error}}
  #else
    #set($hasError = false)
    #foreach($log in $installPlan.log)
      #if ($log.level.name() == 'ERROR')
        #set($hasError = true)
      #end
    #end
    ##
    #if ($hasError)
      #printStatusLog($installPlan)
    #else
      ## Group the extensions by the actions that will be performed on them.
      #set($extensionsByAction = {'INSTALL': [], 'UPGRADE': [], 'DOWNGRADE': [], 'UNINSTALL': []})
      #set ($noAction = true)
      #foreach($planAction in $installPlan.actions)
        #set ($targetExtensions = $extensionsByAction.get($planAction.action.name()))
        #if ($targetExtensions)
          #set ($discard = $targetExtensions.add($planAction))
          #set ($noAction = false)
        #end
      #end
      ##
      #if ($noAction)
        {{info}}$msg.get('extensions.install.error.alreadyInstalled'){{/info}}
      #else
        #foreach($entry in $extensionsByAction.entrySet())
          #if (!$entry.value.isEmpty())
            $msg.get("extensions.install.list.$entry.key.toLowerCase()")
            #foreach ($planAction in $entry.value)
              * #displayDependency($planAction.extension $planAction.namespace)
            #end

          #end
        #end
        {{html}}
          &lt;form action="" class="xform"&gt;
            &lt;div&gt;
              #extensionHiddenFormFields($extensionId $extensionVersion)
              &lt;input name="actionInstall#if ($request.actionInstallGlobally)Globally#end" type="hidden" /&gt;
              &lt;p&gt;
                #em_submitButton('extensions.install.actions.submit' 'confirm')
                #if ("$!{request.xback}" != '')
                  #em_linkButton($request.xback 'extensions.install.actions.cancel')
                #end
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/form&gt;
        {{/html}}
      #end
    #end
  #end
#end

#macro (uninstallExtension $extensionId $extensionVersion $extensionNamespace)
  #if ($extensionNamespace &amp;&amp; $xwiki.isVirtualMode())
    ## Uninstall only from the specified wiki.
    #set ($discard = $extensionManager.uninstall($extensionId, $extensionNamespace))
  #else
    #set ($extension = $extensionManager.resolve($extensionId, $extensionVersion))
    #if ($extension)
      ## Uninstall from the entire farm.
      #set ($discard = $extensionManager.uninstall($extension.id))
    #end
  #end
  #set($lastError = $extensionManager.lastError)
  #if ($lastError)
    #set ($errorMessage = $msg.get('extensions.uninstall.error.uninstallFailure', [$extensionId, $extensionVersion]))
    #if ($xcontext.action == 'get')
      ## AJAX request. Send error back.
      $response.sendError(400, $errorMessage)
    #else
      {{error}}$errorMessage #printThrowable($lastError){{/error}}
    #end
  #else
    ## Redirect to extension display.
    $response.sendRedirect("#getExtensionURL()")
  #end
#end

#macro (computeUninstallPlan $extensionId $extensionVersion $extensionNamespace)
  #if ($extensionNamespace &amp;&amp; $xwiki.isVirtualMode())
    ## Create the uninstall plan only for the specified wiki.
    #set ($uninstallPlan = $extensionManager.createUninstallPlan($extensionId, $extensionNamespace))
  #else
    #set ($extension = $extensionManager.resolve($extensionId, $extensionVersion))
    #if ($extension)
      ## Create the uninstall plan for the entire farm.
      #set ($uninstallPlan = $extensionManager.createUninstallPlan($extension.id))
    #else
      #set ($uninstallPlan = $NULL)
    #end
  #end
  #if (!$uninstallPlan)
    {{error}}$msg.get('extensions.uninstall.error.prepareFailure', [$extensionId, $extensionVersion, $lasterror.message]){{/error}}
  #else
    #set($hasError = false)
    #foreach($log in $uninstallPlan.log)
      #if ($log.level.name() == 'ERROR')
        #set($hasError = true)
      #end
    #end
    ##
    #if ($hasError)
      #printStatusLog($uninstallPlan)
    #else
      #set($extensionsToUninstall = [])
      ##
      #foreach($planAction in $uninstallPlan.actions)
        #if ($planAction.action.name() == "UNINSTALL")
          #set($void = $extensionsToUninstall.add($planAction))
        #end
      #end
      ##
      #if ($extensionsToUninstall.isEmpty())
        {{info}}$msg.get('extensions.uninstall.error.notInstalled'){{/info}}
      #else
        $msg.get('extensions.uninstall.list')
        #foreach ($planAction in $extensionsToUninstall)
          * #displayDependency($planAction.extension $planAction.namespace)
        #end

        {{html}}
          &lt;form action="" class="xform"&gt;
            &lt;div&gt;
              #extensionHiddenFormFields($extensionId $extensionVersion)
              &lt;input name="actionUninstall#if ($request.actionUninstallGlobally)Globally#end" type="hidden" /&gt;
              &lt;p&gt;
                #em_submitButton('extensions.uninstall.actions.submit' 'confirm')
                #if ("$!{request.xback}" != '')
                  #em_linkButton($request.xback 'extensions.uninstall.actions.cancel')
                #end
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/form&gt;
        {{/html}}
      #end
    #end
  #end
#end

#macro (getExtensionURL $extensionId $extensionVersion)
  #set ($parameters = {})
  #if ($extensionId)
    #set ($discard = $parameters.put('extensionId', $extensionId))
  #elseif ($request.extensionId)
    #set ($discard = $parameters.put('extensionId', $request.extensionId))
  #end
  #if ($extensionVersion)
    #set ($discard = $parameters.put('extensionVersion', $extensionVersion))
  #elseif ($request.extensionVersion)
    #set ($discard = $parameters.put('extensionVersion', $request.extensionVersion))
  #end
  #if ($xback)
    #set ($discard = $parameters.put('xback', $xback))
  #elseif ($request.xback)
    #set ($discard = $parameters.put('xback', $request.xback))
  #end
  #if ($request.section)
    #set ($discard = $parameters.put('section', $request.section))
  #end
  #set ($queryString = '')
  #foreach ($entry in $parameters.entrySet())
    #set ($queryString = "$queryString&amp;$escapetool.url($entry.key)=$escapetool.url($entry.value)")
  #end
$doc.getURL($xcontext.action, $queryString.substring(1))##
#end

#macro (getExtensionJobStatus $extensionId $extensionVersion $return)
  ## Retrieve the job status for the current wiki and for the entire farm (if the current wiki is the main wiki).
  #getExtensionJobStatusForNamespace($extensionId $extensionVersion $extensionNamespace $jobStatusForWiki)
  #if ($xcontext.isMainWiki())
    #getExtensionJobStatusForNamespace($extensionId $extensionVersion $NULL $jobStatusForFarm)
  #end
  #set ($return = $NULL)
  #if (!$jobStatusForWiki)
    #setVariable ("$return" $jobStatusForFarm)
  #elseif (!$jobStatusForFarm)
    #setVariable ("$return" $jobStatusForWiki)
  ## Return the most recent job status.
  #elseif ($jobStatusForFarm.startDate.after($jobStatusForWiki.startDate))
    #setVariable ("$return" $jobStatusForFarm)
  #else
    #setVariable ("$return" $jobStatusForWiki)
  #end
#end

#macro (getExtensionJobStatusForNamespace $extensionId $extensionVersion $extensionNamespace $return)
  ## Make sure the value of $return is always reset.
  #set ($return = $NULL)
  #setVariable ("$return" $NULL)
  #set ($_jobStatus = $extensionManager.getExtensionJobStatus($extensionId, $extensionNamespace))
  #if ($_jobStatus)
    ## Check if the stored job status also matches the extension version.
    #foreach ($_extension in $_jobStatus.request.extensions)
      #if ($_extension.id == $extensionId)
        #set ($_version = $_extension.version)
        #if (!$_version)
          ## Some jobs don't require the extension version. Let's determine the currently available version.
          #set ($_version = $extensionManager.getInstalledExtension($extensionId, $extensionNamespace).id.version)
        #end
        #if (!$_version || $extensionVersion == $_version.value)
          #setVariable ("$return" $_jobStatus)
          #break
        #end
      #end
    #end
  #end
#end

#macro (continueExtensionUpgrade $extensionId $extensionVersion)
  #getExtensionJobStatus($extensionId $extensionVersion $jobStatus)
  #if ($jobStatus &amp;&amp; $jobStatus.state == 'WAITING')
    #set($discard = $jobStatus.question.setGlobalAction($request.versionToKeep))
    #set($discard = $jobStatus.answered())
  #end
  ## Redirect to extension display.
  $response.sendRedirect("#getExtensionURL()")
#end

#macro (handleExtensionRequest)
  #if ($request.confirm)
    #if ($services.csrf.isTokenValid($request.form_token))
      #if ($request.actionInstall)
        #installExtension($request.extensionId $request.extensionVersion $extensionNamespace)
      #elseif ($request.actionInstallGlobally)
        #installExtension($request.extensionId $request.extensionVersion $NULL)
      #elseif ($request.actionUninstall)
        #uninstallExtension($request.extensionId $request.extensionVersion $extensionNamespace)
      #elseif ($request.actionUninstallGlobally)
        #uninstallExtension($request.extensionId $request.extensionVersion $NULL)
      #elseif ($request.actionContinue)
        #continueExtensionUpgrade($request.extensionId $request.extensionVersion)
      #else
        $response.sendRedirect("#getExtensionURL()")
      #end
    #elseif ($xcontext.action == 'get')
      # AJAX request. The CSRF token expired. We only redisplay the extension because the resubmission confirmation doesn't fit nicely in-line.
      $response.sendRedirect("#getExtensionURL()")
    #else
      $response.sendRedirect($services.csrf.getResubmissionURL())
    #end
  #else
    ## Display the extension.
    #set ($extension = $extensionManager.resolve($request.extensionId, $request.extensionVersion))
    #if ($extension)
      #displayExtension($extension)
    #else
      {{info}}$msg.get('extensions.advancedSearch.noResults', ["**{{{$!request.extensionId}}}**", "**{{{$!request.extensionVersion}}}**"]){{/info}}
    #end
  #end
#end

#macro (printThrowable $throwable $isCause)
  #if (!$isCause)
    ## We use the HTML macro because we don't have a better way to escape the wiki syntax.
    {{html}}
    &lt;div class="stacktrace"&gt;##
  #end
  $throwable.class: #if(!$throwable.message)null#else$escapetool.xml($throwable.message)#end

  #foreach($stackTraceElement in $throwable.stackTrace)
#**#    at $stackTraceElement
  #end
  #if ($throwable.cause)
    Caused by: #printThrowable($throwable.cause true)
  #end
  #if (!$isCause)
    &lt;/div&gt;
    {{/html}}
  #end
#end

#macro (getThrowableRootCauseMessage $throwable)
  #if ($throwable.cause)
    #getThrowableRootCauseMessage($throwable.cause)
  #else
    $!{throwable.message}##
  #end
#end

#macro (printStatusLog $status)
  #foreach ($log in $status.log)
    #set ($logLevel = $log.level.toString().toLowerCase())
    #if (!$foreach.hasNext &amp;&amp; $status.state != 'FINISHED')
      ## Display the last log item as loading if the job is in progress.
      #set ($logLevel = 'loading')
    #end
    * (% class="extension-log-item extension-log-item-$logLevel" %)(((
        #if ($log.throwable)
          #set ($message = "#getThrowableRootCauseMessage($log.throwable)")
          #if ("$!message" != '')
            ## We use the HTML macro because currently there's no easy way to escape wiki syntax.
            {{html}}$escapetool.xml($message){{/html}}
          #else
            #printLogMessage($log)
          #end

          #printThrowable($log.throwable)
        #else
          #printLogMessage($log)
        #end
      )))
  #end
#end

#macro (printLogMessage $log)
  ## We use the HTML macro because currently there's no easy way to escape wiki syntax.
  {{html}}##
  #set ($messageElements = $log.messageElements)
  #foreach ($argument in $log.argumentArray)
    $escapetool.xml($messageElements.get($mathtool.sub($velocityCount, 1)))##
    ## Assume the argument is an entity reference.
    #set ($reference = $services.model.serialize($argument))
    #if ($reference)
      &lt;a href="$xwiki.getURL($argument)"&gt;$escapetool.xml($reference)&lt;/a&gt;##
    #else
      ## Assume the argument is an extension dependency.
      #set ($_extension = $extensionManager.resolve($argument))
      #if (!$_extension)
        ## Assume the argument is an extension id.
        #set ($_extension = $extensionManager.resolve($argument.id, $argument.version.value))
      #end
      #if ($_extension)
        &lt;a href="#getExtensionURL($_extension.id.id, $_extension.id.version.value)" class="extension-link"&gt;$escapetool.xml("#displayExtensionName($_extension)") $escapetool.xml($_extension.id.version.value)&lt;/a&gt;##
      #else
        $escapetool.xml($argument)##
      #end
    #end
  #end
  $!escapetool.xml($messageElements.get($mathtool.sub($messageElements.size(), 1)))##
  {{/html}}
#end

#macro (computeXBack)
  #set ($xback = "$!{request.xback}")
  #if ($xback == '')
    #set ($params = '')
    #foreach ($parameterName in $request.parameterNames)
      #if (!$parameterName.startsWith('action') &amp;&amp; !$parameterName.startsWith('extension'))
        #foreach ($value in $request.getParameterValues($parameterName))
          #set ($params = "${params}&amp;${parameterName}=${value}")
        #end
      #end
    #end
    #if ($params.length() &gt; 0)
      #set ($params = $params.substring(1))
    #end
    #set ($xback = $doc.getURL($xcontext.action, $params))
  #end
#end

#macro (determineExtensionStatus $extension $extensionStatus $extensionStatusMessage $versionConstraint)
  #set ($currentVersion = $NULL)
  #getExtensionJobStatus($extension.id.id $extension.id.version.value $jobStatus)
  #if ($jobStatus &amp;&amp; $jobStatus.state != 'FINISHED')
    #set ($status = 'loading')
  #else
    #set ($status = $extension.repository.id.id)
    #if ($status != 'core' &amp;&amp; $status != 'installed')
      ## An extension, either local or remote, that might be available to install.
      ## Check if a different version of this extension is installed or is a core dependency.
      #set ($currentVersion = $extensionManager.getCoreExtension($extension.id.id))
      #if (!$currentVersion)
        #set ($currentVersion = $extensionManager.getInstalledExtension($extension.id.id, $extensionNamespace))
      #end
      #if ($currentVersion)
        #set ($repoId = $currentVersion.repository.id.id)
        #set ($options = ["remote-$repoId", $repoId, "remote-${repoId}-incompatible"])
        #set ($status = "#determineVersionCompatibility($extension.id $currentVersion.id $versionConstraint $options)")
      #else
        #set ($status = 'remote')
      #end
    #end
  #end
  #set ($message = $NULL)
  #if ($status != 'remote' &amp;&amp; $status != 'loading')
    #set ($message = $msg.get("extensions.info.status.$status", [$currentVersion.id.version.value]))
  #end
  #set ($extensionStatus = $NULL)
  #setVariable ("$extensionStatus" $status)
  #set ($extensionStatusMessage = $NULL)
  #setVariable ("$extensionStatusMessage" $message)
#end

#macro (determineVersionCompatibility $alice $bob $versionConstraint $options)
  #set ($status = $options.get(0))
  #if ($alice.equals($bob))
    #set ($status = $options.get(1))
  #elseif ($versionConstraint &amp;&amp; !$versionConstraint.isCompatible($bob.version))
    #set ($status = $options.get(2))
  #end
  $status##
#end

#macro(em_submitButton $value $name $secondary $extraClassName)
  &lt;span class="buttonwrapper"&gt;
    &lt;input type="submit" value="$escapetool.xml($msg.get($value))"#if($name) name="$escapetool.xml($name)"#end class="button#if($secondary) secondary#end#if($extraClassName) $!escapetool.xml($extraClassName)#end"/&gt;
  &lt;/span&gt;
#end

#macro(em_linkButton $href $label $extraClassName)
  &lt;span class="buttonwrapper"&gt;
    &lt;a href="$escapetool.xml($href)" class="button secondary#if($extraClassName) $!escapetool.xml($extraClassName)#end"&gt;$msg.get($label)&lt;/a&gt;
  &lt;/span&gt;
#end

#macro(extensionActionButton $installedExtension $action $secondary)
  #set ($actionName = 'Install')
  #if ($action == 'uninstall')
    #set ($actionName = 'Uninstall')
  #end
  #if (!$installedExtension || ($installedExtension.isInstalled($extensionNamespace) &amp;&amp; !$installedExtension.isInstalled($null)) || !$xwiki.isVirtualMode())
    ## Button that targets only the current wiki.
    #em_submitButton("extensions.actions.$action" "action$actionName" $secondary)
  #end
  #if ($xwiki.isVirtualMode() &amp;&amp; $xcontext.isMainWiki())
    ## Button that targets the entire farm.
    #em_submitButton("extensions.actions.${action}Globally" "action${actionName}Globally" true)
  #end
#end

#macro(extensionHiddenFormFields $extensionId $extensionVersion $noCSRFToken)
  #if (!$noCSRFToken)
    &lt;input name="form_token" value="$!services.csrf.getToken()" type="hidden" /&gt;
  #end
  &lt;input name="extensionId" value="${escapetool.xml($extensionId)}" type="hidden" /&gt;
  &lt;input name="extensionVersion" value="${escapetool.xml($extensionVersion)}" type="hidden" /&gt;
  #if ($request.section)
    &lt;input name="section" value="$escapetool.xml($request.section)" type="hidden" /&gt;
  #end
#end
{{/velocity}}</content>
</xwikidoc>
