$response.setContentType("text/xml")
##
#set($classname = $request.get("classname"))
#set($fieldname = $request.get("fieldname"))
#set($firCol = "$!{request.get('firCol')}")
#set($secCol = "$!{request.get('secCol')}")
#set($templatename = $classname + 'Template')
#set($p = $xwiki.getDocument($classname).getxWikiClass().get($fieldname).getPropertyClass())
#set($classnametosearch = $!{p.getCustomMappingMap()['classname']})
#set($propnametosearch = $!{p.getCustomMappingMap()['idField']})
#set($hibquery = "$!p.getSql()")
##
## Determine what was the input. If the property accepts multiple values and has separators, then
## use only the last token as the input.
## TODO: What if the user is actually typing in the middle of the input string? The actual word for
## which the autocompletion is triggered should be sent from JS.
##
#set($input = "$!{request.get('input').toLowerCase()}")
#set($sep = "$!{p.getSeparators()}")
#if($p.isMultiSelect() && ($sep != "")) ### has separators
  #set($input_words = $stringtool.split($input, $sep))
  #foreach($i in $input_words)
    #set($input = $i.trim())
  #end
#end
##
######################### User hibernate query
#if("$!hibquery" != "")
  #if($secCol != "-")
    ### two columns, hidden input
    #set($likeCol = $secCol)
    #set($resultsType = 1)
  #else ### one column, no hidden input
    #set($likeCol = $firCol)
    #set($resultsType = 2)
  #end
  #set($whereidx = $hibquery.toLowerCase().indexOf("where"))
  #if($whereidx < 0)
    #set($like = " where lower("+ $likeCol.replaceAll("[^a-zA-Z0-9_.]", "") + ") like :userinput")
    #set($hibquery = $hibquery.concat($like))
  #else
    #set($whereidx = $whereidx + 5)
    #set($like = " lower("+ $likeCol.replaceAll("[^a-zA-Z0-9_.]", "") + ") like :userinput and")
    #set($hibquery = "${hibquery.substring(0, $whereidx)}${like}${hibquery.substring($whereidx)}")
  #end
  #set($bindValues = {})
  #set($discard = $bindValues.put('userinput', "%${input}%"))
  #set($queryChain = $services.query.hql($hibquery))
  #foreach($key in $bindValues.keySet())
    #set($queryChain = $queryChain.bindValue($key, $bindValues[$key]))
  #end
  #set($queryChain = $queryChain.setLimit(30))
  #set($queryChain = $queryChain.setOffset(0))
  #set($results = $queryChain.execute())
#elseif(!$classnametosearch.isEmpty()) ## hibquery == ""
  #if(!$propnametosearch.isEmpty())
    #set($query = "select distinct doc.fullName, obj.$propnametosearch from Document doc, doc.object($classnametosearch) as obj where lower(obj.$propnametosearch) like :userinput")
    #set($resultsType = "6")
  #else ## if propnametosearch == ""
    #set($query = "select distinct doc.fullName, doc.fullName from Document doc, doc.object($classnametosearch) as obj where lower(doc.fullName) like :userinput")
    #set($resultsType = "7")
  #end ## if propnametosearch != ""
  #set($bindValues = {})
  #set($discard = $bindValues.put('userinput', "%${input}%"))
  #set($queryChain = $services.query.xwql($query))
  #foreach($key in $bindValues.keySet())
    #set($queryChain = $queryChain.bindValue($key, $bindValues[$key]))
  #end
  #set($queryChain = $queryChain.setLimit(30))
  #set($queryChain = $queryChain.setOffset(0))
  #set($results = $queryChain.execute())
#else ## if hibquery == "" and classnametosearch == ""
  #set($bindValues = {})
  #set($discard = $bindValues.put('templatename', ${templatename}))
  #set($discard = $bindValues.put('classname', ${classname}))
  #set($discard = $bindValues.put('fieldname', ${fieldname}))
  #set($discard = $bindValues.put('userinput', "%${input}%"))
  ######################### DBListProperty query
  #if($p.isRelationalStorage() && $p.isMultiSelect())
    #set($query = "select distinct list from BaseObject as obj, DBStringListProperty as prop join prop.list list where obj.name <> :templatename and obj.className = :classname and prop.id.id = obj.id and prop.id.name = :fieldname and lower(list) like :userinput")
    #set($resultsType = "3")
  ######################### StringListProperty query
  #elseif($p.isMultiSelect())
    #set($query = "select distinct prop.textValue from BaseObject as obj, StringListProperty as prop where obj.name <> :templatename and obj.className = :classname and prop.id.id = obj.id and prop.name = :fieldname and lower(prop.textValue) like :userinput")
    #set($resultsType = "5")
  ######################### StringProperty query
  #else
    #set($query = "select distinct prop.value from BaseObject as obj, StringProperty as prop where obj.name <> :templatename and obj.className = :classname and prop.id.id = obj.id and prop.id.name = :fieldname and lower(prop.value) like :userinput")
    #set($resultsType = "8")
  #end
  #set($queryChain = $services.query.hql($query))
  #foreach($key in $bindValues.keySet())
    #set($queryChain = $queryChain.bindValue($key, $bindValues[$key]))
  #end
  #set($queryChain = $queryChain.setLimit(30))
  #set($queryChain = $queryChain.setOffset(0))
  #set($queryResult = $queryChain.execute())
  #set($results = $queryResult.toArray())
  #if($p.isMultiSelect() && !$p.isRelationalStorage())
    #set($finalList = [])
    #foreach($res in $results)
      #set($list = $p.getListFromString($res, '|', false))
      #set($list = $list.toArray())
      #foreach($e in $list)
        #set($discard = $finalList.add($e))
      #end
    #end
    #set($results = $finalList)
  #end
#end ## if hibquery != "" and classnametosearch != ""
##### Printing the XML file
<?xml version="1.0" encoding="UTF-8"?>
<results type="${resultsType}">
#foreach($res in $results)
  #set($info = '')
  #set($rs = $res)
  #foreach($r in $res)
    #if(${foreach.count} == 1)
      #set($info = $r)
    #elseif(${foreach.count} == 2)
      #set($rs = $r)
    #end
  #end
  #if(($info != '-') && ($rs != '-'))
    <rs id="${foreach.count}" info="$!{escapetool.xml($info)}">$!{escapetool.xml($rs)}</rs>
  #end
#end
</results>
