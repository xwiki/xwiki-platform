<?xml version="1.0" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc version="1.1">
  <web>XWiki</web>
  <name>DocumentTreeMacros</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <creationDate>1414167261000</creationDate>
  <parent>XWiki.DocumentTree</parent>
  <author>xwiki:XWiki.Admin</author>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <date>1414440426000</date>
  <contentUpdateDate>1414438718000</contentUpdateDate>
  <version>1.1</version>
  <title>Document Tree Macros</title>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>true</hidden>
  <content>{{include reference="XWiki.SuggestSolrMacros" /}}

{{velocity output="false"}}
## Configuration options.
#set ($docTreeConfig = {
  'showWikis': false,
  'showWikiPrettyName': true,
  'showSpaces': false,
  'showDocumentTitle': true,
  'showAddDocument': false,
  'showTranslations': true,
  'showAttachments': true,
  'showAddAttachment': false,
  'showObjects': false,
  'showClassProperties': false,
  'showChildDocuments': true,
  'showOnlyViewable': true,
  'filterByClass': ''
})

#macro (updateDocTreeConfigFromRequest)
  #foreach ($entry in $docTreeConfig.entrySet())
    #set ($valueFromRequest = $request.getParameter($entry.key))
    #if ("$!valueFromRequest" != '')
      #if ($entry.value.getClass().getName() == 'java.lang.Boolean')
        #set ($entry.value = $valueFromRequest == 'true')
      #else
        #set ($entry.value = $valueFromRequest)
      #end
    #end
  #end
#end

#macro (handleDocumentTreeRequest)
  #if ($request.action)
    #if ($services.csrf.isTokenValid($request.form_token))
      $response.sendError(400, 'The specified action is not supported.')
    #elseif ($isAjaxRequest)
      $response.sendError(403, 'The CSRF token is missing.')
    #else
      $response.sendRedirect($services.csrf.getResubmissionURL())
    #end
  #else
    #set ($data = $NULL)
    #if ($request.data == 'children')
      #getChildren($request.id $data)
    #elseif ($request.data == 'path')
      #getPath($request.id $data)
    #elseif ($request.data == 'contextMenu')
      #getContextMenu($data)
    #elseif ($request.data == 'suggestions')
      #getSuggestions($data)
    #end
    #if ($data)
      #set ($discard = $response.setContentType('application/json'))
      $jsontool.serialize($data)
    #else
      $response.sendError(404);
    #end
  #end
#end

#macro (getChildren $nodeId $return)
  #set ($children = [])
  #if ($nodeId == '#')
    ## Select the root node.
    #if ($docTreeConfig.showWikis &amp;&amp; $xcontext.isMainWiki())
      #set ($nodeType = 'farm')
    #else
      #set ($nodeType = 'wiki')
      #set ($nodeId = $xcontext.database)
    #end
  #else
    #set ($parts = $nodeId.split(':', 2))
    #set ($nodeType = $parts[0])
    #set ($nodeId = $parts[1])
  #end
  #set ($offset = $mathtool.max($mathtool.toInteger($request.offset), 0))
  #if ("$!offset" == '')
    #set ($offset = 0)
  #end
  #evaluate("${escapetool.h}add$stringtool.capitalize($nodeType)Children(${escapetool.d}nodeId
    $offset 15 ${escapetool.d}children)")
  #set ($return = $NULL)
  #setVariable("$return" $children)
#end

#macro (addFarmChildren $nodeId $offset $limit $children)
  #foreach ($wiki in $services.wiki.all)
    #maybeAddWikiNode($wiki $children)
  #end
#end

#macro (maybeAddWikiNode $wiki $siblings $placeholder)
  #if ($wiki &amp;&amp; (!$docTreeConfig.showOnlyViewable || $services.security.authorization.hasAccess('view', $wiki.reference)))
    #addWikiNode($wiki $siblings)
  #elseif ($placeholder)
    #set ($discard = $siblings.add($placeholder))
  #end
#end

#macro (addWikiNode $wiki $siblings)
  ## The main wiki cannot be deleted. For the rest we need special rights.
  #set ($canDeleteWiki = $wiki.id != $services.wiki.mainWikiId
    &amp;&amp; $services.wiki.canDeleteWiki($xcontext.user, $wiki.id))
  #if ($docTreeConfig.showWikiPrettyName)
    #set ($label = $wiki.prettyName)
  #else
    #set ($label = $wiki.id)
  #end
  #set ($discard = $siblings.add({
    'id': "wiki:$wiki.id",
    'text': $label,
    'icon': 'fa fa-hdd-o',
    'children': true,
    'data': {
      'id': $wiki.id,
      'type': 'wiki',
      'validChildren': ['space', 'document', 'pagination'],
      'canDelete': $canDeleteWiki
    },
    'a_attr': {
      'href': $xwiki.getURL($wiki.mainPageReference)
    }
  }))
#end

#macro (addWikiChildren $wikiId $offset $limit $children)
  #set ($wikiReference = $services.model.createWikiReference($wikiId))
  #if ($docTreeConfig.showSpaces)
    #addWikiSpaceChildren($wikiReference $offset $limit $children)
  #else
    #addWikiDocumentChildren($wikiReference $offset $limit $children)
  #end
#end

#macro (addWikiSpaceChildren $wikiReference $offset $limit $children)
  #if ($wikiReference.name == $xcontext.database)
    ## Current wiki.
    #set ($spaces = $xwiki.spaces)
    #set ($totalCount = $spaces.size())
    ## Limit the list of spaces.
    #set ($spaces = $spaces.subList($offset, $mathtool.min($mathtool.add($offset, $limit), $totalCount)))
  #else
    ## A different wiki. Requires programming rights.
    #set ($statement = 'select distinct doc.space from XWikiDocument doc order by doc.space asc')
    #set ($query = $services.query.hql($statement).setWiki($wikiReference.name).addFilter('hidden'))
    #set ($spaces = $query.setOffset($offset).setLimit($limit).execute())
    #if ($spaces.size() &gt;= $limit)
      #set ($countQuery = $services.query.hql('select count(distinct doc.space) from XWikiDocument doc'))
      #set ($totalCount = $countQuery.setWiki($wikiId).addFilter('hidden').execute()[0])
    #end
  #end
  #foreach ($space in $spaces)
    #set ($spaceReference = $services.model.createSpaceReference($space, $wikiReference))
    #maybeAddSpaceNode($spaceReference $children)
  #end
  #if ($spaces.size() &gt;= $limit)
    #set ($newOffset = $mathtool.add($offset, $spaces.size()))
    #if ($newOffset &lt; $totalCount)
      #addPaginationNode("wiki:$wikiReference.name" $newOffset $totalCount $children)
    #end
  #end
#end

#macro (getDocumentsQuery $constraints $parameters $return)
  #set ($fromClause = '')
  #set ($finalConstraints = [])
  #set ($finalParameters = {})
  #if ("$!docTreeConfig.filterByClass" != '')
    #set ($fromClause = ', BaseObject as obj')
    #set ($discard = $finalConstraints.addAll([
      'obj.name = doc.fullName',
      'obj.className = :class',
      'doc.fullName &lt;&gt; :template'
    ]))
    #set ($discard = $finalParameters.putAll({
      'class': $docTreeConfig.filterByClass,
      'template': "$stringtool.removeEnd($docTreeConfig.filterByClass, 'Class')Template"
    }))
  #end
  #set ($discard = $finalConstraints.addAll($constraints))
  #set ($discard = $finalParameters.putAll($parameters))
  #set ($docsQuery = $services.query.hql("$fromClause where $stringtool.join($finalConstraints, ' and ') order by doc.name"))
  #foreach ($entry in $finalParameters.entrySet())
    #set ($docsQuery = $docsQuery.bindValue($entry.key, $entry.value))
  #end
  #set ($discard = $docsQuery.addFilter('hidden'))
  #set ($return = $NULL)
  #setVariable("$return" $docsQuery)
#end

#macro (addWikiDocumentChildren $wikiReference $offset $limit $children)
  #getDocumentsQuery(["doc.parent = ''", 'doc.translation = 0'] {} $query)
  #addDocumentNodesFromQuery($query $offset $limit $wikiReference $children)
#end

#macro (maybeAddSpaceNode $spaceReference $siblings $placeholder)
  #if (!$docTreeConfig.showOnlyViewable || $services.security.authorization.hasAccess('view', $spaceReference))
    #addSpaceNode($spaceReference $siblings)
  #elseif ($placeholder)
    #set ($discard = $siblings.add($placeholder))
  #end
#end

#macro (addSpaceNode $spaceReference $siblings)
  #set ($spaceId = $services.model.serialize($spaceReference, 'default'))
  #set ($spaceHomePageRef = $services.model.resolveDocument('', 'default', $spaceReference))
  #set ($spacePrefsDocRef = $services.model.resolveDocument('WebPreferences', 'explicit', $spaceReference))
  #set ($hasSpaceAdmin = $xwiki.hasAccessLevel('admin', $xcontext.user, $spacePrefsDocRef))
  #set ($discard = $siblings.add({
    'id': "space:$spaceId",
    'text': $spaceReference.name,
    'icon': 'fa fa-folder-o',
    'iconOpened': 'fa fa-folder-open-o',
    'children': true,
    'data': {
      'id': $spaceId,
      'type': 'space',
      'validChildren': ['addDocument', 'document', 'pagination'],
      'hasContextMenu': true,
      'canRename': $hasSpaceAdmin,
      'canDelete': $hasSpaceAdmin,
      'createDocumentURL': $xwiki.getURL($spaceHomePageRef, 'create', $NULL),
      'deleteURL': $xwiki.getURL($spaceHomePageRef, 'deletespace', 'confirm=1')
    },
    'a_attr': {
      'href': $xwiki.getURL($spaceHomePageRef)
    }
  }))
#end

#macro (addSpaceChildren $spaceId $offset $limit $children)
  #set ($spaceReference = $services.model.resolveSpace($spaceId))
  #maybeAddAddDocumentNode($spaceReference $children)
  ## Get the documents from the specified space.
  #set ($constraints = [
    'doc.space = :space',
    'doc.translation = 0'
  ])
  #set ($parameters = {'space': $spaceReference.name})
  #if ($docTreeConfig.showChildDocuments)
    ## Include only documents that either don't have a parent or that have a parent in a different space.
    #set ($discard = $constraints.add("(doc.parent = '' or (doc.parent like '%.%' and doc.parent not like :absoluteRef and doc.parent not like :localRef))"))
    #set ($absoluteRef = $services.model.resolveDocument('%', 'explicit', $spaceReference))
    #set ($parameters.absoluteRef = "$absoluteRef")
    #set ($parameters.localRef = $services.model.serialize($absoluteRef, 'compactwiki', $absoluteRef.wikiReference))
  #end
  #getDocumentsQuery($constraints $parameters $query)
  #addDocumentNodesFromQuery($query $offset $limit $spaceReference $children)
#end

#macro (maybeAddAddDocumentNode $reference $siblings)
  #if ($docTreeConfig.showAddDocument &amp;&amp; $services.security.authorization.hasAccess('edit', $reference))
    #addAddDocumentNode($reference $siblings)
  #end
#end

#macro (addAddDocumentNode $reference $siblings)
  #set ($parentReference = $services.model.resolveDocument('', 'default', $reference))
  #set ($discard = $siblings.add({
    'id': "addDocument:$reference.type.toString().toLowerCase():$services.model.serialize($reference, 'default')",
    'text': 'New document...',
    'icon': 'fa fa-plus-circle',
    'children': false,
    'data': {
      'type': 'addDocument',
      'validChildren': []
    },
    'a_attr': {
      'href': $xwiki.getURL($parentReference, 'create')
    }
  }))
#end

#macro (addDocumentNodesFromQuery $_query $offset $limit $parentReference $children)
  #set ($wikiReference = $parentReference.extractReference('WIKI'))
  #set ($_query = $_query.setWiki($wikiReference.name))
  #set ($results = $_query.setOffset($offset).setLimit($limit).execute())
  #foreach ($docFullName in $results)
    #set ($documentReference = $services.model.resolveDocument($docFullName, 'explicit', $parentReference))
    #maybeAddDocumentNode($documentReference $children)
  #end
  #if ($results.size() &gt;= $limit)
    ## There may be more documents in this space.
    #set ($totalCount = $_query.count())
    #set ($newOffset = $mathtool.add($offset, $results.size()))
    #if ($newOffset &lt; $totalCount)
      #set ($parentRefAsString = $services.model.serialize($parentReference, 'default'))
      #set ($parentId = "$parentReference.type.toLowerCase():$parentRefAsString")
      #addPaginationNode($parentId $newOffset $totalCount $children)
    #end
  #end
#end

#macro (maybeAddDocumentNode $documentReference $siblings $placeholder)
  #if ($xwiki.exists($documentReference) &amp;&amp; (!$docTreeConfig.showOnlyViewable
      || $services.security.authorization.hasAccess('view', $documentReference)))
    #addDocumentNode($documentReference $siblings)
  #elseif ($placeholder)
    #set ($discard = $siblings.add($placeholder))
  #end
#end

#macro (addDocumentNode $documentReference $siblings)
  #set ($docNode = $xwiki.getDocument($documentReference))
  #set ($canViewDoc = "$!docNode" != '')
  #set ($canEditDoc = $docNode.hasAccessLevel('edit'))
  #set ($canDeleteDoc = $docNode.hasAccessLevel('delete'))
  #set ($hasChildren = false)
  #if ($canViewDoc)
    #set ($hasChildren = $hasChildren || ($docTreeConfig.showTranslations &amp;&amp; $docNode.translationList.size() &gt; 0))
    #set ($hasChildren = $hasChildren || ($docTreeConfig.showAttachments
      &amp;&amp; (($docTreeConfig.showAddAttachment &amp;&amp; $canEditDoc) || $docNode.attachmentList.size() &gt; 0)))
    #set ($xclass = $docNode.getxWikiClass())
    #set ($hasChildren = $hasChildren || ($docTreeConfig.showClassProperties &amp;&amp; $xclass &amp;&amp; $xclass.propertyNames.size() &gt; 0))
    #set ($hasChildren = $hasChildren || ($docTreeConfig.showObjects &amp;&amp; $docNode.getxWikiObjects().size() &gt; 0))
  #end
  #if (!$hasChildren &amp;&amp; $docTreeConfig.showChildDocuments)
    #getChildDocumentsCount($documentReference $count)
    #set ($hasChildren = $count &gt; 0)
  #end
  #set ($label = $documentReference.name)
  #if ($docTreeConfig.showDocumentTitle)
    #set ($plainTitle = $docNode.plainTitle)
    #if (!$stringtool.isBlank($plainTitle))
      #set ($label = $plainTitle)
    #end
  #end
  #set ($discard = $siblings.add({
    'id': "document:$documentReference",
    'text': $label,
    'icon': 'fa fa-file-o',
    'children': $hasChildren,
    'data': {
      'id': "$documentReference",
      'type': 'document',
      'validChildren': ['translations', 'attachments', 'attachment', 'classProperties', 'objects', 'document', 'pagination'],
      'hasContextMenu': true,
      'draggable': $canViewDoc,
      'canDelete': $canDeleteDoc,
      'canMove': $canDeleteDoc,
      'canCopy': $canViewDoc,
      'createDocumentURL': $xwiki.getURL($documentReference, 'create', $NULL),
      'deleteURL': $xwiki.getURL($documentReference, 'delete', 'confirm=1')
    },
    'a_attr': {
      'href': $xwiki.getURL($documentReference)
    }
  }))
#end

#macro (getChildDocumentsQuery $parentReference $return)
  #set ($constraints = [
    'doc.translation = 0',
    '(doc.parent in (:absoluteRef, :localRef) or (doc.space = :space and doc.parent = :relativeRef))'
  ])
  #set ($parameters = {
    'space': $parentReference.lastSpaceReference.name,
    'absoluteRef': "$parentReference",
    'localRef': $services.model.serialize($parentReference, 'compactwiki', $parentReference.wikiReference),
    'relativeRef': $services.model.serialize($parentReference, 'compact', $parentReference.parent)
  })
  #if ($docTreeConfig.showSpaces)
    #set ($discard = $constraints.add(0, 'doc.space = :space'))
    #set ($discard = $constraints.set(2, 'doc.parent in (:absoluteRef, :localRef, :relativeRef)'))
  #end
  #getDocumentsQuery($constraints $parameters $query)
  #set ($return = $NULL)
  #setVariable("$return" $query)
#end

#macro (getChildDocumentsCount $parentReference $return)
  #getChildDocumentsQuery($parentReference $countQuery)
  #set ($count = $countQuery.setWiki($parentReference.wikiReference.name).count())
  #set ($return = $NULL)
  #setVariable("$return" $count)
#end

#macro (addPaginationNode $parentId $offset $totalCount $siblings)
  #set ($discard = $siblings.add({
    'id': "pagination:$parentId",
    'text': "$!mathtool.sub($totalCount, $offset) more ...",
    'icon': 'fa fa-eye',
    'children': false,
    'data': {
      'type': 'pagination',
      'validChildren': [],
      'canDelete': true,
      'offset': $offset
    }
  }))
#end

#macro (addDocumentChildren $docId $offset $limit $children)
  #set ($documentReference = $services.model.resolveDocument($docId))
  #set ($docNode = $xwiki.getDocument($documentReference))
  #set ($canEditDoc = $docNode.hasAccessLevel('edit'))
  #set ($canDeleteDoc = $docNode.hasAccessLevel('delete'))
  #if ($offset == 0 &amp;&amp; $docTreeConfig.showTranslations &amp;&amp; $docNode.translationList.size() &gt; 0)
    #set ($discard = $children.add({
      'id': "translations:${documentReference}",
      'text': 'Translations',
      'icon': 'fa fa-language',
      'children': true,
      'data': {
        'type': 'translations',
        'validChildren': ['translation'],
        'canDelete': $canDeleteDoc
      }
    }))
  #end
  #if ($offset == 0 &amp;&amp; $docTreeConfig.showAttachments &amp;&amp;
      (($docTreeConfig.showAddAttachment &amp;&amp; $canEditDoc) || $docNode.attachmentList.size() &gt; 0))
    #addAttachmentsNode($documentReference $children)
  #end
  #set ($xclass = $docNode.getxWikiClass())
  #if ($offset == 0 &amp;&amp; $docTreeConfig.showClassProperties &amp;&amp; $xclass &amp;&amp; $xclass.propertyNames.size() &gt; 0)
    #set ($discard = $children.add({
      'id': "classProperties:${documentReference}",
      'text': 'Class Properties',
      'icon': 'fa fa-gears',
      'children': true,
      'data': {
        'type': 'classProperties',
        'validChildren': ['classProperty'],
        'canDelete': $canEditDoc
      }
    }))
  #end
  #if ($offset == 0 &amp;&amp; $docTreeConfig.showObjects &amp;&amp; $docNode.getxWikiObjects().size() &gt; 0)
    #set ($discard = $children.add({
      'id': "objects:${documentReference}",
      'text': 'Objects',
      'icon': 'fa fa-cubes',
      'children': true,
      'data': {
        'type': 'objects',
        'validChildren': ['objectsOfType'],
        'canDelete': $canEditDoc
      }
    }))
  #end
  #if ($docTreeConfig.showChildDocuments)
    #getChildDocumentsQuery($documentReference $query)
    #addDocumentNodesFromQuery($query $offset $limit $documentReference $children)
  #end
#end

#macro (addAttachmentsNode $documentReference $siblings)
  #set ($docNode = $xwiki.getDocument($documentReference))
  #set ($canEditDoc = $docNode.hasAccessLevel('edit'))
  #set ($discard = $siblings.add({
    'id': "attachments:${documentReference}",
    'text': 'Attachments',
    'icon': 'fa fa-paperclip',
    'children': true,
    'data': {
      'type': 'attachments',
      'validChildren': ['addAttachment', 'attachment', 'pagination'],
      'hasContextMenu': true,
      'canDelete': $canEditDoc
    },
    'a_attr': {
      'href': $docNode.getURL('view', 'viewer=attachments')
    }
  }))
#end

#macro (addTranslationsChildren $docId $offset $limit $children)
  #set ($docRef = $services.model.resolveDocument($docId))
  #set ($docNode = $xwiki.getDocument($docRef))
  #foreach ($language in $docNode.translationList)
    #set ($locale = $services.localization.toLocale($language))
    #set ($translationReference = $services.model.createDocumentReference($docNode.documentReference, $locale))
    #addTranslationNode($translationReference $children)
  #end
#end

#macro (addTranslationNode $translationReference $siblings)
  #set ($currentLocale = $services.localization.currentLocale)
  #set ($translationNode = $xwiki.getDocument($translationReference))
  #set ($discard = $siblings.add({
    'id': "translation:$services.model.serialize($translationReference, 'default')_$translationReference.locale",
    'text': $translationReference.locale.getDisplayName($currentLocale),
    'icon': 'fa fa-file-text-o',
    'children': false,
    'data': {
      'type': 'translation',
      'validChildren': [],
      'canDelete': $translationNode.hasAccessLevel('delete')
    },
    'a_attr': {
      'href': $xwiki.getURL($translationReference, 'view', $escapetool.url({
        'language': $translationReference.locale
      }))
    }
  }))
#end

#macro (addAttachmentsChildren $docId $offset $limit $children)
  #set ($docRef = $services.model.resolveDocument($docId))
  #set ($docNode = $xwiki.getDocument($docRef))
  #set ($canEditDoc = $docNode.hasAccessLevel('edit'))
  #if ($offset == 0 &amp;&amp; $docTreeConfig.showAddAttachment &amp;&amp; $canEditDoc)
    #addAddAttachmentNode($docRef $children)
  #end
  #set ($attachments = $docNode.attachmentList)
  #set ($totalCount = $attachments.size())
  ## Limit the number of attachments.
  #set ($attachments = $attachments.subList($offset, $mathtool.min($mathtool.add($offset, $limit), $totalCount)))
  #foreach ($attachment in $attachments)
    #addAttachmentNode($attachment $children)
  #end
  #if ($attachments.size() &gt;= $limit)
    #set ($newOffset = $mathtool.add($offset, $attachments.size()))
    #if ($newOffset &lt; $totalCount)
      #addPaginationNode("attachments:$docId" $newOffset $totalCount $children)
    #end
  #end
#end

#macro (addAddAttachmentNode $docNode $siblings)
  #set ($discard = $siblings.add({
    'id': "addAttachment:$docRef",
    'text': 'Upload file...',
    'icon': 'fa fa-plus-circle',
    'children': false,
    'data': {
      'type': 'addAttachment',
      'validChildren': []
    },
    'a_attr': {
      'href': $xwiki.getURL($docRef, 'view', 'viewer=attachments')
    }
  }))
#end

#macro (addAttachmentNode $attachment $siblings)
  #set ($attachmentReference = $services.model.createAttachmentReference($attachment.document.documentReference,
    $attachment.filename))
  #set ($attachmentId = $services.model.serialize($attachmentReference, 'default'))
  #getAttachmentIcon($attachment $icon)
  #set ($discard = $siblings.add({
    'id': "attachment:$attachmentId",
    'text': $attachment.filename,
    'icon': $icon,
    'children': false,
    'data': {
      'id': $attachmentId,
      'type': 'attachment',
      'validChildren': [],
      'hasContextMenu': true,
      'draggable': true,
      'canRename': $canEditDoc,
      'canDelete': $canEditDoc,
      'canMove': $canEditDoc,
      'canCopy': true,
      'deleteURL': $docNode.getAttachmentURL($attachment.filename, 'delattachment')
    },
    'a_attr': {
      'href': $docNode.getAttachmentURL($attachment.filename)
    }
  }))
#end

#set ($fileIconByMediaType = {
  'text': ['text/', 'application/xml', 'application/javascript', 'application/ecmascript', 'application/json', 'application/x-sh', '+xml'],
  'image': ['image/'],
  'audio': ['audio/'],
  'video': ['video/'],
  'pdf': ['application/pdf', 'application/postscript'],
  'word': ['application/msword', 'application/vnd.ms-word.', 'application/vnd.oasis.opendocument.text', 'application/vnd.openxmlformats-officedocument.word'],
  'powerpoint': ['application/vnd.ms-powerpoint', 'application/vnd.oasis.opendocument.presentation', 'application/vnd.openxmlformats-officedocument.presentation'],
  'excel': ['application/vnd.ms-excel', 'application/vnd.oasis.opendocument.spreadsheet', 'application/vnd.openxmlformats-officedocument.spreadsheet'],
  'archive': ['application/zip', 'application/x-gzip', 'application/x-bzip', 'application/x-tar', 'application/x-gtar', 'application/vnd.xara', '-archive', '-compressed', '-package', '+zip']
})

#macro (getAttachmentIcon $attachment $return)
  #set ($mediaType = $attachment.mimeType)
  #set ($icon = $NULL)
  #foreach ($entry in $fileIconByMediaType.entrySet())
    #foreach ($pattern in $entry.value)
      #if ($mediaType.startsWith($pattern) || $mediaType.endsWith($pattern))
        #set ($icon = $entry.key)
        #break
      #end
    #end
    #if ($icon)
      #break
    #end
  #end
  #set ($suffix = $stringtool.substringAfterLast($attachment.filename, '.'))
  #set ($codeSuffixes = ['html', 'css', 'js', 'java', 'c', 'cpp', 'c++', 'cs', 'h', 'sql', 'php', 'ruby'])
  #if (!$icon)
    #set ($icon = 'fa fa-paperclip')
  #elseif ($icon == 'text' &amp;&amp; $codeSuffixes.contains($suffix))
    #set ($icon = 'fa fa-file-code-o')
  #else
    #set ($icon = "fa fa-file-${icon}-o")
  #end
  #set ($return = $NULL)
  #setVariable("$return" $icon)
#end

#macro (addClassPropertiesChildren $classId $offset $limit $children)
  #set ($classRef = $services.model.resolveDocument($classId))
  #set ($classNode = $xwiki.getDocument($classRef))
  #foreach ($property in $classNode.getxWikiClass().properties)
    #addClassPropertyNode($property $classRef $children)
  #end
#end

#set ($iconByPropertyType = {
  'Boolean': 'check-square-o',
  'Date': 'calendar-o',
  'DBList': 'database',
  'Groups': 'group',
  'Password': 'asterisk',
  'Levels': 'lock',
  'StaticList': 'list',
  'TextArea': 'paragraph',
  'DBTreeList': 'sitemap',
  'Users': 'user'
})

#macro (addClassPropertyNode $property $classRef $siblings)
  #set ($classPropertyReference = $services.model.createEntityReference($property.name, 'CLASS_PROPERTY', $classRef))
  #set ($classPropertyId = $services.model.serialize($classPropertyReference, 'default'))
  #set ($icon = $iconByPropertyType.get($property.classType))
  #if (!$icon)
    #set ($icon = 'gear')
  #end
  #set ($discard = $siblings.add({
    'id': "classProperty:$classPropertyId",
    'text': $property.name,
    'icon': "fa fa-$icon",
    'children': false,
    'data': {
      'id': $classPropertyId,
      'type': 'classProperty',
      'validChildren': []
    }
  }))
#end

#macro (addObjectsChildren $docId $offset $limit $children)
  #set ($docRef = $services.model.resolveDocument($docId))
  #set ($docNode = $xwiki.getDocument($docRef))
  #foreach ($classId in $docNode.getxWikiObjects().keySet())
    #set ($discard = $children.add({
      'id': "objectsOfType:$docRef/$classId",
      'text': $classId,
      'icon': 'fa fa-cubes',
      'children': true,
      'data': {
        'type': 'objectsOfType',
        'validChildren': ['object', 'pagination'],
        'canDelete': $docNode.hasAccessLevel('edit')
      }
    }))
  #end
#end

#macro (addObjectsOfTypeChildren $nodeId $offset $limit $children)
  #set ($separatorIndex = $nodeId.lastIndexOf('/'))
  #set ($docId = $nodeId.substring(0, $separatorIndex))
  #set ($classId = $nodeId.substring($mathtool.add($separatorIndex, 1)))
  #set ($docRef = $services.model.resolveDocument($docId))
  #set ($docNode = $xwiki.getDocument($docRef))
  #set ($canEditDoc = $docNode.hasAccessLevel('edit'))
  #set ($objects = $docNode.getObjects($classId))
  #set ($totalCount = $objects.size())
  ## Limit the number of objects.
  #set ($objects = $objects.subList($offset, $mathtool.min($mathtool.add($offset, $limit), $totalCount)))
  #foreach ($object in $objects)
    #set ($objectReference = $services.model.createEntityReference("${classId}[$object.number]", 'OBJECT', $docRef))
    #addObjectNode($object $objectReference $children)
  #end
  #if ($objects.size() &gt;= $limit)
    #set ($newOffset = $mathtool.add($offset, $objects.size()))
    #if ($newOffset &lt; $totalCount)
      #addPaginationNode("objectsOfType:$nodeId" $newOffset $totalCount 'bricks' $children)
    #end
  #end
#end

#macro (addObjectNode $object $objectReference $siblings)
  #set ($objectId = $services.model.serialize($objectReference, 'default'))
  #set ($discard = $children.add({
    'id': "object:$objectId",
    'text': "[$object.number]",
    'icon': 'fa fa-cube',
    'children': true,
    'data': {
      'id': $objectId,
      'type': 'object',
      'validChildren': ['objectProperty'],
      'canDelete': $canEditDoc
    }
  }))
#end

#macro (addObjectChildren $objId $offset $limit $children)
  #set ($objRef = $services.model.resolveObject($objId))
  #set ($docNode = $xwiki.getDocument($objRef.extractReference('DOCUMENT')))
  ## Object name is: Space.Class[index]
  #set ($separatorIndex = $objRef.name.lastIndexOf('['))
  #set ($classId = $objRef.name.substring(0, $separatorIndex))
  #set ($objectNumber = $mathtool.toInteger($objRef.name.substring($mathtool.add($separatorIndex, 1),
    $mathtool.sub($objRef.name.length(), 1))))
  #set ($objNode = $docNode.getObject($classId, $objectNumber))
  #foreach ($property in $objNode.properties)
    #addObjectPropertyNode($property $objRef $children)
  #end
#end

#macro (addObjectPropertyNode $property $objRef $siblings)
  #set ($classId = $stringtool.substringBeforeLast($objRef.name, '['))
  #set ($classRef = $services.model.resolveDocument($classId, 'explicit', $objRef))
  #set ($xclass = $xwiki.getDocument($classRef).getxWikiClass())
  #set ($icon = $iconByPropertyType.get($xclass.get($property.name).classType))
  #if (!$icon)
    #set ($icon = 'gear')
  #end
  #set ($objectPropertyReference = $services.model.createEntityReference($property.name, 'OBJECT_PROPERTY', $objRef))
  #set ($objectPropertyId = $services.model.serialize($objectPropertyReference, 'default'))
  #set ($discard = $siblings.add({
    'id': "objectProperty:$objectPropertyId",
    'text': $property.name,
    'icon': "fa fa-$icon",
    'children': false,
    'data': {
      'id': $objectPropertyId,
      'type': 'objectProperty',
      'validChildren': []
    }
  }))
#end

#macro (getPath $nodeId $return)
  #set ($parts = $nodeId.split(':', 2))
  #if ($parts.size() == 1)
    #set ($path = [$nodeId])
  #else
    #set ($nodeType = $parts[0])
    #set ($nodeId = $parts[1])
    #set ($path = [])
    #evaluate("${escapetool.h}get$stringtool.capitalize($nodeType)Path(${escapetool.d}nodeId ${escapetool.d}path)")
  #end
  #set ($return = $NULL)
  #setVariable("$return" $path)
#end

#macro (getWikiPath $wikiRefOrId $path)
  #set ($wikiId = $wikiRefOrId.extractReference('WIKI').name)
  #if (!$wikiId)
    #set ($wikiId = $wikiRefOrId)
  #end
  #set ($wiki = $services.wiki.getById($wikiId))
  #maybeAddWikiNode($wiki $path {})
#end

#macro (getSpacePath $spaceRefOrId $path)
  #set ($spaceRef = $spaceRefOrId.extractReference('SPACE'))
  #if (!$spaceRef)
    #set ($spaceRef = $services.model.resolveSpace($spaceRefOrId))
  #end
  #if ($docTreeConfig.showWikis &amp;&amp; $xcontext.isMainWiki())
    #getWikiPath($spaceRef $path)
  #end
  #maybeAddSpaceNode($spaceRef $path {})
#end

#macro (getDocumentPath $docRefOrId $path)
  #set ($docRef = $docRefOrId.extractReference('DOCUMENT'))
  #if (!$docRef)
    #set ($docRef = $services.model.resolveDocument($docRefOrId))
  #end
  ## We use a linked list because #getDocumentPathRecursively() inserts the parents at the start of the list.
  #set ($docPath = $collectionstool.linkedList)
  #set ($discard = $docPath.add($docRef))
  #if ($docTreeConfig.showChildDocuments)
    ## Collect the references of all the ancestor documents.
    #getDocumentPathRecursively($docPath)
  #end
  #set ($rootDocRef = $docPath.get(0))
  #if ($docTreeConfig.showSpaces)
    #getSpacePath($rootDocRef $path)
  #elseif ($docTreeConfig.showWikis &amp;&amp; $xcontext.isMainWiki())
    #getWikiPath($rootDocRef $path)
  #end
  #foreach ($docRef in $docPath)
    #maybeAddDocumentNode($docRef $path {})
  #end
#end

#macro (getDocumentPathRecursively $path)
  #set ($docRef = $path.get(0))
  #set ($docNode = $xwiki.getDocument($docRef))
  #if ($docNode &amp;&amp; $docNode.parent != '')
    #set ($parentRef = $services.model.resolveDocument($docNode.parent, 'explicit', $docRef))
    ## If the wiki/space nodes are displayed then the documents are grouped by wiki/space and thus the parent document
    ## must remain in the same wiki/space.
    #if ((!$docTreeConfig.showSpaces || $docRef.lastSpaceReference.equals($parentRef.lastSpaceReference))
        &amp;&amp; (!$docTreeConfig.showWikis || $docRef.wikiReference.equals($parentRef.wikiReference)))
      #set ($discard = $path.add(0, $parentRef))
      #getDocumentPathRecursively($path)
    #end
  #end
#end

#macro (getAttachmentsPath $docRefOrId $path)
  #getDocumentPath($docRefOrId $path)
  #set ($docRef = $docRefOrId.extractReference('DOCUMENT'))
  #if (!$docRef)
    #set ($docRef = $services.model.resolveDocument($docRefOrId))
  #end
  #addAttachmentsNode($docRef $path)
#end

#macro (getAttachmentPath $attachmentId $path)
  #set ($attachmentReference = $services.model.resolveAttachment($attachmentId))
  #set ($documentReference = $attachmentReference.documentReference)
  #getAttachmentsPath($documentReference $path)
  #set ($attachment = $xwiki.getDocument($attachmentReference.parent).getAttachment($attachmentReference.name))
  #if ($attachment)
    #addAttachmentNode($attachment $path)
  #else
    #set ($discard = $path.add({}))
  #end
#end

#macro (getContextMenu $return)
  #set ($contextMenuByNodeType = {})
  #if ($docTreeConfig.showSpaces)
    #addSpaceContextMenu($contextMenuByNodeType)
  #end
  #addDocumentContextMenu($contextMenuByNodeType)
  #if ($docTreeConfig.showAttachments)
    #addAttachmentsContextMenu($contextMenuByNodeType)
    #addAttachmentContextMenu($contextMenuByNodeType)
  #end
  #set ($return = $NULL)
  #setVariable("$return" $contextMenuByNodeType)
#end

#macro (addSpaceContextMenu $contextMenuByNodeType)
  #set ($contextMenuByNodeType.space = {
    'createDocument': {
      'label': 'New Page',
      'icon': 'fa fa-file-o',
      'action': 'openLink',
      'parameters': {
        'urlProperty': 'createDocumentURL'
      }
    },
    'openLink': {
      'separator_before': true,
      'label': 'Go to Space',
      'icon': 'fa fa-external-link'
    },
    'refresh': {
      'label': 'Refresh',
      'icon': 'fa fa-refresh'
    },
    'paste': {
      'separator_before': true,
      'label': 'Paste Into Space',
      'icon': 'fa fa-clipboard'
    },
    'rename': {
      'label': 'Rename...',
      'icon': 'fa fa-pencil-square-o'
    },
    'remove': {
      'label': 'Delete',
      'icon': 'fa fa-trash-o',
      'parameters': {
        'confirmationMessage': 'Are you sure you want to move ALL the documents from this space to the recycle bin? If there are hidden documents in this space they will also be deleted.'
      }
    }
  })
#end

#macro (addDocumentContextMenu $contextMenuByNodeType)
  #set ($contextMenuByNodeType.document = {
    'createDocument': {
      'label': 'New Page',
      'icon': 'fa fa-file-o',
      'action': 'openLink',
      'parameters': {
        'urlProperty': 'createDocumentURL'
      }
    },
    'openLink': {
      'separator_before': true,
      'label': 'Go to Page',
      'icon': 'fa fa-external-link'
    },
    'refresh': {
      'label': 'Refresh',
      'icon': 'fa fa-refresh'
    },
    'cut': {
      'separator_before': true,
      'label': 'Cut',
      'icon': 'fa fa-scissors'
    },
    'copy': {
      'label': 'Copy',
      'icon': 'fa fa-files-o'
    },
    'paste': {
      'label': 'Paste',
      'icon': 'fa fa-clipboard'
    },
    'remove': {
      'separator_before': true,
      'label': 'Delete',
      'icon': 'fa fa-trash-o',
      'parameters': {
        'confirmationMessage': 'Are you sure you want to move this document to the recycle bin? All child documents will become orphan as a result.'
      }
    }
  })
#end

#macro (addAttachmentsContextMenu $contextMenuByNodeType)
  #set ($contextMenuByNodeType.attachments = {
    'openLink': {
      'label': 'Go to Attachments',
      'icon': 'fa fa-external-link'
    },
    'refresh': {
      'label': 'Refresh',
      'icon': 'fa fa-refresh'
    },
    'paste': {
      'separator_before': true,
      'label': 'Paste',
      'icon': 'fa fa-clipboard'
    },
    'remove': {
      'label': 'Delete All',
      'icon': 'fa fa-trash-o',
      'parameters': {
        'confirmationMessage': 'Are you sure you want to delete all the attachments of this page?'
      }
    }
  })
#end

#macro (addAttachmentContextMenu $contextMenuByNodeType)
  #set ($contextMenuByNodeType.attachment = {
    'openLink': {
      'label': 'Go to Attachment',
      'icon': 'fa fa-external-link'
    },
    'cut': {
      'separator_before': true,
      'label': 'Cut',
      'icon': 'fa fa-scissors'
    },
    'copy': {
      'label': 'Copy',
      'icon': 'fa fa-files-o'
    },
    'rename': {
      'separator_before': true,
      'label': 'Rename...',
      'icon': 'fa fa-pencil-square-o'
    },
    'remove': {
      'label': 'Delete',
      'icon': 'fa fa-trash-o',
      'parameters': {
        'confirmationMessage': 'Are you sure you want to delete this attachment?'
      }
    }
  })
#end

#macro (getSuggestions $return)
  #set ($limit = 6)
  #set ($text = "$!request.query")
  #set ($lists = [])
  #addDocumentSuggestions($text $limit $lists)
  #if ($docTreeConfig.showAttachments)
    #addAttachmentSuggestions($text $limit $lists)
  #end
  #if ($docTreeConfig.showSpaces)
    #addSpaceSuggestions($text $limit $lists)
  #end
  #limitTotalCount($lists $limit)
  #set ($output = [])
  #foreach ($list in $lists)
    #foreach ($node in $list)
      ## Use the node path as suggestion info.
      #getPath($node.id $path)
      #displayPath($path)
      #set ($node.data.info = $stringtool.join($path.subList(0, $mathtool.sub($path.size(), 1)), ' / '))
      #set ($discard = $output.add($node))
    #end
  #end
  #set ($return = $NULL)
  #setVariable("$return" $output)
#end

#macro (addSpaceSuggestions $text $limit $suggestions)
  #searchSpaces($text $limit $spaceReferences)
  #set ($spaceSuggestions = [])
  #foreach ($spaceReference in $spaceReferences)
    #maybeAddSpaceNode($spaceReference $spaceSuggestions)
  #end
  #set ($discard = $suggestions.add($spaceSuggestions))
#end

#macro (searchSpaces $text $limit $return)
  #set ($statement = 'where upper(doc.space) like upper(?)')
  #set ($displayHiddenDocuments = $xwiki.getUserPreference('displayHiddenDocuments'))
  #if ("$!displayHiddenDocuments" != '1')
    #set ($statement = "$statement and (doc.hidden &lt;&gt; true or doc.hidden is null)")
  #end
  #set ($spaceNames = $xwiki.searchSpacesNames($statement, $limit, 0, ["%$text%"]))
  #set ($spaceReferences = [])
  #set ($wikiReference = $services.model.createWikiReference($xcontext.database))
  #foreach ($spaceName in $spaceNames)
    #set ($discard = $spaceReferences.add($services.model.createSpaceReference($spaceName, $wikiReference)))
  #end
  #set ($return = $NULL)
  #setVariable("$return" $spaceReferences)
#end

#macro (addDocumentSuggestions $text $limit $suggestions)
  #searchDocuments($text $limit $documentReferences)
  #set ($docSuggestions = [])
  #foreach ($documentReference in $documentReferences)
    #maybeAddDocumentNode($documentReference $docSuggestions)
  #end
  #set ($discard = $suggestions.add($docSuggestions))
#end

#macro (searchDocuments $text $limit $return)
  #if ($xwiki.exists('XWiki.SuggestSolrMacros'))
    #searchDocumentsSolr($text $limit $return)
  #else
    #searchDocumentsDatabase($text $limit $return)
  #end
#end

#macro (searchDocumentsSolr $text $limit $return)
  #set ($params = $stringtool.join([
    'fq=type:DOCUMENT',
    'fq=doclocale:""',
    'qf=title^6 name^4 doccontent^2 doccontentraw',
    'fl=wiki space name'
  ], $util.newline))
  #createSearchSuggestQuery($params $text $query)
  #set ($discard = $query.setLimit($limit))
  #set ($documentReferences = [])
  #foreach ($result in $query.execute()[0].results)
    #set ($documentReference = $services.model.createDocumentReference($result.wiki, $result.space, $result.name))
    #set ($discard = $documentReferences.add($documentReference))
  #end
  #set ($return = $NULL)
  #setVariable("$return" $documentReferences)
#end

#macro (searchDocumentsDatabase $text $limit $return)
  #set ($statement = 'where doc.translation = 0 and (upper(doc.name) like upper(:text) or upper(doc.title) like upper(:text))')
  #set ($query = $services.query.hql($statement).addFilter('hidden').setLimit($limit).bindValue('text', "%$text%"))
  #set ($documentReferences = [])
  #foreach ($docFullName in $query.execute())
    #set ($discard = $documentReferences.add($services.model.resolveDocument($docFullName)))
  #end
  #set ($return = $NULL)
  #setVariable("$return" $documentReferences)
#end

#macro (addAttachmentSuggestions $text $limit $suggestions)
  #searchAttachments($text $limit $attachmentReferences)
  #set ($attachmentSuggestions = [])
  #foreach ($attachmentReference in $attachmentReferences)
    #set ($attachment = $xwiki.getDocument($attachmentReference.parent).getAttachment($attachmentReference.name))
    #addAttachmentNode($attachment $attachmentSuggestions)
  #end
  #set ($discard = $suggestions.add($attachmentSuggestions))
#end

#macro (searchAttachments $text $limit $return)
  #if ($xwiki.exists('XWiki.SuggestSolrMacros'))
    #searchAttachmentsSolr($text $limit $return)
  #else
    #searchAttachmentsDatabase($text $limit $return)
  #end
#end

#macro (searchAttachmentsSolr $text $limit $return)
  #set ($params = $stringtool.join([
    'fq=type:ATTACHMENT',
    'qf=filename^4 attcontent',
    'fl=wiki space name filename'
  ], $util.newline))
  #createSearchSuggestQuery($params $text $query)
  #set ($discard = $query.setLimit($limit))
  #set ($attachmentReferences = [])
  #foreach ($result in $query.execute()[0].results)
    #set ($documentReference = $services.model.createDocumentReference($result.wiki, $result.space, $result.name))
    #set ($attachmentReference = $services.model.createAttachmentReference($documentReference, $result.filename))
    #set ($discard = $attachmentReferences.add($attachmentReference))
  #end
  #set ($return = $NULL)
  #setVariable("$return" $attachmentReferences)
#end

#macro (searchAttachmentsDatabase $text $limit $return)
  #set ($statement = 'where upper(attach.filename) like upper(?)')
  #set ($displayHiddenDocuments = $xwiki.getUserPreference('displayHiddenDocuments'))
  #if ("$!displayHiddenDocuments" != '1')
    #set ($statement = "$statement and (doc.hidden &lt;&gt; true or doc.hidden is null)")
  #end
  #set ($attachments = $xwiki.searchAttachments($statement, $limit, 0, ["%$text%"]))
  #set ($attachmentReferences = [])
  #foreach ($attachment in $attachments)
    #set ($discard = $attachmentReferences.add($services.model.createAttachmentReference(
      $attachment.document.documentReference, $attachment.filename)))
  #end
  #set ($return = $NULL)
  #setVariable("$return" $attachmentReferences)
#end

#macro (displayPath $path)
  #foreach ($node in $path)
    #set ($discard = $path.set($foreach.index, $node.text))
  #end
#end

#macro (limitTotalCount $lists $limit)
  ## Prepare the input.
  #set ($input = [])
  #foreach ($list in $lists)
    ## We use queues to be able to easily remove items from the start.
    #set ($queue = $collectionstool.queue)
    #set ($discard = $queue.addAll($list))
    #set ($discard = $input.add($queue))
    ## We will add (part of) the items back later.
    #set ($discard = $list.clear())
  #end
  ## Limit the total item count.
  #set ($index = -1)
  #foreach ($count in [1..$limit])
    #foreach ($i in [1..$input.size()])
      #set ($newIndex = ($index + $i) % $input.size())
      #if ($input.get($newIndex).size() &gt; 0)
        #set ($index = $newIndex)
        #break
      #end
    #end
    #if ($index &lt; 0 || $input.get($index).isEmpty())
      #break
    #else
      #set ($discard = $lists.get($index).add($input.get($index).poll()))
    #end
  #end
#end
{{/velocity}}</content>
</xwikidoc>
