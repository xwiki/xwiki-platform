$response.setContentType("text/xml")
##
#set($classname = $request.get("classname"))
#set($fieldname = $request.get("fieldname"))
#set($firCol = "$!{request.get('firCol')}")
#set($secCol = "$!{request.get('secCol')}")
#set($templatename = $classname + 'Template')
#set($p = $xwiki.getDocument($classname).getxWikiClass().get($fieldname).getPropertyClass())
#set($classnametosearch = $!{p.getCustomMappingMap()['classname']})
#set($propnametosearch = $!{p.getCustomMappingMap()['idField']})
#set($hibquery = "$!p.getSql()")
##
## Determine what was the input. If the property accepts multiple values and has separators, then
## use only the last token as the input.
## TODO: What if the user is actually typing in the middle of the input string? The actual word for
## which the autocompletion is triggered should be sent from JS.
##
#set($input = "$!{request.get('input').toLowerCase()}")
#set($sep = "$!{p.getSeparators()}")
#if($p.isMultiSelect() && ($sep != "")) ### has separators
  #set($input_words = $stringtool.split($input, $sep))
  #foreach($i in $input_words)
    #set($input = $i.trim())
  #end
#end
##
######################### User hibernate query
#if("$!hibquery" != "")
  #if($secCol != "-")
    ### two columns, hidden input
    #set($likeCol = $secCol)
    #set($resultsType = 1)
  #else ### one column, no hidden input
    #set($likeCol = $firCol)
    #set($resultsType = 2)
  #end
  #set($whereidx = $hibquery.toLowerCase().indexOf("where"))
  #if($whereidx < 0)
    #set($like = " where lower("+ $likeCol.replaceAll("[^a-zA-Z0-9_.]", "") + ") like '%${input}%'")
    #set($hibquery = $hibquery.concat($like))
  #else
    #set($whereidx = $whereidx + 5)
    #set($like = " lower("+ $likeCol.replaceAll("[^a-zA-Z0-9_.]", "") + ") like :userinput and")
    #set($hibquery = "${hibquery.substring(0, $whereidx)}${like}${hibquery.substring($whereidx)}")
  #end
  #set($results = $services.query.hql($hibquery).setLimit(30).setOffset(0).bindValue('userinput', "%${input}%").execute())
  <?xml version="1.0" encoding="UTF-8"?>
  <results type="${resultsType}">
  #foreach($res in $results)
    #set($info = '')
    #set($rs = $res)
    #foreach($r in $res)
      #if(${foreach.count} == 1)
        #set($info = $r)
      #elseif(${foreach.count} == 2)
        #set($rs = $r)
      #end
    #end
    #if(($info != '-') && ($rs != '-'))
      <rs id="${foreach.count}" info="$!{escapetool.xml($info)}">$!{escapetool.xml($rs)}</rs>
    #end
  #end
  </results>
#elseif(!$classnametosearch.isEmpty()) ## hibquery == ""
  #if(!$propnametosearch.isEmpty())
    #set($query = "select distinct doc.fullName, obj.$propnametosearch from Document doc, doc.object($classnametosearch) as obj where lower(obj.$propnametosearch) like :userinput")
    #set($resultsType = "6")
  #else ## if propnametosearch == ""
    #set($query = "select distinct doc.fullName, doc.fullName from Document doc, doc.object($classnametosearch) as obj where lower(doc.fullName) like :userinput")
    #set($resultsType = "7")
  #end ## if propnametosearch != ""
  #set($results = $services.query.xwql($query).setLimit(30).setOffset(0).bindValue('userinput', "%${input}%").execute())
  <?xml version="1.0" encoding="UTF-8"?>
  <results type="${resultsType}">
  #foreach($res in $results)
    #set($info = '')
    #set($rs = $res)
    #foreach($r in $res)
      #if(${foreach.count} == 1)
        #set($info = $r)
      #elseif(${foreach.count} == 2)
        #set($rs = $r)
      #end
    #end
    #if(($info != '-') && ($rs != '-'))
      <rs id="${velocityCount}" info="$!{escapetool.xml($info)}">$!{escapetool.xml($rs)}</rs>
    #end
  #end
  </results>
#else ## if hibquery == "" and classnametosearch == ""
  <?xml version="1.0" encoding="UTF-8"?>
  <results type="0" />
#end ## if hibquery != "" and classnametosearch != ""
