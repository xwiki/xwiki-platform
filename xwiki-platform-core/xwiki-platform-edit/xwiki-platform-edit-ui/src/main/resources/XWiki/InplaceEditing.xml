<?xml version="1.1" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc version="1.4" reference="XWiki.InplaceEditing" locale="">
  <web>XWiki</web>
  <name>InplaceEditing</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <parent>WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <version>1.1</version>
  <title/>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>true</hidden>
  <content>{{velocity wiki="false"}}
#if ($request.action == 'lock')
  ## This could be moved later to a Velocity template (e.g. lock.vm).
  #template('edit_macros.vm')
  #getEditConfirmation()
  #if ($editConfirmation)
    ## Ask for confirmation to force the lock.
    #set ($discard = $response.setStatus(423))
    #jsonResponse($editConfirmation)
  #else
    ## Lock the document for editing.
    #set ($discard = $response.sendRedirect($tdoc.getURL('lock', $escapetool.url({
      'ajax': 1,
      'action': $request.lockAction,
      'language': $tdoc.realLocale
    }))))
  #end
#end
{{/velocity}}</content>
  <object>
    <name>XWiki.InplaceEditing</name>
    <number>0</number>
    <className>XWiki.JavaScriptExtension</className>
    <guid>700dc756-1a3a-49e0-854f-c2ecb0d8e970</guid>
    <class>
      <name>XWiki.JavaScriptExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <defaultValue>long</defaultValue>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage|onDemand|always</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>require.config({
  paths: {
    'actionButtons': $jsontool.serialize($xwiki.getSkinFile('js/xwiki/actionbuttons/actionButtons.js', true)),
    'autoSave': $jsontool.serialize($xwiki.getSkinFile('js/xwiki/editors/autosave.js', true)),
    // Required in case the user needs to resolve merge conflicts on save.
    'xwiki-diff': $jsontool.serialize($xwiki.getSkinFile('uicomponents/viewers/diff.js'))
  }
});

define('xwiki-document-api', ['jquery'], function($) {
  var getOldAPI = function(xwikiDocument) {
    return (xwikiDocument.documentReference &amp;&amp; new XWiki.Document(xwikiDocument.documentReference)) ||
      XWiki.currentDocument;
  };

  return {
    /**
     * @return this document's real locale
     */
    getRealLocale: function() {
      var realLocale = this.language;
      if (typeof realLocale === 'string' &amp;&amp; realLocale !== '') {
        // This document is a translation.
      } else if (this.translations &amp;&amp; typeof this.translations['default'] === 'string') {
        // This is the original document.
        realLocale = this.translations['default'];
      } else {
        // The document locale is not specified. Use the UI locale.
        realLocale = $('html').attr('lang');
      }
      return realLocale;
    },

    /**
     * @return the URL that can be used to perform the specified action on this document
     */
    getURL: function(action, queryString, fragment) {
      if (queryString &amp;&amp; typeof queryString === 'object') {
        queryString = $.param(queryString, true);
      }
      // Forward the call to the old API.
      var oldAPI = getOldAPI(this);
      return oldAPI.getURL.call(oldAPI, action, queryString, fragment);
    },

    /**
     * @param queryString the query string to add to the URL; it can be a string or a plain JavaScript object
     * @return the URL that can be used to retrieve this document's (JSON) data, taking into account whether this is the
     *         original document or a translation
     */
    getRestURL: function(queryString) {
      var oldAPI = getOldAPI(this);
      if (queryString &amp;&amp; typeof queryString === 'object') {
        queryString = $.param(queryString, true);
      }
      var entity = this.language &amp;&amp; ('translations/' + encodeURIComponent(this.language));
      return oldAPI.getRestURL(entity, queryString);
    },

    /**
     * Render the title and the content of this document.
     *
     * @param forView whether to render the document for view (without the rendering annotations) or for edit (with the
     *          rendering annotations); when rendering for edit some transformations might not be executed
     * @return a promise that resolves to this document instance if the render request succeeds
     */
    render: function(forView) {
      var queryString = {
        xpage: 'get',
        outputTitle: true,
        outputSyntax: forView ? null : 'annotatedxhtml',
        language: this.getRealLocale(),
        // Make sure the response is not retrieved from cache (IE11 doesn't obey the caching HTTP headers).
        timestamp: new Date().getTime()
      };
      var thisXWikiDocument = this;
      return $.get(this.getURL('view'), queryString).fail(function() {
        new XWiki.widgets.Notification(
          $jsontool.serialize($services.localization.render('edit.inplace.page.renderFailed')),
          'error'
        );
      }).then(function(html) {
        // Render succeeded.
        var container = $('&lt;div/&gt;').html(html);
        return $.extend(thisXWikiDocument, {
          renderedTitle: container.find('#document-title h1').html(),
          renderedContent: container.find('#xwikicontent').html()
        });
      }, function() {
        // Render failed.
        return thisXWikiDocument;
      });
    },

    /**
     * Reload this document's (JSON) data.
     *
     * @return a promise that resolves to this document instance if the reload request succeeds
     */
    reload: function() {
      var thisXWikiDocument = this;
      return $.getJSON(this.getRestURL(), {
        // Make sure the response is not retrieved from cache (IE11 doesn't obey the caching HTTP headers).
        timestamp: new Date().getTime()
      }).then(function(newXWikiDocument) {
        // Reload succeeded.
        // Resolve the document reference.
        thisXWikiDocument.documentReference = XWiki.Model.resolve(newXWikiDocument.id, XWiki.EntityType.DOCUMENT);
        // We were able to load the document so it's not new.
        thisXWikiDocument.isNew = false;
        return $.extend(thisXWikiDocument, newXWikiDocument);
      }, function() {
        // Reload failed.
        return thisXWikiDocument;
      });
    },

    /**
     * Lock this document for the specified action. The request fails if the document is already locked, unless the lock
     * is forced.
     *
     * @return a promise that resolves to this document instance if the lock request succeeds
     */
    lock: function(action, force) {
      var thisXWikiDocument = this;
      action = action || 'edit';
      return $.getJSON(this.getURL('get'), {
        sheet: 'XWiki.InplaceEditing',
        action: 'lock',
        lockAction: action,
        force: force,
        language: this.getRealLocale(),
        outputSyntax: 'plain',
        // Make sure the response is not retrieved from cache (IE11 doesn't obey the caching HTTP headers).
        timestamp: new Date().getTime()
      }).then(function() {
        // Lock succeeded.
        thisXWikiDocument.locked = action;
        return thisXWikiDocument;
      }, function(response) {
        // Lock failed.
        delete thisXWikiDocument.locked;
        // Check if the user can force the lock.
        var lockConfirmation = response.responseJSON;
        if (response.status === 423 &amp;&amp; lockConfirmation) {
          // The user can force the lock, but needs confirmation.
          thisXWikiDocument.lockConfirmation = lockConfirmation;
        }
        return thisXWikiDocument;
      });
    },

    /**
     * Unlock this document for the specified action, by sending a beacon, if the browser supports it, or by making a
     * synchronous HTTP request, because this function can be called just before the window is unloaded.
     */
    unlock: function(action) {
      action = action || 'edit';
      this.locked = false;
      var url = this.getURL('cancel', $.param({
        ajax: 1,
        action: action,
        language: this.getRealLocale()
      }));
      if (navigator.sendBeacon) {
        navigator.sendBeacon(url);
      } else {
        // Make a synchronous request otherwise, because the page can unload before the unlock request is sent.
        // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests
        $.ajax({type: 'GET', url: url, async: false});
      }
    }
  };
});

define('editInPlace', [
  'jquery',
  // We need this in order to access information about the current page.
  'xwiki-meta',
  // We need this in order to easily work with the XWiki document JSON.
  'xwiki-document-api',
  // We need this for the confirmation modals.
  'bootstrap',
  // We need this in order to catch events triggered by actionButtons.js using Prototype.js
  'xwiki-events-bridge'
], function($, xcontext, xwikiDocumentAPI) {
  var preload = function() {
    loadCSS($jsontool.serialize($xwiki.getSkinFile('js/xwiki/actionbuttons/actionButtons.css', true)));
    loadCSS($jsontool.serialize($xwiki.getSkinFile('js/xwiki/editors/autosave.css', true)));
    // Required in case the user needs to resolve merge conflicts on save.
    loadCSS($jsontool.serialize($xwiki.getSkinFile('uicomponents/viewers/diff.css', true)));
    return initActionButtons();
  };

  var loadCSS = function(url) {
    var link = $('&lt;link&gt;').attr({
      type: 'text/css',
      rel: 'stylesheet',
      href: url
    }).appendTo('head');
  };

  var editPage = function() {
    return editInPlace({
      afterEdit: function() {
        $('#document-title-input').focus().select();
      }
    });
  };

  var editSection = function(sectionId) {
    return editInPlace({
      lockFailed: function() {
        // Revert the changes done on #xwikicontent.
        $('#xwikicontent').removeAttr('tabindex').children(':header').children('.edit_section').removeClass('hidden');
      },
      afterEdit: function() {
        // We don't need the tabindex attribute anymore now that the content is editable.
        $('#xwikicontent').removeAttr('tabindex');
        if (sectionId) {
          // Select the heading of the specified section.
          $('#xwikicontent &gt; #' + escapeSelector(sectionId)).each(function() {
            selectText(this);
          });
        }
      }
    });
  };

  var escapeSelector = function(selector) {
    if (window.CSS &amp;&amp; typeof CSS.escape === 'function') {
      // Not supported by Internet Explorer.
      return CSS.escape(selector);
    } else if (typeof $.escapeSelector === 'function') {
      // Added in jQuery 3.0
      return $.escapeSelector(selector);
    } else if (typeof selector === 'string') {
      // Simple implementation.
      // See https://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/
      return selector.replace(/(:|\.|\[|\]|,|=|@)/g, '\\$1');
    } else {
      return selector;
    }
  };

  // We preserve the document data between edits in order to be able to know which document translation should be edited
  // (e.g. when the document translation is missing and we create it, the next edit session should target the created
  // translation).
  var currentXWikiDocument = $.extend({
    language: xcontext.locale
  }, xwikiDocumentAPI);

  var editInPlace = function(options) {
    options = $.extend({
      afterEdit: function() {},
      lockFailed: function() {}
    }, options);
    $('#xwikicontent').addClass('loading');
    // Lock the document first.
    return lock(currentXWikiDocument).fail(options.lockFailed)
      // Then load the document only if we managed to lock it.
      .then(load)
      // Then load the editors only if we managed to load the document.
      .then(edit).done(options.afterEdit).always(function() {
        $('#xwikicontent').removeClass('loading');
      // Then wait for an action (save, cancel, reload) only if the editors were loaded successfuly.
      }).then(maybeSave)
      // Then unlock the document both when the edit ended with success and with a failure.
      .then(unlock, unlock)
      // Finally view the document both when the edit ended with success and with a failure.
      .then(view, view);
  };

  var lock = function(xwikiDocument) {
    return xwikiDocument.lock().then(null, function(xwikiDocument) {
      // If the document was already locked then we need to ask the user if they want to force the lock.
      if (xwikiDocument.lockConfirmation) {
        var confirmation = xwikiDocument.lockConfirmation;
        delete xwikiDocument.lockConfirmation;
        return maybeForceLock(confirmation).then($.proxy(xwikiDocument, 'lock', 'edit', true));
      } else {
        new XWiki.widgets.Notification(
          $jsontool.serialize($services.localization.render('edit.inplace.page.lockFailed')),
          'error'
        );
        return xwikiDocument;
      }
    });
  };

  var maybeForceLock = function(confirmation) {
    var deferred = $.Deferred();
    // Reuse the confirmation modal once it is created.
    var modal = $('.force-edit-lock-modal');
    if (modal.length === 0) {
      modal = createForceLockModal();
    }
    // Update the deferred that needs to be resolved or rejected.
    modal.data('deferred', deferred);
    // Update the confirmation modal.
    modal.find('.modal-title').text(confirmation.title);
    modal.find('.modal-body').html(confirmation.message);
    modal.find('.modal-footer .btn-default').text(confirmation.reject);
    if (confirmation.confirm) {
      modal.find('.modal-footer .btn-warning').show().text(confirmation.confirm);
    } else {
      modal.find('.modal-footer .btn-warning').hide();
    }
    // Show the confirmation modal.
    modal.modal('show');
    return deferred.promise();
  };

  var createForceLockModal = function() {
    var modal = $([
      '&lt;div class="modal fade force-edit-lock-modal" tabindex="-1" role="dialog"&gt;',
        '&lt;div class="modal-dialog" role="document"&gt;',
          '&lt;div class="modal-content"&gt;',
            '&lt;div class="modal-header"&gt;',
              '&lt;button type="button" class="close" data-dismiss="modal"&gt;',
                '&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;',
              '&lt;/button&gt;',
              '&lt;h4 class="modal-title"&gt;&lt;/h4&gt;',
            '&lt;/div&gt;',
            '&lt;div class="modal-body"&gt;&lt;/div&gt;',
            '&lt;div class="modal-footer"&gt;',
              '&lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;&lt;/button&gt;',
              '&lt;button type="button" class="btn btn-warning"&gt;&lt;/button&gt;',
            '&lt;/div&gt;',
          '&lt;/div&gt;',
        '&lt;/div&gt;',
      '&lt;/div&gt;'
    ].join(''));
    modal.find('.close').attr('aria-label', $jsontool.serialize($services.localization.render('edit.inplace.close')));
    modal.find('.modal-footer .btn-warning').click(function() {
      // The user has confirmed they want to force the lock.
      modal.data('deferred').resolve();
      modal.modal('hide');
    });
    modal.on('hide.bs.modal', function() {
      // If the lock promise is not yet resolved when the modal is closing then it means the modal was canceled,
      // i.e. the user doesn't want to force the lock.
      var deferred = modal.data('deferred');
      if (deferred.state() === 'pending') {
        deferred.reject();
      }
    });
    return modal.appendTo('body').modal();
  };

  var load = function(xwikiDocument) {
    return xwikiDocument.reload().done(function(xwikiDocument) {
      // Clone the current document version and keep a reference to it in order to be able to restore it on cancel.
      xwikiDocument.originalDocument = $.extend(true, {
        renderedTitle: $('#document-title h1').html(),
        renderedContent: $('#xwikicontent').html()
      }, xwikiDocument);
    }).fail(function() {
      new XWiki.widgets.Notification($jsontool.serialize($services.localization.render('edit.inplace.page.loadFailed')),
        'error');
    // Render the document for edit, in order to have the annotated content HTML. The annotations are used to protect
    // the rendering transformations (e.g. macros) when editing the content.
    }).then($.proxy(render, null, false));
  };

  /**
   * @param forView whether to render the document for view (without the rendering annotations) or for edit (with the
   *          rendering annotations); when rendering for edit some transformations might not be executed
   * @param xwikiDocument the document to render
   */
  var render = function(forView, xwikiDocument) {
    return xwikiDocument.render(forView);
  };

  var maybeSave = function(xwikiDocument) {
    return waitForAction(xwikiDocument).then(function(action) {
      switch(action.name) {
        case 'save': return save({
          document: action.document,
          'continue': action.data &amp;&amp; action.data['continue']
        });
        case 'reload': return reload(action.document);
        default: return cancel(action.document);
      }
    });
  };

  var waitForAction = function(xwikiDocument) {
    var deferred = $.Deferred();
    // We wait for the first save, reload or cancel event, whichever is triggered first. Note that the event listeners
    // that are not executed first will remain registered but that doesn't cause any problems because the state of a
    // deferred object (promise) cannot change once it was resolved. So the first event that fires will resolve the
    // promise and the remaining events won't be able to change that. The remaining event listeners could be called
    // later but they won't have any effect on the deferred object.
    $(document).one([
      'xwiki:actions:save',
      'xwiki:actions:reload',
      'xwiki:actions:cancel',
    ].join(' '), function(event, data) {
      deferred.resolve({
        name: event.type.substring('xwiki:actions:'.length),
        document: xwikiDocument,
        data: data
      });
    });
    return deferred.promise();
  };

  var save = function(data) {
    // Push the changes to the server.
    return push(data.document).then(function(xwikiDocument) {
      // Save succeeded.
      return shouldReload(xwikiDocument).then(
        // The document was saved with merge and thus if we want to continue eding we need to reload the editor (because
        // its content doesn't match the saved content).
        reload,
        // No need to reload the editor because either the action was Save &amp; View or there was no merge on save.
        $.proxy(maybeContinueEditing, null, data['continue'])
      );
    // Save failed. Continue editing because we may have unsaved content.
    }, maybeSave);
  };

  var push = function(xwikiDocument) {
    // Let actionButtons.js do the push. We just catch the result.
    var deferred = $.Deferred();
    // We wait for the save request to either succeed or fail. Note that one of the event listeners will remain
    // registered but that doesn't cause any problems because the state of a deferred object (promise) cannot change
    // once it was resolved or rejected. So the first event that fires will resolve/reject the promise and the remaining
    // event won't be able to change that. The remaining event listener could be called later but it won't have any
    // effect.
    $(document).one('xwiki:document:saved', $.proxy(deferred, 'resolve', xwikiDocument));
    $(document).one('xwiki:document:saveFailed', $.proxy(deferred, 'reject', xwikiDocument));
    return deferred.promise();
  };

  var maybeContinueEditing = function(continueEditing, xwikiDocument) {
    var afterReloadAndRender = function(success, xwikiDocument) {
      if (continueEditing) {
        if (success) {
          // Update the original version in order to be able to restore it on cancel.
          delete xwikiDocument.originalDocument;
          xwikiDocument.originalDocument = $.extend(true, {}, xwikiDocument);
        }
        // Continue editing.
        return maybeSave(xwikiDocument);
      } else {
        // This is the final version. We stop editing even if the reload / render failed.
        return xwikiDocument;
      }
    };

    // Reload the document JSON data (to have the new version) and render the document for view. We need the view HTML
    // both if we stop editing now and if we continue but cancel the edit later.
    return xwikiDocument.reload().then($.proxy(render, null, true)).then(
      $.proxy(afterReloadAndRender, null, /* success: */ true),
      $.proxy(afterReloadAndRender, null, /* success: */ false)
    );
  };

  var cancel = function(xwikiDocument) {
    // Simply return the original version to be restored.
    return xwikiDocument.originalDocument;
  };

  // Unlock the document so that other users can edit it.
  var unlock = function(xwikiDocument) {
    // Check if we're still editing.
    if (xwikiDocument.locked &amp;&amp; $('#document-title-input').length &gt; 0) {
      xwikiDocument.unlock();
    }
    return xwikiDocument;
  };

  // Make sure we unlock the document when the user navigates to another page.
  $(window).on('unload pagehide', $.proxy(unlock, null, currentXWikiDocument));

  var shouldReload = function(xwikiDocument) {
    var reloadEventFired = false;
    $(document).one('xwiki:actions:reload.maybe', function() {
      reloadEventFired = true;
    });
    var deferred = $.Deferred();
    // Wait a bit to see if the reload event is fired.
    setTimeout(function() {
      // Remove the listener in case the reload event wasn't fired.
      $(document).off('xwiki:actions:reload.maybe');
      if (reloadEventFired) {
        deferred.resolve(xwikiDocument);
      } else {
        deferred.reject(xwikiDocument);
      }
    }, 0);
    return deferred.promise();
  };

  var reload = function(xwikiDocument) {
    // Leave the edit mode and then re-enter.
    return view(xwikiDocument, true).then(editInPlace);
  };

  var view = function(xwikiDocument, reload) {
    // Destroy the editors before returning to view.
    $(document).trigger('xwiki:actions:view', {document: xwikiDocument});
    $('#document-title h1').html(xwikiDocument.renderedTitle);
    $('#xwikicontent').html(xwikiDocument.renderedContent);
    if (!reload) {
      // If the user has canceled the edit then the restored page content may include the section edit links. Show them
      // in case they were hidden.
      $('#xwikicontent').children(':header').children('.edit_section').removeClass('hidden');
      // Let others know that the DOM has been updated, in order to enhance it.
      $(document).trigger('xwiki:dom:updated', {'elements': $('#xwikicontent').toArray()});
    }
    return $.Deferred().resolve(xwikiDocument).promise();
  };

  var edit = function(xwikiDocument) {
    return initActionButtons(xwikiDocument).then(initTitleEditor).then(initContentEditor)
      .then(startRealTimeEditingSession);
  };

  var initActionButtons = function(xwikiDocument) {
    if (xwikiDocument) {
      maybeShowTranslateButton(xwikiDocument);
    }
    var editContent = $('#xwikicontent');
    // We need the wrapper because #xwikicontent uses Bootstrap grid (col-xs-12) which is implemented with CSS float.
    // Thus we need to use the grid for the sticky buttons also otherwise the postion is badly computed when scrolling
    // (because of the float on the previous element). This wouldn't be needed if we were using position:sticky, which
    // we can't use yet because it's not implemented on IE11 which we still have to support.
    var actionButtonsWrapper = editContent.nextAll('.sticky-buttons-wrapper');
    if (actionButtonsWrapper.length === 0) {
      actionButtonsWrapper = $('&lt;div class="sticky-buttons-wrapper col-xs-12"&gt;' +
        '&lt;div class="inplace-editing-buttons sticky-buttons"/&gt;&lt;/div&gt;').insertAfter(editContent);
      var actionButtons = actionButtonsWrapper.children('.sticky-buttons').data('xwikiDocument', xwikiDocument)
        .toggle(!!xwikiDocument);
      return loadActionButtons(actionButtons);
    } else {
      // If we're editing a page..
      if (xwikiDocument) {
        // ..then make sure the action buttons are displayed right away (don't wait for the user to scroll).
        actionButtonsWrapper.children('.sticky-buttons').data('xwikiDocument', xwikiDocument).show();
        // The action buttons are disabled on Save &amp; View. We don't reload the page on Save &amp; View and we reuse the
        // action buttons so we need to re-enable them each time we enter the edit mode.
        fakeForm.enable();
        $(document).trigger('xwiki:dom:refresh');
      }
      return $.Deferred().resolve(xwikiDocument).promise();
    }
  };

  var maybeShowTranslateButton = function(xwikiDocument) {
    var xwikiDocumentLocale = xwikiDocument.getRealLocale();
    var uiLocale = $('html').attr('lang');
    if (xwikiDocumentLocale &amp;&amp; xwikiDocumentLocale !== uiLocale) {
      $('#tmTranslate').off('click.translate').on('click.translate', function(event) {
        event.preventDefault();
        $(this).addClass('hidden');
        xwikiDocument.language = uiLocale;
        // Update the document translation fields that are not 'shared' with the original document.
        xwikiDocument.isNew = true;
        delete xwikiDocument.version;
        delete xwikiDocument.majorVersion;
        delete xwikiDocument.minorVersion;
        $('#document-title-input').focus().select();
        var message = $jsontool.serialize($services.localization.render('edit.inplace.page.translation',
          ['__locale__']));
        new XWiki.widgets.Notification(
          message.replace('__locale__', uiLocale),
          'info'
        );
      }).removeClass('hidden');
      var message = $jsontool.serialize($services.localization.render('edit.inplace.page.original', ['__locale__']));
      new XWiki.widgets.Notification(
        message.replace('__locale__', xwikiDocumentLocale),
        'info'
      );
    }
  };

  var loadActionButtons = function(actionButtons) {
    $(document).on('xwiki:actions:view', function() {
      // Blur the action buttons first to re-enable the "disabled in inputs" shortcut keys (e.g. the page edit
      // shortcut), then disable the action buttons in order to disable their shortcut keys while we're not editing
      // in-place (e.g. prevent the Save shortcut while the user is only viewing the page). Finally hide the action
      // buttons to have them ready for the next editing session (the user can save or cancel and then edit again
      // without reloading the page).
      actionButtons.find(':input').blur().prop('disabled', true).end().hide();
      // Hide the translate button because it can be used only in edit mode for the moment.
      $('#tmTranslate').addClass('hidden');
    });
    return $.get(XWiki.currentDocument.getURL('get'), {
      xpage: 'editactions'
    }).then(function(html) {
      actionButtons.html(html);
      // Fix the name of the Save &amp; View action.
      actionButtons.find('.btn-primary').first().attr('name', 'action_save');
      // Append the hidden input field that keeps the CSRF token.
      $('&lt;input type="hidden" name="form_token" /&gt;').val(xcontext.form_token).appendTo(actionButtons);
      // We need a place where actionButtons.js can add more hidden inputs.
      actionButtons.append('&lt;div class="hidden extra"/&gt;');
      var deferred = $.Deferred();
      require(['actionButtons', 'xwiki-diff', 'autoSave'], function() {
        overrideEditActions();
        overrideAjaxSaveAndContinue();
        // Activate the auto-save feature passing our fake edit form. Note that autosave.js also creates an instance of
        // AutoSave but it doesn't do anything because it doesn't find a real edit form in the page. This is why we have
        // to create our own instance of AutoSave passing the right (fake) form.
        new XWiki.editors.AutoSave({form: fakeForm});
        var xwikiDocument = actionButtons.data('xwikiDocument');
        // Enable the action buttons (and their shortcut keys) only if we're editing a document.
        actionButtons.find(':input').prop('disabled', !xwikiDocument);
        deferred.resolve(xwikiDocument);
      });
      return deferred.promise();
    }, function() {
      new XWiki.widgets.Notification(
        $jsontool.serialize($services.localization.render('edit.inplace.actionButtons.loadFailed')),
        'error'
      );
    });
  };

  // actionButtons.js expects a form so we use a fake form. Refactoring actionButtons.js is too dangerous ATM.
  var fakeForm = {
    action: XWiki.currentDocument.getURL('save'),
    async: true,
    _getActionButtons: function() {
      if (!this._actionButtons) {
        this._actionButtons = $('#xwikicontent').nextAll('.sticky-buttons-wrapper').children('.sticky-buttons');
      }
      return this._actionButtons;
    },
    disable: function() {
      this._getActionButtons().find(':input').prop('disabled', true);
    },
    enable: function() {
      // Clear the extra hidden input fields, that actionButtons.js might have added, each time the form is (re)enabled
      // (i.e. after a failed Save &amp; View or before entering the edit mode) because they are designed to be used once.
      this._getActionButtons().find('.hidden.extra').empty();
      this._getActionButtons().find(':input').prop('disabled', false);
    },
    insert: function(element) {
      this._getActionButtons().find('.hidden.extra').append(element);
    },
    down: function(selector) {
      return this._getActionButtons().find(selector)[0];
    },
    serialize: function() {
      var extra = this._getActionButtons().find(':input').serializeArray().reduce(function(extra, entry) {
        var value = extra[entry.name] || [];
        value.push(entry.value);
        extra[entry.name] = value;
        return extra;
      }, {});
      var xwikiDocument = this._getActionButtons().data('xwikiDocument');
      var formData = {
        title: xwikiDocument.rawTitle,
        language: xwikiDocument.getRealLocale(),
        isNew: xwikiDocument.isNew
      };
      if (xwikiDocument.content != xwikiDocument.originalDocument.content) {
        // Submit the raw (source) content. No syntax conversion is needed in this case.
        formData.content = xwikiDocument.content;
      } else {
        // Submit the rendered content (HTML), but make sure it is converted to the document syntax on the server.
        $.extend(formData, {
          content: xwikiDocument.renderedContent,
          RequiresHTMLConversion: 'content',
          content_syntax: xwikiDocument.syntax
        });
      }
      // Check for merge conflicts only if the document is not new and we know the current version.
      if (!xwikiDocument.isNew &amp;&amp; xwikiDocument.version) {
        formData.previousVersion = xwikiDocument.version;
        formData.editingVersionDate = new Date(xwikiDocument.modified).getTime();
      }
      return $.extend(formData, extra);
    }
  };

  var overrideEditActions = function() {
    // Override the EditActions.notify() function in order to pass a fake form in the event parameters.
    var originalNotify = XWiki.actionButtons.EditActions.prototype.notify;
    XWiki.actionButtons.EditActions.prototype.notify = function(originalEvent, action, params) {
      if (params &amp;&amp; $(originalEvent.element()).closest('.inplace-editing-buttons').length &gt; 0) {
        // actionButtons.js expects a form so we use a fake form. Refactoring actionButtons.js is too dangerous ATM.
        // Note that we do this only when the event has parameters because we want to exclude the cancel event for which
        // actionButtons.js changes the window location if a form is specified, and we want to prevent that.
        params.form = fakeForm;
      }
      return originalNotify.apply(this, arguments);
    };
  };

  var overrideAjaxSaveAndContinue = function() {
    var originalAjaxSaveAndContinue = $.extend({}, XWiki.actionButtons.AjaxSaveAndContinue.prototype);
    $.extend(XWiki.actionButtons.AjaxSaveAndContinue.prototype, {
      reloadEditor: function() {
        if ($('.inplace-editing-buttons').is(':visible')) {
          $(document).trigger('xwiki:actions:reload');
        } else {
          return originalAjaxSaveAndContinue.reloadEditor.apply(this, arguments);
        }
      },
      maybeRedirect: function(continueEditing) {
        if ($('.inplace-editing-buttons').is(':visible')) {
          // Overwrite the default behavior so that we don't redirect when leaving the edit mode because we're already
          // in view mode. We still need to report a redirect (return true) if we don't continue editing, so that
          // actionButtons.js behaves as if a redirect was done.
          return !continueEditing;
        } else {
          // Fallback on the default behavior if the in-place editing buttons are hidden.
          return originalAjaxSaveAndContinue.maybeRedirect.apply(this, arguments);
        }
      }
    });
  };

  var initTitleEditor = function(xwikiDocument) {
    var label = $('&lt;label for="document-title-input" class="sr-only"/&gt;')
      .text($jsontool.serialize($services.localization.render('core.editors.content.titleField.label')));
    var input = $('&lt;input type="text" id="document-title-input"/&gt;').val(xwikiDocument.rawTitle);
    var placeholder = xwikiDocument.documentReference.name;
    if (placeholder === 'WebHome') {
      placeholder = xwikiDocument.documentReference.parent.name;
    }
    input.attr('placeholder', placeholder);
    $('#document-title h1').addClass('editable').empty().append([label, input]);
    $(document).on('xwiki:actions:beforeSave.titleEditor', function(event) {
      xwikiDocument.rawTitle = input.val();
    });
    $(document).one('xwiki:actions:view', function(event, data) {
      // Destroy the title editor.
      $(document).off('xwiki:actions:beforeSave.titleEditor');
      $('#document-title h1').removeClass('editable').text(xwikiDocument.rawTitle);
    });
    return xwikiDocument;
  };

  var initContentEditor = function(xwikiDocument) {
    var editContent = $('#xwikicontent');
    var withFocus = document.activeElement &amp;&amp; document.activeElement === editContent[0];
    // Keep showing the view content until the edit content is ready in order to avoid UI flicker.
    var viewContent = editContent.clone().insertAfter(editContent);
    // Note that we don't trigger the xwiki:dom:updated event here because we want to let the editor trigger the event
    // only for the content areas that are safe to be updated from JavaScript (i.e. the macro output).
    editContent.hide().html(xwikiDocument.renderedContent);
    if (withFocus) {
      // Keep the focus while the edit content is being prepared.
      viewContent.focus();
    }
    var data = $.extend({}, $('div[data-inplace-editing-config]').data('inplaceEditingConfig'), {
      document: xwikiDocument,
      // The content editor is loaded on demand, asynchronously.
      deferred: $.Deferred()
    });
    var editContentPromise = data.deferred.promise();
    editContentPromise.done(function() {
      editContent.show();
      viewContent.remove();
      if (withFocus) {
        // Restore the focus when the edit content is ready but make sure we don't scroll the page.
        editContent[0].focus({preventScroll: true});
      }
    });
    editContent.trigger('xwiki:actions:edit', data);
    return editContentPromise;
  };

  var startRealTimeEditingSession = function(xwikiDocument) {
    // TODO
    return xwikiDocument;
  };

  var selectText = function(node) {
    if (window.getSelection) {
      var selection = window.getSelection();
      var range = document.createRange();
      range.selectNodeContents(node);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  };

  return {
    preload: preload,
    editPage: editPage,
    editSection: editSection
  };
});

require(['jquery'], function($) {
  // We can edit in-place only if the #xwikicontent element is present.
  if (!$('#xwikicontent').length) {
    return;
  }

  var inplaceEditingConfig = $('div[data-inplace-editing-config]').data('inplaceEditingConfig') || {};
  var wysiwygEditorModule = 'xwiki-' + inplaceEditingConfig.wysiwygEditor + '-inline';

  var preloadEditor = function() {
    require(['editInPlace', wysiwygEditorModule], function(editInPlace) {
      editInPlace.preload();
    // Fallback on the standalone edit mode if we fail to load the required modules.
    }, disableInPlaceEditing);
  };

  // Preload the WYSIWYG editor code without slowing down the page view.
  if (document.readyState === 'complete') {
    setTimeout(preloadEditor, 0);
  } else {
    $(window).on('load', function() {
      setTimeout(preloadEditor, 0);
    });
  }

  var editButton = $('#tmEdit &gt; a');
  editButton.on('click.inPlaceEditing', function(event) {
    event.preventDefault();
    // Make sure the user doesn't try to re-activate the edit mode while we are in edit mode.
    editButton.addClass('disabled');
    // Load the code needed to edit in place only when the edit button is clicked.
    require(['editInPlace', wysiwygEditorModule], function(editInPlace) {
      editInPlace.editPage().always(function() {
        editButton.removeClass('disabled');
      });
    // Fallback on the standalone edit mode if we fail to load the required modules.
    }, $.proxy(disableInPlaceEditing, event.target));
  });

  // Section in-place editing.
  $('#xwikicontent').on('click.inPlaceEditing', '&gt; :header &gt; a.edit_section:not(.disabled)', function(event) {
    event.preventDefault();
    // Make sure the user doesn't try to re-activate the edit mode while we are in edit mode.
    editButton.addClass('disabled');
    // Hide the section editing links and focus the content right away. We could have replaced the section editing icon
    // with a loading animation / spinner but giving instant visual feedback about what is going to happen is perceived
    // better by the users (it feels faster).
    $('#xwikicontent').attr('tabindex', '0').focus().children(':header').children('.edit_section').addClass('hidden');
    var heading = $(event.target).closest(':header');
    // Load the code needed to edit in place only when the edit button is clicked.
    require(['editInPlace', wysiwygEditorModule], function(editInPlace) {
      editInPlace.editSection(heading.attr('id')).always(function() {
        editButton.removeClass('disabled');
      });
    // Fallback on the standalone edit mode if we fail to load the required modules.
    }, $.proxy(disableInPlaceEditing, event.target));
  });

  var disableInPlaceEditing = function() {
    editButton.off('click.inPlaceEditing').removeClass('disabled');
    $('#xwikicontent').off('click.inPlaceEditing').removeAttr('tabindex').children(':header').children('.edit_section')
      .removeClass('hidden');
    // Fallback on the standalone edit mode.
    $(this).click();
  };
});</code>
    </property>
    <property>
      <name/>
    </property>
    <property>
      <parse>1</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>XWiki.InplaceEditing</name>
    <number>0</number>
    <className>XWiki.StyleSheetExtension</className>
    <guid>bd0e5f70-8c74-48e4-97b9-81620b5d9394</guid>
    <class>
      <name>XWiki.StyleSheetExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <defaultValue>long</defaultValue>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <contentType>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>contentType</name>
        <number>6</number>
        <prettyName>Content Type</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>CSS|LESS</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </contentType>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage|onDemand|always</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>#document-title h1.editable {
  /* Move the title heading a bit to the top and to the left in order to accomodate the input border and padding. */
  margin-top: -@line-height-computed / 4;
  margin-left: -(ceil(@grid-gutter-width / 2));
  /* Reduce the bottom margin in order to accomodate the input border and bottom padding. */
  margin-bottom: @line-height-computed / 4;
}

@document-title-input-padding-vertical: @line-height-computed / 4 - 1;
input#document-title-input {
  /* Preserve the heading styles. */
  border: 1px solid transparent;
  box-shadow: none;
  color: inherit;
  font-size: inherit;
  /* It seems it's not enough to set the line height for the text input. We also need to set its height. */
  height: @font-size-document-title * @headings-line-height + 2 * (1 + @document-title-input-padding-vertical);
  line-height: @headings-line-height;
  padding: @document-title-input-padding-vertical (ceil(@grid-gutter-width / 2) - 1);
  width: 100%;
}

input#document-title-input:hover {
  border-color: @input-border;
}

input#document-title-input:focus,
#xwikicontent[contenteditable]:focus,
#xwikicontent[tabindex]:focus {
  .form-control-focus();
}

#xwikicontent[contenteditable],
#xwikicontent[tabindex] {
  border: 1px solid transparent;
  margin-top: -1px;
  margin-left: -1px;
}

#xwikicontent.loading {
  background: none;
  cursor: wait;
}

/* Leave more space at the top of the edited content by reducing the margin bottom of the preceding horizontal rule. */
.document-header + hr {
  margin-bottom: @line-height-computed / 4;
}
#xwikicontent {
  padding-top: @line-height-computed * 0.75;
}

.sticky-buttons-wrapper {
  /* Leave some space for the bottom box shadow of the editing area. */
  margin-top: 7px;
}</code>
    </property>
    <property>
      <contentType>LESS</contentType>
    </property>
    <property>
      <name/>
    </property>
    <property>
      <parse>0</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>XWiki.InplaceEditing</name>
    <number>0</number>
    <className>XWiki.UIExtensionClass</className>
    <guid>5c7fd93e-a308-4bd0-a53a-5e4d54b2640c</guid>
    <class>
      <name>XWiki.UIExtensionClass</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <async_cached>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_cached</name>
        <number>3</number>
        <prettyName>Cached</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_cached>
      <async_context>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>1</multiSelect>
        <name>async_context</name>
        <number>4</number>
        <prettyName>Context elements</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>5</size>
        <unmodifiable>0</unmodifiable>
        <values>doc.reference=Document|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.parameters=Request parameters|request.url=Request URL|request.wiki=Request wiki|user=User|wiki=Wiki</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </async_context>
      <async_enabled>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_enabled</name>
        <number>2</number>
        <prettyName>Asynchronous rendering</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_enabled>
      <content>
        <disabled>0</disabled>
        <editor>Text</editor>
        <name>content</name>
        <number>1</number>
        <prettyName>Executed Content</prettyName>
        <rows>25</rows>
        <size>120</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </content>
      <extensionPointId>
        <disabled>0</disabled>
        <name>extensionPointId</name>
        <number>5</number>
        <prettyName>Extension Point ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </extensionPointId>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>6</number>
        <prettyName>Extension ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parameters>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>parameters</name>
        <number>7</number>
        <prettyName>Extension Parameters</prettyName>
        <rows>10</rows>
        <size>40</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </parameters>
      <scope>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>scope</name>
        <number>8</number>
        <prettyName>Extension Scope</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>wiki=Current Wiki|user=Current User|global=Global</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </scope>
    </class>
    <property>
      <async_cached>0</async_cached>
    </property>
    <property>
      <async_context/>
    </property>
    <property>
      <async_enabled>0</async_enabled>
    </property>
    <property>
      <content>{{velocity}}
{{html clean="false"}}
#if ($services.edit.document.inPlaceEditingEnabled() &amp;&amp; $hasEdit &amp;&amp; $xcontext.action == 'view' &amp;&amp; !$doc.isNew())
  ## We support in-place editing only for the WYSIWYG edit mode ATM.
  #getDefaultDocumentEditor($defaultEditMode)
  #if ($defaultEditMode == 'wysiwyg')
    ## We have to explicitly enable the source mode for in-line edit because the latest version of the content editor
    ## could be installed on an older version of XWiki where the in-place editor didn't support the source mode (so the
    ## content editor cannot enable the source mode by default).
    #set ($inplaceEditingConfig = {
      'contentType': 'org.xwiki.rendering.syntax.SyntaxContent',
      'editMode': $defaultEditMode,
      'wysiwygEditor': $services.edit.syntaxContent.defaultWysiwygEditor.descriptor.id,
      'enableSourceMode': true,
      'enableOfficeImport': $services.officemanager.isConnected()
    })
    &lt;div class="hidden" data-inplace-editing-config="$escapetool.xml($jsontool.serialize($inplaceEditingConfig))"&gt;&lt;/div&gt;
    ## We didn't move this to the file system because it uses LESS and we didn't want to include it in the skin.
    #set ($discard = $xwiki.ssx.use('XWiki.InplaceEditing'))
    ## We can't move this to a WebJar until we have XWIKI-12788 (Introduce skin extension plugins for webjar resources).
    #set ($discard = $xwiki.jsx.use('XWiki.InplaceEditing'))
  #end
#end
{{/html}}
{{/velocity}}</content>
    </property>
    <property>
      <extensionPointId>org.xwiki.platform.template.header.after</extensionPointId>
    </property>
    <property>
      <name>org.xwiki.platform.template.header.after.inplaceEditing</name>
    </property>
    <property>
      <parameters/>
    </property>
    <property>
      <scope>wiki</scope>
    </property>
  </object>
  <object>
    <name>XWiki.InplaceEditing</name>
    <number>1</number>
    <className>XWiki.UIExtensionClass</className>
    <guid>13939f90-1cd4-4517-8c42-2dbeee198357</guid>
    <class>
      <name>XWiki.UIExtensionClass</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <async_cached>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_cached</name>
        <number>3</number>
        <prettyName>Cached</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_cached>
      <async_context>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>1</multiSelect>
        <name>async_context</name>
        <number>4</number>
        <prettyName>Context elements</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>5</size>
        <unmodifiable>0</unmodifiable>
        <values>doc.reference=Document|icon.theme=Icon theme|locale=Language|rendering.defaultsyntax=Default syntax|rendering.restricted=Restricted|rendering.targetsyntax=Target syntax|request.base=Request base URL|request.parameters=Request parameters|request.url=Request URL|request.wiki=Request wiki|user=User|wiki=Wiki</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </async_context>
      <async_enabled>
        <defaultValue>0</defaultValue>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType/>
        <name>async_enabled</name>
        <number>2</number>
        <prettyName>Asynchronous rendering</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </async_enabled>
      <content>
        <disabled>0</disabled>
        <editor>Text</editor>
        <name>content</name>
        <number>1</number>
        <prettyName>Executed Content</prettyName>
        <rows>25</rows>
        <size>120</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </content>
      <extensionPointId>
        <disabled>0</disabled>
        <name>extensionPointId</name>
        <number>5</number>
        <prettyName>Extension Point ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </extensionPointId>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>6</number>
        <prettyName>Extension ID</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parameters>
        <contenttype>PureText</contenttype>
        <disabled>0</disabled>
        <editor>PureText</editor>
        <name>parameters</name>
        <number>7</number>
        <prettyName>Extension Parameters</prettyName>
        <rows>10</rows>
        <size>40</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </parameters>
      <scope>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <freeText>forbidden</freeText>
        <largeStorage>0</largeStorage>
        <multiSelect>0</multiSelect>
        <name>scope</name>
        <number>8</number>
        <prettyName>Extension Scope</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators>|, </separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>wiki=Current Wiki|user=Current User|global=Global</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </scope>
    </class>
    <property>
      <async_cached>0</async_cached>
    </property>
    <property>
      <async_context/>
    </property>
    <property>
      <async_enabled>0</async_enabled>
    </property>
    <property>
      <content>{{velocity}}
{{html clean="false"}}
## Output the translation button if all the following conditions are met:
## * multilingual is on
## * we're loading the original document version
## * the original document version has a locale specified (it doesn't make sense to translate technical documents)
## * the current UI locale doesn't match the original document locale
#if ($services.edit.document.inPlaceEditingEnabled() &amp;&amp; $hasEdit &amp;&amp; $xwiki.isMultiLingual()
    &amp;&amp; $tdoc.realLocale == $doc.realLocale &amp;&amp; "$!doc.realLocale" != '' &amp;&amp; $doc.realLocale != $xcontext.locale)
  #set ($url = $doc.getURL('edit', $escapetool.url({'language': $xcontext.locale})))
  #set ($hint = $services.localization.render('edit.inplace.page.translate.hint',
    [$xcontext.locale.getDisplayName($xcontext.locale)]))
  ## We show the translate button only while editing in-place.
  &lt;div class="btn-group hidden" id="tmTranslate"&gt;
    &lt;a class="btn btn-default" href="$url" role="button" title="$escapetool.xml($hint)"&gt;
      $services.icon.renderHTML('translate')
      &lt;span class="btn-label"&gt;$escapetool.xml($services.localization.render('edit.inplace.page.translate'))&lt;/span&gt;
    &lt;/a&gt;
  &lt;/div&gt;
#end
{{/html}}
{{/velocity}}</content>
    </property>
    <property>
      <extensionPointId>org.xwiki.plaftorm.menu.content</extensionPointId>
    </property>
    <property>
      <name>org.xwiki.plaftorm.menu.content.translate</name>
    </property>
    <property>
      <parameters>order=5000</parameters>
    </property>
    <property>
      <scope>wiki</scope>
    </property>
  </object>
</xwikidoc>
